<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux</title>
      <link href="/2023/11/25/Linux/"/>
      <url>/2023/11/25/Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h1><h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><ul><li>一系列输入输出设备的总称</li></ul><h3 id="shell家族"><a href="#shell家族" class="headerlink" title="shell家族"></a>shell家族</h3><ul><li>shell：命令解释器，根据输入的命令执行相应命令。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看当前系统有哪些shell：</span><br><span class="line">  <span class="built_in">cat</span> /etc/shells</span><br><span class="line">查看当前系统正在使用的shell：</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br></pre></td></tr></table></figure><p>Unix–&gt;shell</p><p>Linux–&gt;bash</p><h2 id="类Unix系统目录"><a href="#类Unix系统目录" class="headerlink" title="类Unix系统目录"></a>类Unix系统目录</h2><ul><li><p>根目录下bin存放二进制可执行文件</p></li><li><p>根目录下boot存放开机时的启动程序</p></li><li><p>根目录下dev存放设备文件</p></li><li><p>根目录下etc存放用户信息和相关配置文件</p></li><li><p>根目录下home存放用户</p></li><li><p>根目录下root存放宿主目录(家目录)</p></li><li><p>根目录下lib存放库路径</p></li><li><p>根目录下media，mnt用于挂载磁盘和卸载磁盘</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">插入磁盘，挂载成文件，默认在media下</span><br></pre></td></tr></table></figure><ul><li>根目录下usr存放第三方应用库(用户资源管理目录)</li></ul><h2 id="Linux命令基础"><a href="#Linux命令基础" class="headerlink" title="Linux命令基础"></a>Linux命令基础</h2><ol><li>什么是命令，命令行</li></ol><ul><li>命令：即Linux操作指令，是系统内置的程序，可以以字符化的形式去使用。</li><li>命令行：即Linux终端，可以提供字符化的操作页面供命令执行。</li></ul><ol start="2"><li>Linux命令的通用格式</li></ol><ul><li>command(命令本身) [-options(可选，命令的一些选项，可以通过选项控制命令的行为细节)] [parameter(可选，命令的参数，多数用于i命令的指向目标)]</li></ul><h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><ol><li>ls命令参数的作用</li></ol><ul><li>可以指定要查看的文件夹(目录)的内容，如果不给定参数，要查看当前工作目录的内容。</li></ul><ol start="2"><li>ls命令的选项</li></ol><ul><li><p>-a选项，可以展示出隐藏的内容</p><p> 以’.’开头的文件或文件夹默认被隐藏，需要-a才能显示出来</p></li><li><p>-l选项，以列表的形式展示内容，并展示更多细节</p></li><li><p>-h选项，需要和-l选项搭配使用，以更加人性化的方式显示文件的大小单位</p></li><li><p><strong>-d选项，查看目录本身</strong></p></li><li><p>-R选项，递归展示所有信息，包括文件夹内的</p></li></ul><ol start="3"><li>命令的选项组合使用</li></ol><ul><li>命令的选项是可以组合使用的，比如：ls-lah等同于ls-a-l-h</li></ul><h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h3><ol><li>cd命令的作用</li></ol><ul><li><p>cd命令可以切换当前工作目录，语法是：cd [Linux路径]</p><p>没有选项，只有参数，表示目标路径</p><p>使用参数，切换到指定路径</p><p>不使用参数，切换工作目录到当前用户的HOME</p></li></ul><ol start="2"><li>特殊路径符</li></ol><ul><li>‘.’   表示当前目录，比如cd .&#x2F;Desktop表示切换到当前目录下的Desktop目录内，和cd Desktop效果一致</li><li>‘..’  表示上一级目录，比如：cd .. 即可切换到上一级目录，cd ..&#x2F;.. 切换到上二级的目录</li><li>‘~’  表示HOME目录，比如：cd ~ 即可切换到HOME目录或cd ~&#x2F;Desktop &#x3D; cd &#x2F;home&#x2F;wzhvv&#x2F;Desktop 切换到HOME内的Desktop目录</li><li>‘-‘，cd -表示返回进入此目录之前的目录</li></ul><h3 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h3><ul><li>pwd命令，没有选项，没有参数，直接使用即可</li><li>作用：输出当前所在的工作目录</li></ul><h3 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h3><ol><li>mkdir命令的语法和功能</li></ol><ul><li>mkdir用以创建新的目录(文件夹)</li><li>语法：mkdir [-p] Linux路径</li><li>参数必填，表示要创建的目录的路径，相对，绝对，特殊路径符都可以使用</li></ul><ol start="2"><li>-p选项的作用</li></ol><ul><li>可选，表示自动创建不存在的父目录，适用于创建连续多层级的目录</li></ul><h3 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h3><ul><li>用于创建一个新文件</li><li>语法：touch Linux路径</li><li>参数必填，表示要创建的文件的路径，相对，绝对，特殊路径都可以使用</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> <span class="string">&#x27;abc xyz&#x27;</span> 或 <span class="built_in">touch</span> abc\ xyz</span><br></pre></td></tr></table></figure><h3 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h3><ul><li>用于查看文件内容</li><li>语法：cat Linux路径</li><li>参数必填，表示要查看的文件的路径，相对，绝对路径符都可以使用</li><li>直接使用cat，可以读终端，输什么显示什么</li><li><strong>倒着写成tac，文件输出从下往上</strong></li></ul><h3 id="more-x2F-less命令"><a href="#more-x2F-less命令" class="headerlink" title="more&#x2F;less命令"></a>more&#x2F;less命令</h3><ul><li>用于查看文件的内容，可翻页查看</li><li>语法：more Linux路径</li><li>参数必填，表示要查看的文件的路径，相对，绝对，特殊路径符都可以使用</li><li>使用空格进行翻页，使用q退出查看，也可以ctrl+c退出，但less只能用q退出</li></ul><h3 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h3><ul><li>默认显示文件前十行</li><li>可以指定行数</li></ul><h3 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h3><ul><li>查看文件尾部内容，并且可以持续追踪</li><li>语法：tail [-f  -num] linux路径</li><li>-f：持续跟踪，-num：启动的时候查看尾部多少行，默认10</li><li>linux路径，表示被查看的文件</li></ul><h3 id="tree命令"><a href="#tree命令" class="headerlink" title="tree命令"></a>tree命令</h3><ul><li>按结构树的形状显示文件和目录</li></ul><h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h3><ul><li>用于复制文件和文件夹</li><li>语法：cp [-r] 参数1 参数2</li><li>-r选项，可选，用于复制文件夹使用，表示递归</li><li>-a选项，可选，复制全部文件和文件夹，文件时间不变</li><li>参数1，linux路径，表示被复制的文件或文件夹</li><li>参数2，linux路径，表示要复制去的地方</li></ul><h3 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h3><ul><li>用于移动文件和文件夹</li><li>语法：mv 参数1 参数2</li><li>参数1，linux路径，表示被移动的文件或文件夹</li><li>参数2，linux路径，表示要移动去的地方，如果目标不存在，则进行改名，确保目标存在</li></ul><h3 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h3><ul><li>用于删除文件和文件夹</li><li>语法： rm [-r -f] 参数1 参数2 … 参数n</li><li>-r选项， 可选，文件夹删除</li><li>-f选项，可选，用于强制删除(不提示，一般用于root用户)</li><li>参数，表示被删除的文件或文件夹路径，支持多个，空格隔开</li><li>参数也支持通配符*，用以做模糊匹配</li></ul><h3 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h3><ul><li>查找命令所在的程序文件</li><li>语法：which  要查找的命令</li><li>无需选项，只需要参数表示查找哪个命令</li></ul><h3 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h3><ul><li><strong>用于查找指定的文件</strong></li><li>按文件名查找：find 起始路径 -name “被查找文件名”<ul><li>支持通配符</li><li>符号*表示通配符，即匹配任意内容(包括空)</li><li>test*，表示匹配任何以test开头的内容</li><li>*test，表示匹配任何以test结尾的内容</li><li>*test *，表示匹配任何包含test的内容</li></ul></li><li>按文件大小查找：find 起始路径 -size   +|-    n[kMG]<ul><li>+，-表示大于和小于</li><li>n表示大小数字</li><li>kMG表示大小单位，k(小写字母)表示kb，M表示MB，G表示GB。默认为b，一块-&gt;512byte</li></ul></li><li>-type 按文件类型搜索</li><li>-maxdepth 指定搜索深度</li><li>atime(访问)，mtime(属性修改)，ctime(文件内容修改) 天</li><li>-exec：将find搜索的结果集执行某一指定命令</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /usr/ -name <span class="string">&quot;*tmp*&quot;</span> -<span class="built_in">exec</span> <span class="built_in">ls</span> -l &#123;&#125; \; --&#123;&#125;：将-<span class="built_in">exec</span>前面的内容放入&#123;&#125;中执行</span><br></pre></td></tr></table></figure><ul><li>-ok：以交互式的方式将find搜索的结果集执行某一指定命令</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find ./ -name <span class="string">&quot;*tmp&quot;</span> -ok <span class="built_in">rm</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure><ul><li>-xargs：将find搜索的结果集执行某一指定命令。当结果集数量过大时，可以分片映射。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /usr/ -name <span class="string">&#x27;*tmp*&#x27;</span> | xargs <span class="built_in">ls</span> -ld //默认以空格作为拆分依据</span><br></pre></td></tr></table></figure><ul><li>print0</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /usr/ -name <span class="string">&#x27;*tmp*&#x27;</span> -print0 | xargs -print0 <span class="built_in">ls</span> -ld //此时默认以null作为拆分依据</span><br><span class="line">find /usr/ -name <span class="string">&#x27;*tmp*&#x27;</span> -print0 | xargs -0 <span class="built_in">ls</span> -ld //此时不询问</span><br></pre></td></tr></table></figure><h3 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h3><ul><li><strong>找文件内容</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -r <span class="string">&#x27;copy&#x27;</span> ./ -n</span><br><span class="line">ps aux | grep <span class="string">&#x27;cupsd&#x27;</span> --检索进程结果集</span><br></pre></td></tr></table></figure><ul><li>从文件中通过关键字过滤文件行</li><li>语法：grep [-n] 关键字  文件路径</li><li>选项-n，可选，表示在结果中显示匹配的行的行号</li><li>参数，关键字，必填，表示过滤的关键字，带有空格或其他特殊符号，建议使用” “将关键字包围起来</li><li>参数，文件路径，必填，表示要过滤内容的文件路径，<strong>可作为管道符的输入</strong></li></ul><h3 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h3><ul><li>命令统计文件的行数，单词数量，字节数，字符数等</li><li>语法：wc [-c -m -l -w] 文件路径</li><li>不带选项默认统计：行数，单词数，字节数</li><li>-c字节数，-m字符数，-l行数，-w单词数</li><li>参数，被统计的文件路径，可作为管道符的输入</li></ul><h3 id="whoami命令"><a href="#whoami命令" class="headerlink" title="whoami命令"></a>whoami命令</h3><ul><li>查看当前登录用户</li></ul><h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符 |"></a>管道符 |</h3><ul><li>将管道符左边命令的结果，作为右边命令的输入</li></ul><h3 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h3><ul><li>可以使用echo命令在命令行内输出指定内容</li><li>语法：echo 输出的内容**(env：查看所有环境变量)**</li><li>无需选项，只有一个参数，表示要输出的内容，复杂内容可以用” “包围</li></ul><h3 id="96-反引号符"><a href="#96-反引号符" class="headerlink" title="&#96;反引号符"></a>&#96;反引号符</h3><ul><li>被&#96;包围的内容，会被<strong>作为命令执行</strong>，而非普通字符</li></ul><h3 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h3><ul><li>“&gt;”，将左侧命令的结果，覆盖写入到符号右侧指定的文件中</li><li>“&gt;&gt;”，将左侧命令的结果，追加写入到符号右侧指定的文件中</li></ul><h3 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307211010017.png" alt="vi/vim编辑器"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入还可以是：I A O S s</span><br><span class="line">命令模式退出：ZZ(保存 退出)</span><br><span class="line">末行模式返回命令模式：ESC 2次 或 执行末行命令</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i：插入光标前一个字符</span><br><span class="line">I：插入行首</span><br><span class="line">a：插入光标后一个字符</span><br><span class="line">A：插入行末</span><br><span class="line">o：向下新开一行，插入行首</span><br><span class="line">O：向上新开一行，插入行首</span><br><span class="line">s：删除当前光标，插入</span><br><span class="line">S：删除当前行，插入</span><br></pre></td></tr></table></figure><h3 id="vi基本快捷键"><a href="#vi基本快捷键" class="headerlink" title="vi基本快捷键"></a>vi基本快捷键</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">跳转到指定行：1. 88G(命令模式) 2. 88(末行模式)</span><br><span class="line">跳转文件首：gg(命令模式)</span><br><span class="line">跳转文件尾：G(命令模式)</span><br><span class="line">自动格式化程序：gg=G(命令模式)</span><br><span class="line">大括号对应：%(命令模式)</span><br><span class="line">光标移至行首：0(命令模式) 执行结束，工作模式不变</span><br><span class="line">光标移至行尾：$(命令模式) 执行结束，工作模式不变</span><br><span class="line">删除单个字符：x(命令模式) 执行结束，工作模式不变</span><br><span class="line">替换单个字符：将待替换的字符用光标选中，r(命令模式)，再按预替换的字符</span><br><span class="line">删除一个单词：dw(命令模式) 光标置于单词的首字母进行操作</span><br><span class="line">删除光标至行尾：D 或 d$(命令模式)</span><br><span class="line">删除光标至行首：d0(命令模式)</span><br><span class="line">删除指定区域：按v(命令模式) 切换为 <span class="string">&quot;可视模式&quot;</span>，使用 hjkl 挪移光标来选中待删除区域。按 d 删除该区域数据</span><br><span class="line">删除指定一行：在光标所在行，按<span class="built_in">dd</span>(命令模式)</span><br><span class="line">删除指定N行：在光标所在行，按Ndd(命令模式)</span><br><span class="line">复制一行：yy</span><br><span class="line">粘贴：p：向后 P：向前(删除本质是剪切)</span><br><span class="line">查找：1.找设想内容：命令模式下，按“/”输入欲搜索关键字，回车。使用n检索下一个</span><br><span class="line">     2.找看到的内容：命令模式下，将光标置于单词任意一个字符上，按“*”(向下找) 或 “<span class="comment">#”(向上找)</span></span><br><span class="line">单行替换：将光标置于待替换行上，进入末行模式，输入 :s /原数据/新数据</span><br><span class="line">通篇替换：末行模式下，输入 :%s /原数据/新数据/g g：不加，只替换每行首个</span><br><span class="line">指定行的替换：末行模式下， :起始行号,终止行号s /原数据/新数据/g g：不加，只替换每行首个</span><br><span class="line">            :29,35s /printf/println/g  </span><br><span class="line">撤销，反撤销：u ctrl+r   (命令模式)</span><br><span class="line">分屏：sp：横屏分 ctrl+ww切换</span><br><span class="line">     vsp：竖屏分 ctrl+ww切换</span><br><span class="line">跳转至man手册：将光标置于待查看函数单词上，使用K(命令模式)跳转。指定卷，nK (1：一卷表命令，2：二卷系统调用，3：三卷是库...) </span><br><span class="line">查看宏定义：将光标置于待查看宏定义单词上，使用 [d 查看定义语句</span><br><span class="line">在末行模式执行shell命令：:!命令 -&gt; :!<span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure><h3 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h3><ol><li>&#x2F;etc&#x2F;vim&#x2F;vimrc</li><li>~&#x2F;.vimrc</li><li>~&#x2F;.vimrc优先级高</li></ol><h3 id="Linux的root用户-超级管理员"><a href="#Linux的root用户-超级管理员" class="headerlink" title="Linux的root用户(超级管理员)"></a>Linux的root用户(超级管理员)</h3><p>root用户拥有最大的系统操作权限，而普通用户在许多地方的权限是受限的。</p><ul><li>普通用户的权限，一般在其HOME目录内是不受限的</li><li>一旦出了HOME目录，大多数地方，普通用户仅有只读和执行权限，无修改权限</li></ul><h4 id="su命令"><a href="#su命令" class="headerlink" title="su命令"></a>su命令</h4><ul><li><p>su命令就是用于账户切换的系统命令，其来源英文单词：Switch User</p></li><li><p>语法：su [-] [用户名]</p></li><li><p>“-“ 符号是可选的，表示是否在切换用户后加载环境变量，建议带上</p></li><li><p>参数：用户名，表示要切换的用户，用户名也可以省略，省略表示切换到root</p></li><li><p>切换用户后，可以通过exit命令退回上一个用户，也可以使用快捷键：ctrl+d</p></li><li><p>使用普通用户，切换到其他用户需要输入密码，如切换到root用户</p></li><li><p>使用root用户切换到其他用户，无需密码，可以直接切换</p></li></ul><h4 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h4><p>在我们得知root密码的时候，可以通过su命令切换到root得到最大权限</p><p>但是我们不建议长期使用root用户，避免带来系统损坏</p><p>我们可以使用sudo命令，为普通的命令授权，临时以root身份执行</p><ul><li>语法：sudo 其他命令</li><li>在其他命令之前，带上sudo，即可为一条命令临时赋予root授权</li><li>但是并不是所有的用户，都有权力使用sudo，我们需要为普通用户配置sudo认证</li></ul><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307211010234.png" alt="sudo认证"></p><h3 id="用户，用户组"><a href="#用户，用户组" class="headerlink" title="用户，用户组"></a>用户，用户组</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307211010056.png" alt="image-20230502161110601"></p><h4 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h4><p>以下命令需root用户执行</p><ul><li>创建用户组</li></ul><p>groupadd 用户组名</p><ul><li>删除用户组</li></ul><p>groupdel 用户组名</p><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p>以下命令需root用户执行</p><ul><li>创建用户</li></ul><p>useradd [-g -d] 用户名</p><ul><li><p>选项：-g指定用户的组，不指定-g，会创建同名组并自动加入，指定-g需要组已经存在，如已存在同名组，必须使用-g</p></li><li><p>选项：-d指定用户HOME路径，不指定，HOME目录默认在：&#x2F;home&#x2F;用户名</p></li><li><p>删除用户</p></li></ul><p>userdel [-r] 用户名</p><ul><li><p>选项：-r，删除用户的HOME目录，不使用-r，删除用户时，HOME目录保留</p></li><li><p>查看用户所属组</p></li></ul><p>id[用户名]</p><ul><li><p>参数：用户名，被查看的用户，如果不提供则查看自身</p></li><li><p>修改用户所属组</p></li></ul><p>usermod -aG 用户组 用户名，将指定用户加入指定用户组</p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307211010030.png" alt="image-20230502163205161"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307211010683.png" alt="image-20230502163242470"></p><h3 id="查看权限控制信息"><a href="#查看权限控制信息" class="headerlink" title="查看权限控制信息"></a>查看权限控制信息</h3><h4 id="认知权限信息"><a href="#认知权限信息" class="headerlink" title="认知权限信息"></a>认知权限信息</h4><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307211010192.png" alt="Snipaste_2023-05-03_09-49-46"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307211010851.png" alt="屏幕截图 2023-03-11 194556"></p><h4 id="rwx"><a href="#rwx" class="headerlink" title="rwx"></a>rwx</h4><ul><li>r表示读权限</li><li>w表示写权限</li><li>x表示执行权限</li></ul><p>针对文件，文件夹的不同，rwx的含义有细微差别</p><ul><li>r，针对文件可以查看文件内容<ul><li>针对文件夹，可以查看文件夹内容，如ls命令</li></ul></li><li>w，针对文件表示可以修改此文件<ul><li>针对文件夹，可以在文件夹内：创建，删除，改名等操作</li></ul></li><li>x，针对文件表示可以将文件作为程序执行<ul><li>针对文件夹，表示可以更改工作目录到此文件夹，即cd进入</li></ul></li></ul><h4 id="Linux系统文件类型"><a href="#Linux系统文件类型" class="headerlink" title="Linux系统文件类型"></a>Linux系统文件类型</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">普通文件：-</span><br><span class="line">目录文件：d</span><br><span class="line">字符设备文件：c</span><br><span class="line">块设备文件：b</span><br><span class="line">软链接：l</span><br><span class="line">管道文件：p</span><br><span class="line">套接字：s</span><br><span class="line">未知文件</span><br></pre></td></tr></table></figure><h3 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h3><ul><li>功能：修改文件，文件夹的权限细节</li><li>限制：只能是文件，文件夹的所属用户或root用户有权修改</li><li>语法：chmod [-R] 权限 文件或文件夹</li><li>选项：-R，对文件夹内的全部内容应用同样的规则</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">-chmod u=rwx,g=rx,o=x hello.txt，将文件权限修改为：rwx r-x --x</span><br><span class="line"> 其中：u表示user所属用户权限，g表示group组权限，o表示other其他用户权限 a表示所有(all)用户，系统默认值</span><br><span class="line">-chmod -R u=rwx,g=rx,o=x test，将文件夹test以及文件夹内全部内容权限设置为：rwx r-x --x</span><br><span class="line">-chmod [who] [+ | - | =] [mode] 文件名</span><br><span class="line">+：添加某个权限。</span><br><span class="line">-：取消某个权限。</span><br><span class="line">=：赋予给定权限并取消其他所有权限(如果有的话)。</span><br></pre></td></tr></table></figure><h4 id="权限的数字序号"><a href="#权限的数字序号" class="headerlink" title="权限的数字序号"></a>权限的数字序号</h4><ul><li>r代表4，w代表2，x代表1</li><li>rwx的相互组合可以得到从0到7的8种权限组合</li><li>如7代表：rwx，5代表：r-x，1代表：–x</li></ul><h3 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h3><ul><li>功能：修改文件，文件夹的所属用户，用户组</li><li>限制：只可root执行</li><li>语法：chown [-R] [用户] [:] [用户组] 文件或文件夹<ul><li>选项，-R，同chmod。对文件夹内全部内容应用相同规则</li><li>选项，用户，修改所属用户</li><li>选项，用户组，修改所属用户组</li><li>：，用于分割用户和用户组</li></ul></li></ul><p>示例：</p><ul><li>chown root hello.txt，将hello.txt<strong>所属用户</strong>修改为root</li><li>chown :root hello.txt，将hello.txt<strong>所属用户组</strong>修改为root</li><li>chown root:whvv hello.txt，将hello.txt所属用户修改为root，用户组修改为wzhvv</li><li>chown -R root test，将文件夹test的所属用户修改为root并对文件夹内全部内容应用同样规则</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">创建用户：sudo adduser 新用户名</span><br><span class="line">修改文件所属用户：sudo <span class="built_in">chown</span> 新用户名 待修改文件</span><br><span class="line">删除用户：sudo deluser 用户名</span><br><span class="line">创建用户组：sudo addgroup 新组名</span><br><span class="line">修改所属用户组：sudo <span class="built_in">chgrp</span> 新用组户 待修改文件</span><br><span class="line">删除组：sudo delgroup 用户组名</span><br></pre></td></tr></table></figure><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li>“ctrl + c”，强制停止</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1，Linux某些程序的运行，如果想要强制停止它，可以使用快捷键ctrl+c</span><br><span class="line">2，命令输入错误，也可以通过快捷键ctrl+c，退出当前输入，重新输入</span><br></pre></td></tr></table></figure><ul><li>“ctrl+z”，暂停到后台，使用<strong>fg</strong>恢复。</li><li>“ctrl + d”，退出或登出</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1，可以通过快捷键：ctrl + d，退出账户的登录</span><br><span class="line">2，或者退出某些特定程序的专属页面</span><br><span class="line">ps：不能用于退出vi/vim</span><br></pre></td></tr></table></figure><ul><li>历史命令搜索</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1，可以通过history命令，查看历史输入过的命令</span><br><span class="line">2，可以通过!命令前缀，自动执行上一次匹配前缀的命令</span><br><span class="line">3，可以通过快捷键：ctrl + r，输入内容去匹配历史命令</span><br><span class="line">如果搜索到的内容是你需要的，那么：</span><br><span class="line">- 回车键可以直接执行</span><br><span class="line">- 键盘左右键，可以得到此命令(不执行)</span><br><span class="line">4，ctrl+p 查看上一条指令</span><br><span class="line">5，ctrl+n 查看下一条指令</span><br></pre></td></tr></table></figure><ul><li>光标移动快捷键</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctrl + a，跳到命令开头</span><br><span class="line">ctrl + e，跳到命令结尾</span><br><span class="line">ctrl + 键盘左键，向左跳一个单词</span><br><span class="line">ctrl + 键盘右键，向右跳一个单词</span><br></pre></td></tr></table></figure><ul><li>清屏</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">通过快捷键ctrl + l，可以清空终端内容</span><br><span class="line">或通过命令clear得到同样效果</span><br></pre></td></tr></table></figure><ul><li>命令和路径补齐</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在bash下敲命令时，Tab键可以补全已经敲了一部分的文件名和目录名。在Ubuntu系统下，默认启用了bash completion，可以补全命令的某些参数，Makefile目标等。</span><br></pre></td></tr></table></figure><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p>apt：deb包软件管理器，用于自动化安装配置Linux软件，并可以自动解决依赖问题。</p><p>语法：apt [-y] [install | remove | search] 软件名称</p><ul><li>选项：-y，自动确认，无需手动确认安装或卸载过程</li><li>install：安装</li><li>remove：卸载</li><li>search：搜索</li></ul><p>apt命令需要root权限，需要联网</p><ul><li>使用软件包(.deb)安装：sudo dpkg -i 安装包名</li></ul><h3 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h3><p>作用：可以控制软件(服务)的启动，关闭，开机自启动</p><ul><li>系统内置服务均可被systemctl控制</li><li>第三方软件，如果自动注册了可以被systemctl控制</li><li>第三方软件，如果没有自动注册，可以手动注册</li></ul><p>语法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start | stop | status | enable | disable 服务名</span><br></pre></td></tr></table></figure><ul><li>start 启动</li><li>stop 关闭</li><li>status 查看状态</li><li>enable 开启开机自启</li><li>disable 关闭开机自启</li></ul><h3 id="ln命令创建软链接"><a href="#ln命令创建软链接" class="headerlink" title="ln命令创建软链接"></a>ln命令创建软链接</h3><p>在系统中创建软链接，可以将文件，文件夹链接到其它位置</p><p>类似Windows系统中的<strong>快捷方式</strong></p><p>语法：ln -s 参数1 参数2</p><ul><li>-s选项，创建软链接</li><li>参数1：被链接的文件或文件夹</li><li>参数2：要链接去的目的地</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">参数1默认是相对路径，当将参数2移动时将无法正确访问</span><br><span class="line">为保证软链接可以任意搬移，创建时务必对源文件使用绝对路径</span><br></pre></td></tr></table></figure><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><ul><li>语法：ln 参数1 参数2</li></ul><p>操作系统给每一个文件赋予唯一的inode，当有相同inode的文件存在时，彼此同步。</p><p>删除时，只将硬链接计数减一。减为0时，inode被释放</p><ul><li>目的：实现文件共享。</li></ul><h3 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h3><p>通过date命令可以在命令行中查看系统时间</p><p>语法：date [-d] [+格式化字符串]</p><ul><li><p>-d 按照给定的字符串显示日期，一般用于日期计算</p></li><li><p>格式化字符串：通过特定的字符串标记，来控制显示的日期格式</p><ul><li>%Y          年</li><li>%y          月份后两位数字(00 99)</li><li>%m        月份(01 12)</li><li>%d         日(01 31)</li><li>%H        小时(00 23)</li><li>%M       分钟(00 59)</li><li>%S         秒(00 60)</li><li>%s         自 1970-01-01 00:00:00 UTC到现在的秒数</li></ul></li><li><p>其中支持的时间标记为：</p><ul><li>year</li><li>month</li><li>day</li><li>hour</li><li>minute</li><li>second</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date -d &quot;+1 day&quot; +%Y%m%d   #显示后一天的日期</span><br></pre></td></tr></table></figure><ul><li>-d 选项可以和格式化字符串配合一起使用</li></ul><h3 id="修改Linux时区"><a href="#修改Linux时区" class="headerlink" title="修改Linux时区"></a>修改Linux时区</h3><p>使用root权限，执行如下命令，修改时区为东八区时区</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -f /etc/localtime</span><br><span class="line">sudo ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><p>将系统自带的localtime文件删除，并将&#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai文件链接为localtime文件即可</p><h3 id="ntp命令"><a href="#ntp命令" class="headerlink" title="ntp命令"></a>ntp命令</h3><p>我们可以通过ntp程序自动校准系统时间</p><p>安装ntp：apt -y install ntp</p><p>启动并设置开机自启：</p><ul><li>systemctl start ntpd</li><li>systemctl enable ntpd</li></ul><p>当ntpd启动后会定期的帮助我们联网校准系统的时间</p><ul><li>也可以手动校准(需root权限)：ntpdate -u ntp.aliyun.com</li></ul><p>通过阿里云提供的服务网址配合ntpdate(安装ntp后会附带这个命令)命令自动校准</p><h3 id="ip地址和主机名"><a href="#ip地址和主机名" class="headerlink" title="ip地址和主机名"></a>ip地址和主机名</h3><h4 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h4><p>每一台联网的电脑都会有一个地址，用于和其他计算机进行通讯</p><p>ip地址主要有两个版本，v4和v6版本</p><p>IPv4版本的地址格式是：a.b.c.d，其中abcd表示0~255的数字，如192.168.88.101就是一个标准的IP地址</p><ul><li>可以通过命令：ifconfig，查看本机的ip地址，如无法使用ifconfig命令，可以安装：apt -y install net-tools</li></ul><h4 id="特殊ip地址"><a href="#特殊ip地址" class="headerlink" title="特殊ip地址"></a>特殊ip地址</h4><ul><li>127.0.0.1，这个ip地址用于指代本机</li><li>0.0.0.0，特殊ip地址<ul><li>可以用于指代本机</li><li>可以在端口绑定中用来确定绑定关系</li><li>在一些ip地址限制中，表示所有ip的意思，如放行规则设置为0.0.0.0，表示允许任意ip访问</li></ul></li></ul><h4 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h4><p>每一台电脑除了对外联络地址(ip地址)以外，也可以有一个名字，称之为主机名</p><ul><li>可以使用命令：hostname查看主机名</li><li>可以使用命令：hostnamectl set-hostname 主机名，修改主机名(需root)</li></ul><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><p>ip地址难以记忆，我们可以通过字符化的地址去访问服务器。如在浏览器内打开<a href="http://www.baidu.com,会打开百度的网址,百度的网址称之为域名./">www.baidu.com，会打开百度的网址，百度的网址称之为域名。</a></p><p><img src="/Linux.assets/Snipaste_2023-05-09_17-11-50.png" alt="Snipaste_2023-05-09_17-11-50"></p><h4 id="配置主机名映射"><a href="#配置主机名映射" class="headerlink" title="配置主机名映射"></a>配置主机名映射</h4><p>我们ubuntu是通过ip地址连接到的Linux服务器，那有没有可能通过域名(主机名)连接呢？</p><p>可以，我们只需要在Windows系统的：C:\Windows\System32\drivers\etc\hosts文件中配置记录即可</p><h3 id="配置Linux固定ip地址"><a href="#配置Linux固定ip地址" class="headerlink" title="配置Linux固定ip地址"></a>配置Linux固定ip地址</h3><h4 id="为什么需要固定ip"><a href="#为什么需要固定ip" class="headerlink" title="为什么需要固定ip"></a>为什么需要固定ip</h4><p>当前我们虚拟机的Linux操作系统，其ip地址是通过DCHP服务获取的</p><p>DCHP：动态获取ip地址，即每次重启设备后都会获取一次，可能导致ip地址频繁变更</p><p>原因1：办公电脑ip地址变化无所谓，但是我们要远程连接到Linux系统，如果ip地址经常变化我们就要频繁修改适配很麻烦</p><p>原因2：在配置虚拟机ip地址和主机名的映射，如果ip频繁更改，我们需要频繁更新映射关系</p><h3 id="网络请求和下载"><a href="#网络请求和下载" class="headerlink" title="网络请求和下载"></a>网络请求和下载</h3><h4 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">可以通过ping命令检查指定的网络服务器是否是可联通状态</span><br><span class="line">    语法：ping [-c num] ip或主机名</span><br><span class="line">    选项：-c，检查的次数，不使用-c选项，将无限次数持续检查</span><br><span class="line">    参数：ip或主机名，被检查的服务器的ip地址或主机名地址</span><br></pre></td></tr></table></figure><h4 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">wget是非交互式的文件下载器，可以在命令行内下载网络文件</span><br><span class="line">    语法：wget [-b] url</span><br><span class="line">    选项：-b，可选，后台下载，会将日志写入到当前工作目录的wget-log文件</span><br><span class="line">    参数：url，下载链接</span><br></pre></td></tr></table></figure><p>注意：无论下载是否完成，都会生成要下载的文件。如果下载未完成，请及时删除这个文件</p><h4 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">curl可以发送http网络请求，可用于：下载文件，获取信息等</span><br><span class="line">    语法：curl [-O] url</span><br><span class="line">    选项：-O，用于下载文件，当url是下载链接时，可以使用此选项保存文件</span><br><span class="line">    参数：url，要发起请求的网络地址</span><br></pre></td></tr></table></figure><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>端口：是设备与外界通讯交流的出入口。端口可以分为：物理端口和虚拟端口两类</p><ul><li>物理端口：又可称之为接口，是可见的端口，如USB接口，RJ45网口，HDMH端口等</li><li>虚拟端口：是指计算机内部的端口，是不可见的，是用来操作系统和外部进行交互使用的</li></ul><h4 id="虚拟端口作用"><a href="#虚拟端口作用" class="headerlink" title="虚拟端口作用"></a>虚拟端口作用</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">计算机程序之间的通讯，通过IP只能锁定计算机，但是无法锁定具体的程序</span><br><span class="line">通过端口可以锁定计算机上具体的程序，确保程序之间进行沟通</span><br><span class="line">IP地址相当于小区地址，在小区内可以有许多用户(程序)，而门牌号(端口)就是各个住户(程序)的联系地址</span><br></pre></td></tr></table></figure><h3 id="端口分类"><a href="#端口分类" class="headerlink" title="端口分类"></a>端口分类</h3><p>Linux系统是一个超大号小区，可以支持65535个端口，这6万多个端口分为3类进行使用：</p><ul><li>公认端口：1~1023，通常用于一些系统内置或知名程序的预留使用，如SSH服务的22端口，HTTPS服务的443端口，非特殊需要，不要占用这个范围的端口</li><li>注册端口：1024~49151，通常可以随意使用，用于松散的绑定一些程序\服务</li><li>动态端口：49152~65535，通常不会固定绑定程序，而是当程序对外进行网络链接时，用于临时使用。</li></ul><p>例：计算机A的微信连接计算机B的微信，A使用的50001即动态端口，临时找一个端口作为出口</p><p>计算机B的微信使用端口5678，即注册端口，长期绑定此端口等待别人连接</p><h3 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h3><ul><li><p>使用namp命令：namp 被查看的IP地址</p></li><li><p>使用netstat命令，查看指定端口的占用情况</p><p>语法：netstat -anp | grep 端口号，安装netstat: apt -y install net-tools</p></li></ul><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul><li>tar zcvf 要生成的压缩包名 压缩材料 -使用gzip方式进行压缩</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zcvf test.tar.gz file1 dir2</span><br><span class="line">z:gzip 压缩  gzip file 生成 file.gz</span><br><span class="line">c:create 创建</span><br><span class="line">v:显示压缩过程(可省略)</span><br><span class="line">f:file 一个压缩文件</span><br></pre></td></tr></table></figure><ul><li><p>tar jcvf 要生成的压缩包名 压缩材料 -使用bzip2方式进行压缩</p></li><li><p>rar压缩：rar a -r 压缩包名(带.rar后缀) 压缩材料</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rar a -r testrar.rar stdio.h test.mp3</span><br></pre></td></tr></table></figure><ul><li>zip压缩：zip -r 压缩包名(带.zip后缀) 压缩材料</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip -r testzip.zip <span class="built_in">dir</span> test.mp3</span><br></pre></td></tr></table></figure><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><ul><li><p>将压缩命令中的c–&gt;x</p></li><li><p>tar zxvf 生成的压缩包名 -使用gzip方式进行解压缩</p></li><li><p>tar jxvf 生成的压缩包名 -使用bzip2方式进行解压缩</p></li><li><p>rar解压：unrar x 压缩包名(带.rar后缀)</p></li><li><p>zip解压：unzip -r 压缩包名(带.zip后缀)</p></li></ul><h3 id="gcc编译"><a href="#gcc编译" class="headerlink" title="gcc编译"></a>gcc编译</h3><h4 id="gcc编译四步骤"><a href="#gcc编译四步骤" class="headerlink" title="gcc编译四步骤"></a>gcc编译四步骤</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc编译可以执行程序4步骤：预处理，编译，汇编，链接</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307240847832.png" alt="Snipaste_2023-07-24_08-35-42"></p><h4 id="gcc编译常用命令"><a href="#gcc编译常用命令" class="headerlink" title="gcc编译常用命令"></a>gcc编译常用命令</h4><ul><li><strong>I：指定头文件所在目录位置</strong>(用来寻找inc下的.h文件)</li><li>c：只做预处理，编译，汇编。得到二进制文件</li><li>g：编译时添加调试语句(调试语句系统隐藏)。主要支持gdb调试</li><li>On：n&#x3D;0~3 编译优化，n越大优化得越多(去除无用代码，默认n&#x3D;2)<strong>(主要用于嵌入式编程)</strong></li><li>Wall(warning all)：显示<strong>所有</strong>警告信息(轻重都显示)</li><li>D<DEF>：向程序中的”动态”注册宏定义。(可以直接输出宏)</li><li>l：指定动态库库名</li><li>L：指定动态库路径</li></ul><h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><h4 id="静态库制作"><a href="#静态库制作" class="headerlink" title="静态库制作"></a>静态库制作</h4><ol><li>将 .c 生成 .o 文件</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c add.c -o add.o</span><br></pre></td></tr></table></figure><ol start="2"><li>使用ar 工具制作静态库</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ar rcs lib库名.a add.o sub.o...</span><br></pre></td></tr></table></figure><ol start="3"><li>编译静态库到可执行文件中</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc test.c lib库名.a -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h4 id="头文件守卫：防止头文件被重复包含"><a href="#头文件守卫：防止头文件被重复包含" class="headerlink" title="头文件守卫：防止头文件被重复包含"></a>头文件守卫：防止头文件被重复包含</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HEAD_H_</span></span><br><span class="line">.......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><h4 id="动态库制作"><a href="#动态库制作" class="headerlink" title="动态库制作"></a>动态库制作</h4><ol><li>将 .c 生成 .o 文件，(生成与位置无关的代码 -fPIC)</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c add.c -o add.o -fPIC</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 gcc -shared 制作动态库</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -shared -o lib库名.so add.o sub.o</span><br></pre></td></tr></table></figure><ol start="3"><li>编译可执行程序时，指定所使用的动态库。 -l：指定库名(去掉lib前缀和.so后缀)  -L：指定库路径。</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc test.c -o a.out -lmymath -L./lib</span><br></pre></td></tr></table></figure><ol start="4"><li>运行可以执行程序 .&#x2F;a.out 出错!  !  !</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">原因：链接器：工作于链接阶段，工作时需要 -l 和 -L</span><br><span class="line">     动态链接器：工作于程序运行阶段，工作时需要提供动态库所在目录位置</span><br><span class="line">解决方式：     </span><br><span class="line">     (1)通过环境变量：<span class="built_in">export</span> LD_LIBRARY_PATH=动态库路径</span><br><span class="line">     ./a.out 成功! ! ! (临时生效，终端重启环境变量失效)</span><br><span class="line">     (2)永久生效：写入 终端配置文件。 .bashrc</span><br><span class="line">     1.vi ~/.bashrc</span><br><span class="line">     2.写入<span class="built_in">export</span> LD_LIBRARY_PATH=动态库路径(建议使用绝对路径) 保存</span><br><span class="line">     3.. .bashrc | <span class="built_in">source</span> .bashrc | 重启终端 --&gt; 让修改后的.bashrc 生效</span><br><span class="line">     4../a.out成功! ! !</span><br><span class="line">     (3)拷贝自定义动态库到/lib(标准C库所在目录位置)</span><br><span class="line">     (4)配置文件法</span><br><span class="line">     1.sudo vim /etc/ld.so.conf</span><br><span class="line">     2.写入 动态库绝对路径 保存</span><br><span class="line">     3.sudo ldconfig -v 使配置文件生效</span><br><span class="line">     4../a.out 成功 ! ! ! ---使用 ldd a.out查看</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202309301600857.png" alt="Snipaste_2023-07-25_15-31-39"></p><h3 id="数据段合并"><a href="#数据段合并" class="headerlink" title="数据段合并"></a>数据段合并</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202309301601021.png" alt="Snipaste_2023-07-28_09-23-10"></p><h3 id="gdb调试-调试逻辑错误"><a href="#gdb调试-调试逻辑错误" class="headerlink" title="gdb调试(调试逻辑错误)"></a>gdb调试(调试逻辑错误)</h3><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><ul><li>-g：使用该参数编译可以执行文件，得到调试表</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb a.out</span><br></pre></td></tr></table></figure><ul><li>list(l)：list 1 列出源码。根据源码<strong>指定行号</strong>设置断点</li><li><strong>start：从第一行开始执行源码</strong></li><li>breakpoint(b)：b 20  在20行位置设置断点</li><li>run(r)：运行程序</li><li>next(n)：下一条指令(会越过函数)</li><li>step(s)：下一条指令(会进入函数)</li><li>print(p)：p i 查看变量的值</li><li>continue：继续执行断点后续指令</li><li>quit：退出当前gdb调试</li></ul><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><ul><li>run：使用run查找段错误出现位置</li><li>finish：结束当前函数调用</li><li>set args：设置main函数命令行参数**(在run | start 之前做)**</li><li>run 字符串1 字符串2…：设置main函数命令行参数</li><li>info b：查看断点信息表</li><li>b 20 if i&#x3D;5：设置条件断点</li><li>ptype：查看变量类型</li><li>backtrace(bt)：列出当前程序正存活着的栈帧</li><li>frame：根据栈帧编号，切换栈帧</li><li>display：设置持续跟踪变量(display i)</li><li>undisplay：取消设置的跟踪变量。undisplay 1(使用跟踪变量的编号)</li></ul><h3 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h3><ul><li><p>作用：项目编译管理  提高编译效率  降低编译出错概率</p></li><li><p>命名：makefile  Makefile(可以默认使用make命令)</p></li><li><p>1个规则：</p></li></ul><p>​                     目标:依赖条件(目标：欲生成的文件  依赖：生成目标的原材料)</p><p>​                                 (一个tab缩进)命令  (tab命令：生成手段，方法)</p><pre><code>                 1. 目标的时间必须晚于依赖条件的时间，否则，更新目标                 2. 依赖条件如果不存在，找寻新的规则去产生依赖条件 </code></pre><ul><li>ALL：指定makefile的终极目标</li><li>2个函数：</li></ul><p>​                    src&#x3D;$(wildcard .&#x2F;*.c)：匹配当前工作目录下的所有.c文件。将文件组成列表，赋值给变量src。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">src=add.c sub.c</span><br></pre></td></tr></table></figure><p>​                    obj&#x3D;$(patsubst %.c,%.o,$(src))：将参数3中，包含参数1的部分，替换为参数2.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">obj=add.o sub.o</span><br></pre></td></tr></table></figure><p>​                    clean:(没有依赖)   (如果当前文件夹存在clean目录，make clean失败，此时必须加到伪目标中)</p><p>​                     -rm -rf $(obj) a.out</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;-rm 中 -&quot;</span>作用是：删除不存在的文件时，不报错。顺序执行结束</span><br></pre></td></tr></table></figure><ul><li><strong>make clean -n(可以展示要执行的代码，并不会执行)</strong></li><li>3个自动变量：</li></ul><p>​                      $@：在规则的命令中，表示规则中的目标</p><p>​                      $^：在规则的命令中，表示所有依赖条件</p><p>​                      $&lt;：在规则的命令中，表示第一个依赖条件。如果将该变量应用到模式规则中，它可将依赖条件列表中的依赖依次取出，套用模式规则。</p><ul><li>手动变量</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">foo=abc(给出变量值)</span><br><span class="line">bar=$(foo)(索引变量值)</span><br></pre></td></tr></table></figure><ul><li>库变量</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CC</span><br><span class="line">CPPFLAGS</span><br><span class="line">CFLAGS</span><br><span class="line">LDFLAGS</span><br></pre></td></tr></table></figure><ul><li>模式规则：(%通配符，只匹配参数名，不匹配路径)</li></ul><p>​                      %.o:%.c</p><p>​                       gcc -c $&lt; -o %@</p><ul><li>静态模式规则：(表示对哪一个依赖条件套用模式规则)防止有多个规则时的误解，用以区分</li></ul><p>​                       $(obj):%.o:%.c</p><p>​                       gcc -c $&lt; -o %@</p><ul><li><p>伪目标：</p><p>​                 .PHONY: clean ALL(不用生成文件，但要执行这个规则)</p></li><li><p>参数：</p><p>​                -n：模拟执行make，make clean 命令</p><p>​                -f：指定文件执行make命令 (若文件名不是makefile | Makefile时使用)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -f 文件名</span><br></pre></td></tr></table></figure></li><li><p>当文件夹有多个main函数时</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">src=$(wildcard *.c)</span><br><span class="line">obj=$(patsubst %.c,%.o,$(src))</span><br><span class="line">executables=$(patsubst %.c,%,$(src))</span><br><span class="line"></span><br><span class="line">myArgs= -Wall -g</span><br><span class="line"></span><br><span class="line">all: $(executables)</span><br><span class="line"></span><br><span class="line">%: %.o</span><br><span class="line">        gcc $^ -o $@ $(myArgs)</span><br><span class="line"></span><br><span class="line">$(obj): %.o: %.c</span><br><span class="line">        gcc -c $&lt; -o $@ $(myArgs)</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        -rm -rf $(obj) $(executables)</span><br><span class="line"></span><br><span class="line">.PHONY: clean all</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307311611857.png" alt="image-20230731161109706"></p><h3 id="open-x2F-close函数"><a href="#open-x2F-close函数" class="headerlink" title="open&#x2F;close函数"></a>open&#x2F;close函数</h3><h4 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h4><ul><li>int open(const char *pathname,int flags);</li><li>int open(const char *pathname,int flags,mode_t mode);  &#x2F;&#x2F;mode_t 存储八进制整型(参数2指定了0_CREATE)</li><li>int close(int fd);  &#x2F;&#x2F;成功返回0   失败返回-1  并设置  errno</li></ul><h4 id="常用参数-flags取值"><a href="#常用参数-flags取值" class="headerlink" title="常用参数(flags取值)"></a>常用参数(flags取值)</h4><ul><li>O_RDONLY  O_WRONLY  O_RDWR(选其一)</li><li>O_APPEND  O_CREATE  O_EXCL(是否存在)  O_TRUNC(截断，截断后文件大小为0)  O_NONBLOCK(附加选项)</li><li>创建文件时，指定文件访问权限。权限同时受umask影响。结论为：<strong>文件的权限&#x3D;mode &amp; ~umask</strong>(775)(使用头文件：&lt;fcntl.h&gt;)</li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul><li>成功：返回打开文件所得到对应的 文件描述符 (整数)</li><li>失败：返回**-1<strong>，并设置一个</strong>errno**(头文件为errno.h)。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>;  <span class="comment">//可以展示出errno所对应的信息</span></span><br></pre></td></tr></table></figure><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span>   <span class="comment">//前两个可以使用#include&lt;unistd.h&gt;代替</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span>    </span></span><br></pre></td></tr></table></figure><h4 id="open常见错误："><a href="#open常见错误：" class="headerlink" title="open常见错误："></a>open常见错误：</h4><ol><li>打开文件不存在</li><li>以写方式打开只读文件(打开文件没有对应的权限)</li><li>以只写方式打开目录</li></ol><ul><li>错误处理函数：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;xxx error: %d\n&quot;</span>,errno);</span><br><span class="line"></span><br><span class="line">char *strerror(int errnum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;xxx error: %s\n&quot;</span>,strerror(errno));</span><br><span class="line"></span><br><span class="line">void perror(const char *s)</span><br><span class="line">perror(<span class="string">&quot;open error&quot;</span>); //字符串自定义</span><br></pre></td></tr></table></figure><h4 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h4><ul><li>ssize_t read(int fd , void *buf , size_t count);  (第一个s表符号)</li><li>参数：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fd: 文件描述符</span><br><span class="line">buf: 存数据的缓冲区</span><br><span class="line">count: 缓冲区大小</span><br></pre></td></tr></table></figure><ul><li><strong>返回值：</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0：读到文件末尾</span><br><span class="line">成功：读到的字节数</span><br><span class="line">失败：-1 设置errno</span><br><span class="line">-1：并且errno=EAGIN 或 EWOULDBLOCK，说明<span class="built_in">read</span>在以非阻塞方式读一个设备文件(网络文件)，并且文件无数据。(不是<span class="built_in">read</span>失败)</span><br></pre></td></tr></table></figure><h4 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h4><ul><li>*<em>ssize_t write(int fd , const void <em>buf , size_t count);</em></em>  (第一个s表符号)</li><li>参数：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fd: 文件描述符</span><br><span class="line">buf: 待写出数据的缓冲区</span><br><span class="line">count: 数据大小</span><br></pre></td></tr></table></figure><ul><li>返回值：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">成功：写入的字节数</span><br><span class="line">失败：-1 设置errno</span><br></pre></td></tr></table></figure><h4 id="系统调用和库函数的比较"><a href="#系统调用和库函数的比较" class="headerlink" title="系统调用和库函数的比较"></a>系统调用和库函数的比较</h4><h5 id="strace命令"><a href="#strace命令" class="headerlink" title="strace命令"></a>strace命令</h5><p>strace是一个用于跟踪系统调用的命令行工具。它可以让你查看一个程序执行期间发生的系统调用，包括打开文件、读写文件、网络通信等。通过跟踪系统调用，你可以了解程序在底层的操作和行为。</p><p>strace的基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strace [选项] [命令 [参数...]]</span><br></pre></td></tr></table></figure><p>常用选项包括：</p><ul><li><code>-p &lt;进程ID&gt;</code>：跟踪指定进程ID的系统调用。</li><li><code>-o &lt;输出文件&gt;</code>：将跟踪结果输出到指定文件。</li><li><code>-e &lt;系统调用&gt;</code>：指定需要跟踪的系统调用，多个系统调用之间用逗号分隔。</li><li><code>-c</code>：统计每个系统调用的次数和时间。</li><li><code>-s &lt;最大字符串长度&gt;</code>：限制显示的字符串长度。</li><li><code>-f</code>：跟踪由fork创建的子进程。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strace -o output.txt ls -l</span><br></pre></td></tr></table></figure><p>上述命令将跟踪执行ls -l命令时发生的系统调用，并将结果输出到output.txt文件中。</p><p>strace是一个强大的工具，可以帮助开发人员和系统管理员调试和分析应用程序的行为。通过查看系统调用，你可以了解程序的执行过程和底层操作，从而更好地理解和解决问题。</p><h5 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h5><ul><li>read，write函数常常被称为Unbuffered I&#x2F;O。(指的是无用户及缓冲区，但不保证不使用内核缓冲区)</li></ul><h5 id="预读入缓输出"><a href="#预读入缓输出" class="headerlink" title="预读入缓输出"></a>预读入缓输出</h5><ul><li><strong>用户空间到内核空间时间消耗大</strong>。(只有系统调用才能进内核空间(例如：write，read))。</li><li>fputc在用户空间有缓冲区，缓满4096才调用write进入内核。</li></ul><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308032030214.png" alt="Snipaste_2023-08-03_17-33-25"></p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><ul><li>PCB进程控制块：本质  结构体</li><li>成员：文件描述符表</li><li>文件描述符：0&#x2F;1&#x2F;……&#x2F;1023</li></ul><ol><li>STDIN_FILENO   &#x2F;&#x2F;标准输入</li><li>STDOUT_FILENO   &#x2F;&#x2F;标准输出</li><li>STDERR_FILENO  &#x2F;&#x2F;标准错误</li></ol><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308040937536.png" alt="Snipaste_2023-08-03_21-55-25"></p><ul><li>文件描述符key所对应的value：是指向文件结构体的指针</li></ul><h3 id="阻塞，非阻塞-设备文件，网络文件的属性"><a href="#阻塞，非阻塞-设备文件，网络文件的属性" class="headerlink" title="阻塞，非阻塞(设备文件，网络文件的属性)"></a>阻塞，非阻塞(设备文件，网络文件的属性)</h3><ul><li><strong>产生阻塞的场景。</strong>读设备文件。读网络文件。(读常规文件无阻塞概念)</li><li>&#x2F;dev&#x2F;tty  –  终端文件</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">open(<span class="string">&quot;/dev/tty&quot;</span>,O_RDWR | O_NONBLOCK)  --设置/dev/tty非阻塞状态。(默认为阻塞状态)</span><br></pre></td></tr></table></figure><h3 id="fcntl改文件属性"><a href="#fcntl改文件属性" class="headerlink" title="fcntl改文件属性"></a>fcntl改文件属性</h3><ul><li><strong>int flags&#x3D;fcntl(fd,F_GETFL);</strong></li><li>flags |&#x3D; O_NONBLOCK</li><li><strong>fcntl(fd,F_SETFL,flags)</strong></li><li>获取文件状态：F_GETFL</li><li>设置文件状态：F_SETFL</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"></span><br><span class="line">int fcntl(int fd, int cmd, ... /* arg */);</span><br><span class="line">功能：改变已打开的文件性质，fcntl针对描述符提供控制。</span><br><span class="line">参数：</span><br><span class="line">    fd：操作的文件描述符</span><br><span class="line">    cmd：操作方式</span><br><span class="line">    arg：针对cmd的值，fcntl能够接受第三个参数int arg。</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回某个其他值</span><br><span class="line">    失败：-1</span><br></pre></td></tr></table></figure><p><strong>fcntl函数有5种功能：</strong></p><ol><li><p>复制一个现有的描述符（cmd&#x3D;F_DUPFD）</p></li><li><p>获得／设置文件描述符标记(cmd&#x3D;F_GETFD或F_SETFD)</p></li><li><p>获得／设置文件状态标记(cmd&#x3D;F_GETFL或F_SETFL)</p></li><li><p>获得／设置异步I&#x2F;O所有权(cmd&#x3D;F_GETOWN或F_SETOWN)</p></li><li><p>获得／设置记录锁(cmd&#x3D;F_GETLK, F_SETLK或F_SETLKW)</p></li></ol><h3 id="lseek函数-修改文件偏移量"><a href="#lseek函数-修改文件偏移量" class="headerlink" title="lseek函数(修改文件偏移量)"></a>lseek函数(修改文件偏移量)</h3><ul><li><strong>off_t lseek(int fd,off_t offset,int whence);</strong></li><li>参数：</li></ul><ol><li>fd：文件描述符</li><li>offset：偏移量(off_t 矢量值，可以往前偏也可以往后偏)</li><li>whence：设置起始偏移位置：SEEK_SET | SEEK_CUR | SEEK_END</li></ol><ul><li>返回值：</li></ul><ol><li>成功：较起始位置偏移量</li><li>失败：-1 errno</li></ol><ul><li>应用场景：</li></ul><ol><li><em><strong>文件的”读”，”写”使用同一偏移位置</strong></em></li><li><strong>使用lseek获取文件大小</strong>：int length&#x3D;lseek(fd,0,SEEK_END);</li><li><strong>使用lseek拓展文件大小</strong>：lseek(fd,111,SEEK_END) -此时文件大小并未真正改变，要想使文件大小真正拓展，<strong>必须引起IO操作</strong> (如调write函数)</li></ol><ul><li>使用truncate函数。直接拓展文件。 int ret&#x3D;truncate(“dict.cp”,250); </li><li>使用ftruncate函数。int ret &#x3D; ftruncate(fd , 250);</li><li><strong>od-tcx filename  查看文件的16进制表示形式</strong></li><li><strong>od-tcd filename  查看文件的10进制表示形式</strong></li></ul><h3 id="传入传出参数"><a href="#传入传出参数" class="headerlink" title="传入传出参数"></a>传入传出参数</h3><ul><li><p>char *strcpy(char *dest,const char *src);</p></li><li><p><strong>传入参数：第二个参数</strong></p></li></ul><ol><li>指针作为函数参数</li><li>通常有const关键字修饰</li><li>指针指向有效区域，在函数内部做读操作</li></ol><ul><li><strong>传出参数：第一个参数</strong></li></ul><ol><li>指针作为函数参数</li><li>在函数调用之前，指针指向的空间可以无意义，但必须有效</li><li>在函数内部，做写操作</li><li>函数调用结束后，充当函数返回值</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void aaa();</span><br><span class="line">int aaa(int *p,struct <span class="built_in">stat</span> *p2,struct student *p3);</span><br><span class="line"><span class="function"><span class="title">bb</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    aaa();</span><br><span class="line">&#125;</span><br><span class="line">1.给b赋值，如果无传出参数充当返回值，返回一个数</span><br><span class="line">2.有传出参数充当返回值，返回4个数，但传出参数不是返回值</span><br></pre></td></tr></table></figure><ul><li><p>char *strtok(char *str,const char *delim,char **saveptr);</p></li><li><p><strong>传入传出参数：第三个参数</strong></p></li></ul><ol><li>指针作为函数参数</li><li>在函数调用之前，指针指向的空间有实际意义</li><li>在函数内部，先做读操作，后做写操作</li><li>函数调用结束后，充当函数返回值</li></ol><h3 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h3><h4 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h4><ul><li>其<strong>本质为结构体</strong>，存储文件的属性信息(ls -l查看的信息)。如：权限，类型，大小，时间，用户，<em><strong>盘块位置</strong></em>…也叫作<strong>文件属性管理结构</strong>，大多数的inode都存储在磁盘上。</li><li>少量使用、近期使用的inode会被缓存在内存中。</li></ul><h4 id="dentry"><a href="#dentry" class="headerlink" title="dentry"></a>dentry</h4><ul><li><strong>目录项</strong>，其本质依然是结构体，重要的、成员变量有两个{文件名，inode,…}，而文件内容(data)保存在磁盘盘块中。</li></ul><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308061451906.png" alt="Snipaste_2023-08-06_10-57-03"></p><ul><li><strong>硬链接时，dentry不同，inode相同。</strong>删除一个硬链接，减少一个dentry，全部删除，磁盘空间不会被擦除。磁盘空间只能被覆盖。</li></ul><h3 id="stat-x2F-lstat函数"><a href="#stat-x2F-lstat函数" class="headerlink" title="stat&#x2F;lstat函数"></a>stat&#x2F;lstat函数</h3><ul><li><strong>获取文件属性(从inode结构体中获取)</strong></li></ul><h4 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h4><ul><li>**int stat(const char <em>path,struct stat <em>buf);</em></em> (包含头文件 #include&lt;sys&#x2F;stat.h&gt; <strong>手动创建结构体 struct stat buf)</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">参数：</span><br><span class="line">   path：文件路径</span><br><span class="line">   buf：(传出参数) 存放文件属性</span><br><span class="line">返回值：</span><br><span class="line">   成功：0</span><br><span class="line">   失败：-1 errno</span><br></pre></td></tr></table></figure><ul><li><strong>获取文件大小</strong>：buf.st_size</li><li><strong>获取文件类型</strong>：buf.st_mode</li><li><strong>获取文件权限</strong>：buf.st_mode</li></ul><h4 id="lstat函数"><a href="#lstat函数" class="headerlink" title="lstat函数"></a>lstat函数</h4><ul><li>**int lstat(char <em>path,struct stat <em>buf);</em></em></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">成功：返回0</span><br><span class="line">失败：返回-1 设置errno</span><br></pre></td></tr></table></figure><ul><li>文件类型判断方法：st_mode 取高4位。但应使用宏函数：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">S_ISREG(m)is it a regular file?</span><br><span class="line">S_ISDIR(m)directory?</span><br><span class="line">S_ISCHR(m)character device?</span><br><span class="line">S_ISBLK(m)block device?</span><br><span class="line">S_ISFIFO(m)FIFO(named pipe)</span><br><span class="line">S_ISLNK(m)symbolic <span class="built_in">link</span>? (Not <span class="keyword">in</span> POSIX.1-1996)</span><br><span class="line">S_ISSOCK(m)socket? (Not <span class="keyword">in</span> POSIX.1-1996)</span><br></pre></td></tr></table></figure><ul><li><strong>穿透符号链接：stat：会；lstat：不会</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./stat f.soft  //is a reguctor</span><br><span class="line">./lstat f.soft //is a symbolic <span class="built_in">link</span></span><br></pre></td></tr></table></figure><h3 id="link和unlink隐式回收"><a href="#link和unlink隐式回收" class="headerlink" title="link和unlink隐式回收"></a>link和unlink隐式回收</h3><h4 id="link函数-可以为已经存在的文件创建目录项-硬链接"><a href="#link函数-可以为已经存在的文件创建目录项-硬链接" class="headerlink" title="link函数(可以为已经存在的文件创建目录项(硬链接))"></a>link函数(可以为已经存在的文件创建目录项(硬链接))</h4><ul><li>**int link(const char <em>oldpath , const char <em>newpath)</em></em>   –  可以为已经存在的文件创建目录项(硬链接)</li></ul><ol><li>成功：0</li><li>失败：-1 设置errno</li></ol><h4 id="unlink函数-删除一个文件的目录项"><a href="#unlink函数-删除一个文件的目录项" class="headerlink" title="unlink函数(删除一个文件的目录项)"></a>unlink函数(删除一个文件的目录项)</h4><ul><li>*<em>int unlink(const char <em>pahname);</em></em></li></ul><ol><li>成功：0</li><li>失败：-1 设置errno</li></ol><ul><li>Linux下删除文件的机制</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不断将st_nlink -1，直至减到0为止。无目录项对应的文件，将会被操作系统择机释放。(具体时间由系统内部调度算法决定)</span><br><span class="line">因此，我们删除文件，从某种意义上说，只是让文件具备了被释放的条件</span><br></pre></td></tr></table></figure><ul><li><strong>unlink函数的特征：</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">清楚文件时，如果文件的硬链接数到0了，没有dentry对应，但该文件仍不会马上被释放。要等到所有打开该文件的进程关闭该文件，系统才会挑时间将该文件释放掉。</span><br></pre></td></tr></table></figure><h4 id="隐式回收"><a href="#隐式回收" class="headerlink" title="隐式回收"></a>隐式回收</h4><ul><li>当进程结束运行时，所有该进程打开的文件会被关闭，申请的内存空间会被释放。系统的这一特性称之为隐式回收系统资源。</li></ul><h4 id="readlink函数-读取符号链接文件本身内容，得到链接所指向的文件名"><a href="#readlink函数-读取符号链接文件本身内容，得到链接所指向的文件名" class="headerlink" title="readlink函数(读取符号链接文件本身内容，得到链接所指向的文件名)"></a>readlink函数(读取符号链接文件本身内容，得到链接所指向的文件名)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /.home/wzhvv/a a.soft</span><br><span class="line"><span class="built_in">readlink</span> a.soft  --&gt;  /.home/wzhvv/a</span><br></pre></td></tr></table></figure><ul><li>**ssize_t  readlink(const char <em>path , char <em>buf,size_t bufsiz);</em></em> –&gt; 读到的内容放到buf缓冲区</li></ul><ol><li>成功：返回实际读到的字节数</li><li>失败：-1 设置errno</li></ol><h4 id="rename函数-重命名一个文件"><a href="#rename函数-重命名一个文件" class="headerlink" title="rename函数(重命名一个文件)"></a>rename函数(重命名一个文件)</h4><ul><li>**int rename(const char <em>oldpath , const char <em>newpath)</em></em></li></ul><ol><li>成功：0</li><li>失败：-1 设置errno</li></ol><h4 id="getcwd函数-获取当前工作目录-–-gt-相当于pwd"><a href="#getcwd函数-获取当前工作目录-–-gt-相当于pwd" class="headerlink" title="getcwd函数(获取当前工作目录) –&gt; 相当于pwd"></a>getcwd函数(获取当前工作目录) –&gt; 相当于pwd</h4><ul><li>**char <em>getcwd(char <em>buf , size_t size);</em></em></li></ul><ol><li>成功：buf中保存当前进程工作目录位置</li><li>失败：返回NULL</li></ol><h4 id="chdir函数-改变当前进程的工作目录-–-gt-相当于cd"><a href="#chdir函数-改变当前进程的工作目录-–-gt-相当于cd" class="headerlink" title="chdir函数(改变当前进程的工作目录) –&gt; 相当于cd"></a>chdir函数(改变当前进程的工作目录) –&gt; 相当于cd</h4><ul><li>int chdir(const char *path)</li></ul><ol><li>成功：0</li><li>失败：-1 设置errno</li></ol><h3 id="文件目录权限"><a href="#文件目录权限" class="headerlink" title="文件目录权限"></a>文件目录权限</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308071505544.png" alt="Snipaste_2023-08-07_15-04-37"></p><h3 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h3><h4 id="opendir函数-根据传入的目录名打开一个目录-库函数-DIR-类似于-FILE"><a href="#opendir函数-根据传入的目录名打开一个目录-库函数-DIR-类似于-FILE" class="headerlink" title="opendir函数(根据传入的目录名打开一个目录(库函数))DIR * 类似于 FILE *"></a>opendir函数(根据传入的目录名打开一个目录(库函数))DIR * 类似于 FILE *</h4><ul><li>**DIR <em>opendir(const char <em>name);</em></em>   (头文件 #include&lt;dirent.h&gt;)–》 directory entry</li></ul><ol><li>成功：返回<strong>指向该目录结构体指针</strong></li><li>失败：返回NULL</li></ol><h4 id="closedir函数-关闭打开的目录"><a href="#closedir函数-关闭打开的目录" class="headerlink" title="closedir函数(关闭打开的目录)"></a>closedir函数(关闭打开的目录)</h4><ul><li>*<em>int closedir(DIR <em>dirp)</em></em></li></ul><ol><li>成功：0</li><li>失败：-1 设置errno</li></ol><h4 id="readdir函数-读取目录-库函数"><a href="#readdir函数-读取目录-库函数" class="headerlink" title="readdir函数(读取目录(库函数))"></a>readdir函数(读取目录(库函数))</h4><ul><li>**struct dirent <em>readdir(DIR <em>dirp);</em></em></li></ul><ol><li>成功：返回目录项结构体指针</li><li>失败：返回NULL 设置errno  <strong>(当读取结束时也返回NULL值，所以应借助errno进一步加以区分)</strong></li></ol><ul><li>struct 结构体：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct dirent&#123;</span><br><span class="line">    ino_t  d_ino;  //inode编号</span><br><span class="line">    ...</span><br><span class="line">    char  d_name[256];  //文件名</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="递归遍历目录：ls-R"><a href="#递归遍历目录：ls-R" class="headerlink" title="递归遍历目录：ls -R"></a>递归遍历目录：ls -R</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 判断命令行参数，获取用户要查询的目录名。argv[<span class="number">1</span>]</span><br><span class="line">    argc == <span class="number">1</span>--&gt; ./</span><br><span class="line"><span class="number">2.</span> 判断用户指定的是否是目录。stat S_ISDIR();--&gt; 封装函数 isFile</span><br><span class="line"><span class="number">3.</span> 读目录：</span><br><span class="line">    opendir(dir)</span><br><span class="line">    <span class="keyword">while</span>(readdir())&#123;</span><br><span class="line">        普通文件，直接打印</span><br><span class="line">        目录：</span><br><span class="line">            拼接目录访问绝对路径。<span class="built_in">sprintf</span>(path,<span class="string">&quot;%s%s&quot;</span>,dir,d_name)</span><br><span class="line">            递归调用自己。--&gt; opendir(path) readdir closedir</span><br><span class="line">    &#125;</span><br><span class="line">closedir()</span><br></pre></td></tr></table></figure><h3 id="dup函数-重定向"><a href="#dup函数-重定向" class="headerlink" title="dup函数(重定向)"></a>dup函数(重定向)</h3><h4 id="dup函数"><a href="#dup函数" class="headerlink" title="dup函数"></a>dup函数</h4><ul><li><p><strong>int dup(int oldfd);</strong>   </p></li><li><p>功能：<strong>通过 oldfd 复制出一个新的文件描述符</strong>，新的文件描述符是调用进程文件描述符表中最小可用的文件描述符，最终 oldfd 和新的文件描述符都指向同一个文件。    </p></li><li><p>参数：oldfd : 需要复制的文件描述符 oldfd   </p></li><li><p>返回值：</p></li></ul><p>  成功：新文件描述符<br>  失败： -1</p><h4 id="dup2函数-dup-to"><a href="#dup2函数-dup-to" class="headerlink" title="dup2函数 (dup to)"></a>dup2函数 (dup to)</h4><ul><li><strong>int dup2(int oldfd, int newfd);</strong>  (头文件 #include &lt;unistd.h&gt;)</li><li>功能：<strong>通过 oldfd 复制出一个新的文件描述符 newfd</strong>，<strong>如果成功，newfd 和函数返回值是<em>同一个返回值</em></strong>，最终 oldfd 和新的文件描述符 newfd 都指向同一个文件。    </li><li>参数：<br>    oldfd : 需要复制的文件描述符<br>     newfd : 新的文件描述符，这个描述符可以人为指定一个合法数字（0 - 1023），如果指定的数字已经被占用（和某个文件有关联），此函数会自动关闭 close() 断开这个数字和某个文件的关联，再来使用这个合法数字。</li><li>返回值：<br>        成功：返回 newfd<br>        失败：返回 -1</li></ul><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>程序：死的。只占用磁盘空间。  –剧本</li><li>进程：活的。运行起来的程序。占用内存，cpu等系统资源。  –戏</li></ul><h3 id="PCB进程控制块"><a href="#PCB进程控制块" class="headerlink" title="PCB进程控制块"></a>PCB进程控制块</h3><ol><li>进程id</li><li>文件描述符</li><li>进程状态： 初始态  就绪态  运行态  挂起态  终止态</li><li>进程工作目录位置</li><li>umask掩码</li><li>信号相关信息资源</li><li>信号相关信息资源</li><li>用户id和组id</li></ol><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><ul><li>pid_t fork(void);</li><li>创建子进程。父子进程各自返回。父进程返回子进程pid。子进程返回0。</li><li>getpid()：返回当前进程pid。getppid：返回父进程pid。</li><li>循环创建N个子进程模型。每个子进程标识自己的身份。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)   <span class="comment">//循环期间，子进程不fork</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">5</span>==i)&#123;        <span class="comment">//父进程，从表达式2跳出</span></span><br><span class="line">    <span class="comment">//sleep(5);</span></span><br><span class="line">    wait(<span class="literal">NULL</span>);  <span class="comment">//一次wait/waitpid函数调用，只能回收一个进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I`m parent\n&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;           <span class="comment">//子进程，从break跳出</span></span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I`m %dth child\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="父子进程相同："><a href="#父子进程相同：" class="headerlink" title="父子进程相同："></a>父子进程相同：</h4><ul><li>刚fork后。data段，text段，堆，栈，环境变量，全局变量，宿主目录位置，进程工作目录位置，信号处理方式</li></ul><h4 id="父子进程不同："><a href="#父子进程不同：" class="headerlink" title="父子进程不同："></a>父子进程不同：</h4><ul><li>进程id，返回值，各自的父进程，进程创建时间，闹钟，未决信号集</li></ul><h4 id="父子进程共享："><a href="#父子进程共享：" class="headerlink" title="父子进程共享："></a>父子进程共享：</h4><ul><li><strong>读时共享，写时复制。</strong>—–   全局变量</li></ul><ol><li>文件描述符</li><li>mmap映射区</li></ol><h4 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h4><p>使用gdb调试的时候，gdb只能跟踪一个进程。可以在fork函数调用之前，通过指令设置gdb调试工具跟踪父进程或者是跟踪子进程。<strong>默认跟踪父进程。</strong></p><ul><li>set follow-fork-mode child 命令设置gdb在fork之后跟踪子进程。</li><li>set follow-fork-mode parent 设置跟踪父进程</li></ul><p><em><strong>注意：一定要在fork函数调用之前设置才有效。</strong></em></p><h3 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h3><ul><li>fork创建子进程后执行的是和父进程相同的程序(但有可能执行不同的代码分支)，子进程往往要调用exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。</li><li>将当前进程的.text,.data替换为所要加载的程序的.text,.data，然后让进程从新的.text第一条指令开始执行，但进程id不变，换核不换壳。</li></ul><h4 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a>execlp函数</h4><ul><li>加载一个进程，借助PATH环境变量</li><li>int execlp(const char *file , const char *arg , ….);</li></ul><ol><li>成功：无返回</li><li>失败：-1</li></ol><ul><li>参数1：要加载的程序的名字。该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数1则出错返回。</li><li>该函数通常用来调用系统程序。如：ls，date，cp，cat等指令。</li></ul><h4 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a>execl函数</h4><ul><li>加载一个进程，通过  路径名+程序名  来加载</li><li>int execl(const char *path , const char *arg , ….);</li></ul><ol><li>成功：无返回</li><li>失败：-1</li></ol><ul><li>对比execlp，如加载 ls 命令带有 -l ，-F参数</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-F&quot;</span>,NULL);          //使用程序名在PATH中搜索   哨兵：NULL</span><br><span class="line">execlp(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-F&quot;</span>,NULL);     //使用参数1给出的绝对路径搜索      </span><br></pre></td></tr></table></figure><h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><ul><li>孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为 init 进程，称为init进程领养的孤儿。</li></ul><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><ul><li>僵尸进程：进程终止，父进程尚未回收，子进程残留资源(PCB)存放于内核中，变成僵尸(Zombie)进程。</li><li>特别注意：僵尸进程不能使用kill命令消除掉。因为kill命令只用来终止进程的，而僵尸进程已经终止。(可通过杀死父进程，让init来回收子进程)</li></ul><h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h4><ul><li>一个进程在终止时会关闭所有的文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着<strong>导致该进程终止的信号</strong>是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid都得到它的退出状态同时彻底清除掉这个进程。</span><br></pre></td></tr></table></figure><ul><li>父进程调用wait函数可以回收子进程终止信息。该函数有<strong>三个功能</strong>：</li></ul><ol><li>阻塞等待子进程退出</li><li>回收子进程残留资源</li><li>获取子进程结束状态(退出原因)</li></ol><ul><li><em><em>pid_t wait(int <em>status);</em></em>     &#x2F;&#x2F;status为</em><strong>传出</strong><em>参数，*<em>回收进程状态</em></em>    (传NULL，不关心子进程结束原因)</li></ul><ol><li>成功：清理掉的<strong>子进程ID</strong></li><li>失败：-1(没有子进程)</li></ol><ul><li>当进程终止时，<strong>操作系统的隐式回收进制</strong>会：1.关闭所有文件描述符 2.释放用户空间分配的内存。</li><li>内核的PCB仍存在。其中保存该进程的退出状态。(正常终止 -&gt; 退出值 ；异常终止 -&gt; 终止信号)</li><li>可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组：</li></ul><ol><li><p><strong>WIFEXITED(status)</strong>  为非0  → 进程正常结束</p><p><strong>WEXITSTATUS(status)</strong> 如上宏为真，使用此宏 → 获取进程退出状态(exit的参数) —  子进程的返回值。</p></li><li><p><strong>WIFSIGNALED(status)</strong> 为非0 → 进程异常终止  <strong>(信号终止)</strong></p><p><strong>WTERMSIG(status)</strong> 如上宏为真，使用此宏 → <strong>取得使进程终止的那个信号的编号</strong>。</p></li><li><p><strong>WIFSTOPPED(status)</strong> 为非0  →  进程处于暂停状态</p><p><strong>WSTOPSIG(status)</strong> 如上宏为真，使用此宏  → 取得使进程暂停的那个信号的编号。</p><p><strong>WIFCONTINUED(status)</strong> 为真  → 进程暂停后已经继续运行</p></li></ol><h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h4><ul><li>作用同wait，但可指定pid进程清理，可以不阻塞。</li><li>*<em>pid_t waitpid(pid_t pid,int <em>status,int options);</em></em></li><li>返回值：</li></ul><ol><li>(&gt;0)：表成功回收的子进程pid</li><li>(0)：函数调用时，参3指定了WNOHANG，并且，没有子进程结束</li><li>(-1)：失败。errno</li></ol><p><strong>特殊参数和返回情况：</strong></p><ul><li>参数pid：</li></ul><ol><li>(&gt;0) 回收指定ID的进程</li><li>(-1) 回收任意子进程(相当于wait)</li><li>(0) 回收和当前调用waitpid<em><strong>一个组</strong></em>的所有子进程  <strong>此时 参3 为WNOHANG，且子进程正在运行</strong></li><li>(&lt;-1) 回收指定<em><strong>进程组</strong></em>内的任意子进程  <strong>(进程id取反)</strong></li></ol><ul><li><em><strong>注意：</strong></em>一次wait 或 waitpid 调用只能清理一个子进程，清理多个子进程应使用循环。</li><li>参数status：**(传出)** 回收进程的状态</li><li>参数options：WNOHANG 指定回收方式为：非阻塞    0：阻塞</li></ul><p><strong>总结：wait，waitpid一次调用，回收一个子进程。想回收多个：用while。</strong></p><h3 id="进程间通信常见方式"><a href="#进程间通信常见方式" class="headerlink" title="进程间通信常见方式"></a>进程间通信常见方式</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308190931519.png" alt="Snipaste_2023-08-15_15-50-37"></p><ul><li>现今常用的进程间通信方式有：</li></ul><ol><li>管道 (使用最简单)</li><li>信号 (开销最小)</li><li>共享映射区 (无血缘关系)</li><li>本地套接字 (最稳定)</li></ol><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><h4 id="管道的概念"><a href="#管道的概念" class="headerlink" title="管道的概念"></a>管道的概念</h4><ul><li>管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据的传递。调用pipe系统函数即可创建一个管道。有如下特质：</li></ul><ol><li>其本质是一个伪文件 (实为内核缓冲区)</li><li>由两个文件描述符引用，一个表示读端，一个表示写端</li><li>规定数据从管道的写端写入管道，从读端流出</li></ol><ul><li>管道的原理：管道实为内核使用<strong>环形队列机制</strong>，借助内核缓冲区(4k)实现</li><li>管道的局限性：</li></ul><ol><li>数据不能进程自己写，自己读</li><li>管道中数据不可反复读取。一但读走，管道中不再存在</li><li>采用半双工通信方式，数据只能在单方向上流动</li><li>只能在有公共祖先的进程间使用管道</li></ol><ul><li><strong>常用的通信方式有：单工通信：电视  半双工通信：对讲机  全双工通信：电话</strong></li></ul><h4 id="管道基本用法"><a href="#管道基本用法" class="headerlink" title="管道基本用法"></a>管道基本用法</h4><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308190931599.png" alt="Snipaste_2023-08-16_10-20-22"></p><ul><li>pipe函数：创建，并打开管道</li><li>int pipe(int fd[2]);</li><li>参数：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fd[0]；读端</span><br><span class="line">fd[1]：写端</span><br></pre></td></tr></table></figure><ul><li>返回值：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">成功：0</span><br><span class="line">失败：-1 errno</span><br></pre></td></tr></table></figure><h4 id="管道读写行为"><a href="#管道读写行为" class="headerlink" title="管道读写行为"></a>管道读写行为</h4><ul><li>读管道：</li></ul><ol><li>管道中有数据，read返回实际读到的字节数。</li><li>管道中无数据：</li></ol><p>​                             (1) 管道写端被全部关闭，read返回0 (类似读到文件结尾)</p><pre><code>                         (2) 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</code></pre><ul><li>写管道：</li></ul><ol><li><p>管道读端全部被关闭，进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)</p></li><li><p>管道读端没有全部关闭：</p><p>​                     (1) 管道已满，write阻塞。</p><p>​                     (2)管道未满，write将数据写入，并返回实际写入的字节数。</p></li></ol><h4 id="管道缓冲区大小"><a href="#管道缓冲区大小" class="headerlink" title="管道缓冲区大小"></a>管道缓冲区大小</h4><ul><li><p>可以使用 <strong>ulimit -a</strong> 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为：</p><p>​pipe size  (512 byte , -p)  8</p></li><li><p>也可以使用 fpathconf 函数，借助参数选项来查看。使用该宏应引入头文件&lt;unistd.h&gt;</p><p>​<strong>long fpathconf(int fd , int name)；</strong></p></li></ul><ol><li>成功：返回管道大小</li><li>失败：-1 设置errno</li></ol><h4 id="管道的优劣"><a href="#管道的优劣" class="headerlink" title="管道的优劣"></a>管道的优劣</h4><ul><li>优点：简单，相比信号，套接字实现进程间通信，简单很多</li><li>缺点：</li></ul><ol><li>只能单向通信，双向通信需建立两个管道</li><li>只能用于父子，兄弟进程(有共同祖先)间通信</li></ol><h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><ul><li>FIFO常被称为命名管道，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间。但通过FIFO，不相关的进程也能交换数据。</li><li>FIFO是Linux基础文件类型中的一种。但，<strong>FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道</strong>。<em><strong>各进程可以打开这个文件进行read&#x2F;write</strong></em>，实际上是在读写内核通道，这样就实现了进程间通信。</li><li>创建方式：</li></ul><ol><li>命令：<strong>mkfifo 管道名</strong></li><li>库函数：<em><em>int mkfifo(const char <em>pathname , mode_t mode);</em></em>  成功：0；失败：-1</em><em>(头文件 sys&#x2F;stat.h)</em>*</li></ol><ul><li>一但使用mkfifo创建一个FIFO，就可以使用open打开它，常见的文件I&#x2F;O函数都可用于fifo。如：close，read，write，unlink等</li></ul><h3 id="存储映射I-x2F-O"><a href="#存储映射I-x2F-O" class="headerlink" title="存储映射I&#x2F;O"></a>存储映射I&#x2F;O</h3><ul><li>存储映射I&#x2F;O(Memory-mapped I&#x2F;O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可以不适用read和write函数的情况下，使用地址(指针)完成I&#x2F;O操作。</li><li>使用这种方法，首先通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现。</li></ul><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308190931049.png" alt="Snipaste_2023-08-19_09-31-15"></p><h4 id="mmap函数-头文件sys-x2F-mman-h"><a href="#mmap函数-头文件sys-x2F-mman-h" class="headerlink" title="mmap函数(头文件sys&#x2F;mman.h)"></a>mmap函数(头文件sys&#x2F;mman.h)</h4><ul><li>**void <em>mmap(void <em>addr , size_t length , int prot , int flags , int fd , off_t offset);</em></em>             创建共享内存映射</li><li>参数：</li></ul><ol><li>addr：指定映射区的首地址。通常传NULL，表示让系统自动分配</li><li>length：共享内存映射区的大小。(&lt;&#x3D;文件的实际大小)</li><li>prot：共享内存映射区的读写属性。PROT_READ、PROT_WRITE、PROT_READ | PROT_WRITE</li><li>flags：标注共享内存的共享属性。MAP_SHARED、<strong>MAP_PRIVATE(当对内存进行修改，不能直接修改磁盘)</strong></li><li>fd：用于创建共享内存映射区的那个文件的 文件描述符</li><li>offset：偏移位置。需要是 <strong>4k</strong> 的整数倍。默认为0，表示映射文件全部</li></ol><ul><li>返回值：</li></ul><ol><li>成功：映射区的首地址。</li><li>失败：MAP_FAILED 设置errno</li></ol><h4 id="munmap函数"><a href="#munmap函数" class="headerlink" title="munmap函数"></a>munmap函数</h4><ul><li>*<em>int munmap(void <em>addr , size_t length);</em></em>        释放映射区</li><li>参数：</li></ul><ol><li>addr：mmap的返回值</li><li>length：大小</li></ol><p>返回值：</p><ol><li>成功：0</li><li>失败：-1</li></ol><h4 id="使用注意事项："><a href="#使用注意事项：" class="headerlink" title="使用注意事项："></a>使用注意事项：</h4><ol><li><p>用于创建映射区的文件大小为0，实际指定非0大小创建映射区，出“总线错误”。</p></li><li><p>用于创建映射区的文件大小为0，实际指定0大小创建映射区，出“无效参数”。**(即映射文件大小为0时，不能创建映射区)**</p></li><li><p>用于创建映射区的文件读写属性为，只读。映射区属性为 读写，出“无效参数”。</p></li><li><p><strong>创建映射区，需要read权限</strong>(隐含了一次对映射区的读操作)。当访问权限指定为“共享”MAP_SHARED时，mmap的读写权限，应该&lt;&#x3D;文件的open权限。<strong>只写不行</strong></p></li><li><p>文件描述符fd，在mmap创建映射区完成即可关闭。<strong>后续访问文件，用地址访问。</strong></p></li><li><p>offset必须是 4096 的整数倍。(MMU映射的最小单位 4k)</p></li><li><p>对申请的映射区内存，不能越界访问。</p></li><li><p>munmap用于释放的地址，必须是<strong>mmap申请返回的地址</strong>。 (指针不能执行++操作，改变了原地址)</p></li><li><p>映射区访问权限为“私有”MAP_PRIVATE，对内存所做的修改，只在内存有效，不会反应到物理磁盘上。</p></li><li><p>映射区访问权限为“私有”MAP_PRIVATE，只需要open文件时，有读权限，用于创建映射区即可。</p></li></ol><ul><li><strong>mmap函数的保险调用方式：</strong></li></ul><ol><li>fd&#x3D;open(“文件名” , O_RDWR);</li><li>mmap(NULL,有效文件大小,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</li></ol><h4 id="mmap父子进程通信"><a href="#mmap父子进程通信" class="headerlink" title="mmap父子进程通信"></a>mmap父子进程通信</h4><ul><li>父子等血缘关系的进程之间也可以通过mmap建立的映射区来完成数据通信。但相应的要在创建映射区的时候指定对应的标志位参数flags：</li><li>MAP_PRIVATE：(私有映射)  父子进程各自独占映射区</li><li>MAP_SHARED：(共享映射)  父子进程共享映射区</li></ul><h4 id="mmap无血缘关系进程间通信"><a href="#mmap无血缘关系进程间通信" class="headerlink" title="mmap无血缘关系进程间通信"></a>mmap无血缘关系进程间通信</h4><ul><li>实际上mmap是内核借助文件帮我们创建了一个映射区，多个进程之间利用该映射区完成数据传递。由于内核空间多进程共享，因此无血缘关系的进程间也可以使用mmap来完成通信。只要设置相应的标志位参数flags即可。</li><li>若想实现共享，使用MAP_SHARED</li><li><strong>值得注意的是：MAP_ANON和&#x2F;dev&#x2F;zero都不能应用于非血缘关系进程间通信。只能应用于亲子进程间。</strong></li></ul><h4 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a>匿名映射</h4><ul><li><p>通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。</p><p>通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。 可以直接使用匿名映射来代替。</p><p>其实Linux系统给我们提供了创建匿名映射区的方法，<strong>无需依赖一个文件即可创建映射区</strong>。同样需要<strong>借助标志位参数flags</strong>来指定。</p></li><li><p>使用**MAP_ANONYMOUS(或MAP_ANON)**，如：</p></li><li><p>int <em>p&#x3D;(int <em>)mmap(NULL,<strong>4,<strong>PROT_READ|PROT_WRITE</strong>,MAP_SHARED|MAP_ANONYMOUS</strong>,**-1</em></em>,0);  (“4”位置可以自行指定大小)</p></li><li><p>需要注意的是，MAP_ANONYMOUS和MAP_ANON这两个宏是Linux操作系统特有的宏。在类Unix系统中无该宏定义，可使用如下两步来完成匿名映射区的建立。</p></li></ul><ol><li>fd&#x3D;open(“&#x2F;dev&#x2F;zero” , O_RDWR);  dev&#x2F;zero:文件宝库(无限读，”\0”)  dev&#x2F;null:文件黑洞(无限写)</li><li>p&#x3D;mmap(NULL , size , PROT_READ|PROT_WRITE , MMAP_SHARED , fd , 0);</li></ol><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><h4 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a>信号的概念</h4><ul><li><p>信号在我们的生活中随处可见，如：古代战争中摔杯为号；现代战争中的信号弹；体育比赛中使用的信号枪…他们都有共性：</p><p>1.简单  2.不能携带大量信息   3.满足某个特设条件才发送</p></li></ul><h5 id="信号的机制"><a href="#信号的机制" class="headerlink" title="信号的机制"></a>信号的机制</h5><ul><li>A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行。与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。</li><li>信号的特质：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延时时间非常短，不易察觉。</li><li><strong>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</strong></li></ul><h5 id="与信号相关的事件和状态"><a href="#与信号相关的事件和状态" class="headerlink" title="与信号相关的事件和状态"></a>与信号相关的事件和状态</h5><ul><li>产生信号：</li></ul><ol><li>按键产生：如：ctrl+c，ctrl+z，ctrl+&#x2F;</li><li>系统调用产生，如：kill，raise，abort</li><li>软件条件产生，如：定时器alarm</li><li>硬件异常产生，如：非法访问内存(段错误)，除0(浮点数例外)，内存对齐错误(总线错误)</li><li>命令产生：如：kill命令</li></ol><ul><li><strong>递达：递送并且到达进程</strong></li><li><strong>未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。</strong></li><li><strong>信号的处理方式：</strong></li></ul><ol><li>执行默认动作</li><li>忽略(丢弃)</li><li>捕捉(调用户处理函数)</li></ol><ul><li><p>Linux内核的进程控制块PCB是一个结构体，task_struct，除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，<strong>主要指阻塞信号集和未决信号集</strong></p></li><li><p><strong>阻塞信号集(信号屏蔽字)：本质：位图。</strong>将某些信号加入集合，对他们设置屏蔽，当屏蔽信号x后，在解决屏蔽前，该信号一直处于未决状态。</p></li><li><p><strong>未决信号集：本质位图。</strong></p></li></ul><ol><li>信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0.这一时刻往往非常短暂。</li><li>信号产生后由于某些原因(主要是阻塞)不能递达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。</li></ol><h5 id="信号的编号"><a href="#信号的编号" class="headerlink" title="信号的编号"></a>信号的编号</h5><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308211101339.png" alt="Snipaste_2023-08-21_11-01-05"></p><h5 id="信号四要素"><a href="#信号四要素" class="headerlink" title="信号四要素"></a>信号四要素</h5><ul><li><p><strong>1.编号  2. 名称  3. 事件  4. ，默认处理动作</strong></p><p>可以通过man 7 signal查看帮助文档获取。也可以查看&#x2F;usr&#x2F;src&#x2F;linux-headers-3.16.0-30&#x2F;arch&#x2F;s390&#x2F;include&#x2F;uapi&#x2F;asm&#x2F;signal.h</p></li></ul><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308211723199.png" alt="1527928967909"></p><ul><li><strong>Action为默认动作：</strong></li></ul><ol><li>Term：终止进程</li><li>lgn：忽略信号(默认即时对该种信号忽略操作)</li><li>Core：终止进程，生成Core文件(查验死亡原因，用于gdb调试)</li><li>Stop停止(暂停)进程</li><li>Cont：继续运行进程</li></ol><ul><li><strong>Linux常规信号一览表</strong></li></ul><table><thead><tr><th align="left"><strong>编号</strong></th><th align="left"><strong>信号</strong></th><th align="left"><strong>对应事件</strong></th><th align="left"><strong>默认动作</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>SIGHUP</strong></td><td align="left">用户退出shell时，由该shell启动的所有进程将收到这个信号</td><td align="left">终止进程</td></tr><tr><td align="left">2</td><td align="left"><strong>SIGINT</strong></td><td align="left">当用户按下了**&lt;Ctrl+C&gt;**组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号</td><td align="left">终止进程</td></tr><tr><td align="left">3</td><td align="left"><strong>SIGQUIT</strong></td><td align="left">用户按下**&lt;ctrl+ \ &gt;**组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号</td><td align="left">终止进程</td></tr><tr><td align="left">4</td><td align="left">SIGILL</td><td align="left">CPU检测到某进程执行了非法指令</td><td align="left">终止进程并产生core文件</td></tr><tr><td align="left">5</td><td align="left">SIGTRAP</td><td align="left">该信号由断点指令或其他 trap指令产生</td><td align="left">终止进程并产生core文件</td></tr><tr><td align="left">6</td><td align="left">SIGABRT</td><td align="left">调用abort函数时产生该信号</td><td align="left">终止进程并产生core文件</td></tr><tr><td align="left">7</td><td align="left"><strong>SIGBUS</strong></td><td align="left">非法访问内存地址，包括内存对齐出错</td><td align="left">终止进程并产生core文件</td></tr><tr><td align="left">8</td><td align="left"><strong>SIGFPE</strong></td><td align="left">在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误</td><td align="left">终止进程并产生core文件</td></tr><tr><td align="left">9</td><td align="left"><em><strong>SIGKILL</strong></em></td><td align="left">无条件终止进程。本信号不能被忽略，处理和阻塞</td><td align="left">终止进程，可以杀死任何进程</td></tr><tr><td align="left">10</td><td align="left"><strong>SIGUSR1</strong></td><td align="left">用户定义的信号。即程序员可以在程序中定义并使用该信号</td><td align="left">终止进程</td></tr><tr><td align="left">11</td><td align="left"><strong>SIGSEGV</strong></td><td align="left">指示进程进行了无效内存访问(段错误)</td><td align="left">终止进程并产生core文件</td></tr><tr><td align="left">12</td><td align="left"><strong>SIGUSR2</strong></td><td align="left">另外一个用户自定义信号，程序员可以在程序中定义并使用该信号</td><td align="left">终止进程</td></tr><tr><td align="left">13</td><td align="left"><strong>SIGPIPE</strong></td><td align="left">Broken pipe向一个没有读端的管道写数据</td><td align="left">终止进程</td></tr><tr><td align="left">14</td><td align="left"><strong>SIGALRM</strong></td><td align="left">定时器超时，超时的时间 由系统调用alarm设置</td><td align="left">终止进程</td></tr><tr><td align="left">15</td><td align="left"><strong>SIGTERM</strong></td><td align="left">程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号</td><td align="left">终止进程</td></tr><tr><td align="left">16</td><td align="left">SIGSTKFLT</td><td align="left">Linux早期版本出现的信号，现仍保留向后兼容</td><td align="left">终止进程</td></tr><tr><td align="left">17</td><td align="left"><strong>SIGCHLD</strong></td><td align="left">子进程结束时，父进程会收到这个信号</td><td align="left">忽略这个信号</td></tr><tr><td align="left">18</td><td align="left">SIGCONT</td><td align="left">如果进程已停止，则使其继续运行</td><td align="left">继续&#x2F;忽略</td></tr><tr><td align="left">19</td><td align="left"><em><strong>SIGSTOP</strong></em></td><td align="left">停止进程的执行。信号不能被忽略，处理和阻塞</td><td align="left">为终止进程</td></tr><tr><td align="left">20</td><td align="left">SIGTSTP</td><td align="left">停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号</td><td align="left">暂停进程</td></tr><tr><td align="left">21</td><td align="left">SIGTTIN</td><td align="left">后台进程读终端控制台</td><td align="left">暂停进程</td></tr><tr><td align="left">22</td><td align="left">SIGTTOU</td><td align="left">该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生</td><td align="left">暂停进程</td></tr><tr><td align="left">23</td><td align="left">SIGURG</td><td align="left">套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达</td><td align="left">忽略该信号</td></tr><tr><td align="left">24</td><td align="left">SIGXCPU</td><td align="left">进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程</td><td align="left">终止进程</td></tr><tr><td align="left">25</td><td align="left">SIGXFSZ</td><td align="left">超过文件的最大长度设置</td><td align="left">终止进程</td></tr><tr><td align="left">26</td><td align="left">SIGVTALRM</td><td align="left">虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间</td><td align="left">终止进程</td></tr><tr><td align="left">27</td><td align="left">SGIPROF</td><td align="left">类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间</td><td align="left">终止进程</td></tr><tr><td align="left">28</td><td align="left">SIGWINCH</td><td align="left">窗口变化大小时发出</td><td align="left">忽略该信号</td></tr><tr><td align="left">29</td><td align="left">SIGIO</td><td align="left">此信号向进程指示发出了一个异步IO事件</td><td align="left">忽略该信号</td></tr><tr><td align="left">30</td><td align="left">SIGPWR</td><td align="left">关机</td><td align="left">终止进程</td></tr><tr><td align="left">31</td><td align="left">SIGSYS</td><td align="left">无效的系统调用</td><td align="left">终止进程并产生core文件</td></tr><tr><td align="left">34~64</td><td align="left">SIGRTMIN ～ SIGRTMAX</td><td align="left">LINUX的实时信号，它们没有固定的含义（可以由用户自定义）</td><td align="left">终止进程</td></tr></tbody></table><ul><li>特别强调：<strong>9) SIGKILL</strong> <strong>和19) SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</strong></li><li>另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送(但不一定递达)，不应乱发信号！</li></ul><h4 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h4><h5 id="kill函数-x2F-命令产生信号"><a href="#kill函数-x2F-命令产生信号" class="headerlink" title="kill函数&#x2F;命令产生信号"></a>kill函数&#x2F;命令产生信号</h5><ul><li>kill命令参数信号：kill -SIGKILL pid</li><li>kill函数：给指定进程发送指定信号(不一定杀死)</li><li>**int kill(pid_t , int sig);<strong>成功：0，失败：-1</strong>(ID非法，信号非法，普通用户杀init进程等权级问题)**，设置errno</li><li>sig：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</li></ul><ol><li>pid&gt;0：发送信号给指定的进程。</li><li>pid&#x3D;0：发送信号给与<strong>调用kill函数进程属于同一进程组的所有进程</strong>。</li><li>pid&lt;-1：区|pid|发送给对应进程组。</li><li>pid&#x3D;-1：发送给进程有权限发送的系统中所有进程。</li></ol><ul><li><strong>进程组</strong>：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，<strong>每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。</strong></li><li>权限保护：super用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。同样，普通用户也不能向其他普通用户发送信号终止其进程，只能向自己创建的进程发送信号。<strong>普通用户基本规则是：发送者实际或有效用户ID&#x3D;&#x3D;接收者实际或有效用户ID。</strong></li></ul><h5 id="其他几个发信号函数"><a href="#其他几个发信号函数" class="headerlink" title="其他几个发信号函数"></a>其他几个发信号函数</h5><ul><li>int raise(int sig);</li><li>void abort(void);</li></ul><h5 id="软件条件产生信号"><a href="#软件条件产生信号" class="headerlink" title="软件条件产生信号"></a>软件条件产生信号</h5><h6 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h6><ul><li><p>设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送 14)SIGALRM 信号。进程收到该信号，默认动作终止。</p></li><li><p><strong>每个进程都有且只有唯一一个定时器。</strong></p></li><li><p>unsigned int alarm(unsigned int seconds); <strong>返回0或剩余的秒数</strong>，无失败。</p></li><li><p>常用：取消定时器 alarm(0)，返回旧闹钟余下秒数。</p></li><li><p>例：alarm(5) →3sec →alarm(4) (返回2s)→5sec→alarm(5) (返回0s)→alarm(0) </p></li><li><p>定时，与进程状态无关(自然定时法)！就绪，运行，挂起(阻塞，暂停)，终止，僵尸…无论进程处于何种状态，alarm都计时。</p></li><li><p>使用time命令查看程序执行时间。 time .&#x2F;alarm  <strong>程序运行的瓶颈在于IO，优化程序，首选优化IO。</strong></p></li><li><p><strong>实际执行时间&#x3D;系统时间+用户时间+<em>等待时间</em></strong></p></li></ul><h6 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which,  <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value, <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br><span class="line">功能：</span><br><span class="line">    设置定时器(闹钟)。 可代替alarm函数。精度微秒us，可以实现周期定时。</span><br><span class="line">参数：</span><br><span class="line">    which：指定定时方式</span><br><span class="line">        a) 自然定时：ITIMER_REAL → <span class="number">14</span>）SIGALRM计算自然时间</span><br><span class="line">        b) 虚拟空间计时(用户空间)：ITIMER_VIRTUAL → <span class="number">26</span>）SIGVTALRM  只计算进程占用cpu的时间</span><br><span class="line">        c) 运行时计时(用户 + 内核)：ITIMER_PROF → <span class="number">27</span>）SIGPROF计算占用cpu及执行系统调用的时间</span><br><span class="line">    </span><br><span class="line">    new_value：定时秒数 (相当于alarm的seconds)</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_interval</span>;</span> <span class="comment">// 闹钟触发周期</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_value</span>;</span>    <span class="comment">// 闹钟触发时间</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">            <span class="type">long</span> tv_sec;            <span class="comment">// 秒</span></span><br><span class="line">            <span class="type">long</span> tv_usec;           <span class="comment">// 微秒</span></span><br><span class="line">        &#125;</span><br><span class="line">        itimerval.it_value：     设定第一次执行function所延迟的秒数 (<span class="keyword">do</span>)</span><br><span class="line">        itimerval.it_interval：  设定以后每几秒执行function   (<span class="keyword">while</span>)</span><br><span class="line">​</span><br><span class="line">    old_value： 传出参数，上次定时剩余时间(相对于alarm的返回值)，一般指定为<span class="literal">NULL</span></span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="信号集概述"><a href="#信号集概述" class="headerlink" title="信号集概述"></a>信号集概述</h4><ul><li>这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对其进行位操作。而需自定义另外一个集合，接着信号集操作函数来对PCB中的这两个信号集进行修改。</li></ul><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308232043891.png" alt="Snipaste_2023-08-23_10-00-15"></p><h5 id="信号集设定"><a href="#信号集设定" class="headerlink" title="信号集设定"></a>信号集设定</h5><ul><li><p><strong>#include &lt;signal.h&gt;</strong>  </p></li><li><p><strong>sigset_t set;</strong>    &#x2F;&#x2F;typedef unsigned long sigset_t;</p></li><li><p>int sig<strong>empty</strong>set(sigset_t *set);       &#x2F;&#x2F;将set集合置空(清0)                                                成功：0；失败-1</p></li><li><p>int sig<strong>fill</strong>set(sigset_t *set)；          &#x2F;&#x2F;将所有信号加入set集合(全置1)                              成功：0；失败-1</p></li><li><p>int sig<strong>add</strong>set(sigset_t *set, int signo);  &#x2F;&#x2F;将signo信号加入到set集合(单个置1)            成功：0；失败-1</p></li><li><p>int sig<strong>del</strong>set(sigset_t *set, int signo);   &#x2F;&#x2F;从set集合中移除signo信号(单个清0)            成功：0；失败-1</p></li><li><p>int sig<strong>ismember</strong>(const sigset_t *set, int signo); &#x2F;&#x2F;判断信号是否存在                           在：1；不在：0；出错：-1</p></li><li><p>sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。</p></li></ul><h5 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h5><ul><li>用来屏蔽信号。解除屏蔽也使用该函数。其本质，读取或修改进程的信号屏蔽字(PCB中)</li><li>严格注意，<strong>屏蔽信号：只是将信号处理延迟执行(延迟到解除屏蔽时)<strong>，而</strong>忽略</strong>表示将信号丢处理。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line">功能：</span><br><span class="line">    检查或修改信号阻塞集，根据 how 指定的方法对进程的阻塞集合进行修改，新的信号阻塞集由 <span class="built_in">set</span> 指定，而原先的信号阻塞集合由 oldset 保存。</span><br><span class="line">​</span><br><span class="line">参数：</span><br><span class="line">    how : 信号阻塞集合的修改方法，有 <span class="number">3</span> 种情况：</span><br><span class="line">        SIG_BLOCK：当how设置为此值，<span class="built_in">set</span>表示需要屏蔽的信号。相当于 mask = mask|<span class="built_in">set</span>。</span><br><span class="line">        SIG_UNBLOCK：当how设置为此值，<span class="built_in">set</span>表示需要解除屏蔽的信号。相当于 mask = mask &amp; ~ <span class="built_in">set</span>。</span><br><span class="line">        SIG_SETMASK：当how设置为此值，<span class="built_in">set</span>表示用于替代原始屏蔽集的新屏蔽集。相当于mask = <span class="built_in">set</span>。</span><br><span class="line">        若调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">set</span> : 传入参数，是一个位图，<span class="built_in">set</span>中哪个位置为<span class="number">1</span>，就表示当前进程屏蔽哪个信号。要操作的信号集地址。</span><br><span class="line">        若 <span class="built_in">set</span> 为 <span class="literal">NULL</span>，则不改变信号阻塞集合，函数只把当前信号阻塞集合保存到 oldset 中。</span><br><span class="line">    oldset : 传出参数，保存原先信号阻塞集地址</span><br><span class="line">​</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span>，</span><br><span class="line">    失败：<span class="number">-1</span>，失败时错误代码只可能是 EINVAL，表示参数 how 不合法。</span><br></pre></td></tr></table></figure><h5 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a>sigpending函数</h5><ul><li><strong>读取</strong>当前进程的未决信号集</li><li>int sigpending(sigset_t *set);set传出参数。返回值：成功：0；失败：-1，设置errno</li></ul><h4 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h4><h5 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h5><ul><li><strong>注册</strong>一个信号捕捉函数</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;(不加<span class="keyword">typedef</span>为一个函数指针，返回值为<span class="type">void</span>，参数为<span class="type">int</span>)</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line">功能：</span><br><span class="line">    注册信号处理函数（不可用于 SIGKILL、SIGSTOP 信号），即确定收到信号后处理函数的入口地址。此函数不会阻塞。</span><br><span class="line">​</span><br><span class="line">参数：</span><br><span class="line">    signum：信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令 kill - l(<span class="string">&quot;l&quot;</span> 为字母)进行相应查看。</span><br><span class="line">    handler : 取值有 <span class="number">3</span> 种情况：</span><br><span class="line">          SIG_IGN：忽略该信号</span><br><span class="line">          SIG_DFL：执行系统默认动作</span><br><span class="line">          信号处理函数名：自定义信号处理函数，如：func</span><br><span class="line">          回调函数的定义如下：</span><br><span class="line">            <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// signo 为触发的信号，为 signal() 第一个参数的值</span></span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">返回值：</span><br><span class="line">    成功：第一次返回 <span class="literal">NULL</span>，下一次返回此信号上一次注册的信号处理函数的地址。如果需要使用此返回值，必须在前面先声明此函数指针的类型。</span><br><span class="line">    失败：返回 SIG_ERR</span><br></pre></td></tr></table></figure><ul><li>该函数由ANSI定义，由于历史原因在不同版本的Unix和不同版本的Linux中可能有不同的行为。因此应该尽量避免使用它，取而代之使用sigaction函数。</li></ul><h5 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h5><ul><li>修改信号处理动作(通常在Linux用其来注册一个信号的捕捉函数)</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line">功能：</span><br><span class="line">    检查或修改指定信号的设置（或同时执行这两种操作）。</span><br><span class="line">​</span><br><span class="line">参数：</span><br><span class="line">    signum：要操作的信号。</span><br><span class="line">    act：   要设置的对信号的新处理方式（传入参数）。</span><br><span class="line">    oldact：原来对信号的处理方式（传出参数）。</span><br><span class="line">​</span><br><span class="line">    如果 act 指针非空，则要改变指定信号的处理方式（设置），如果 oldact 指针非空，则系统将此前指定信号的处理方式存入 oldact。</span><br><span class="line">​</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><ul><li><strong>struct sigaction结构体：</strong></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>(*sa_handler)(<span class="type">int</span>); <span class="comment">//旧的信号处理函数指针</span></span><br><span class="line">    <span class="type">void</span>(*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *); <span class="comment">//新的信号处理函数指针(携带复杂数据时使用)</span></span><br><span class="line">    <span class="type">sigset_t</span>   sa_mask;      <span class="comment">//信号阻塞集(只工作于信号捕捉函数执行期间) (用sigemptyset函数初始化)</span></span><br><span class="line">    <span class="type">int</span>        sa_flags;     <span class="comment">//信号处理的方式</span></span><br><span class="line">    <span class="type">void</span>(*sa_restorer)(<span class="type">void</span>); <span class="comment">//已弃用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) sa_handler、sa_sigaction：信号处理函数指针，和 signal() 里的函数指针用法一样，应根据情况给sa_sigaction、sa_handler 两者之一赋值，其取值如下：</span><br><span class="line"></span><br><span class="line">a) SIG_IGN：忽略该信号</span><br><span class="line"></span><br><span class="line">b) SIG_DFL：执行系统默认动作</span><br><span class="line"></span><br><span class="line">c) 处理函数名：自定义信号处理函数</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>) sa_mask：信号阻塞集，在信号处理函数执行过程中，临时屏蔽指定的信号。</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) sa_flags：用于指定信号处理的行为，通常设置为<span class="number">0</span>，表使用默认属性。它可以是一下值的“按位或”组合：</span><br><span class="line"></span><br><span class="line">Ø SA_RESTART：使被信号打断的系统调用自动重新发起（已经废弃）</span><br><span class="line"></span><br><span class="line">Ø SA_NOCLDSTOP：使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号。</span><br><span class="line"></span><br><span class="line">Ø SA_NOCLDWAIT：使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程。</span><br><span class="line"></span><br><span class="line">Ø SA_NODEFER：使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号。</span><br><span class="line"></span><br><span class="line">Ø SA_RESETHAND：信号处理之后重新设置为默认的处理方式。</span><br><span class="line"></span><br><span class="line">Ø SA_SIGINFO：使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数。</span><br></pre></td></tr></table></figure><h5 id="信号捕捉特性"><a href="#信号捕捉特性" class="headerlink" title="信号捕捉特性"></a>信号捕捉特性</h5><ol><li>进程正常执行时，默认PCB中有一个信号屏蔽字mask，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该函数以后，要调用该函数。<strong>而该函数有可能执行很长时间，在这期间所屏蔽的信号不由mask来指定。而是用sa_mask来指定。调用完信号处理函数，再恢复为mask。</strong></li><li>xxx信号捕捉函数执行期间，xxx信号自动被屏蔽。</li><li><strong>阻塞的常规信号不支持排队，产生多次只记录一次。</strong>(后32个实时信号支持排队)</li></ol><h5 id="内核实现信号捕捉过程"><a href="#内核实现信号捕捉过程" class="headerlink" title="内核实现信号捕捉过程"></a>内核实现信号捕捉过程</h5><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308241102712.png" alt="1527931072795"></p><h4 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h4><h6 id="SIGCHLD的产生条件"><a href="#SIGCHLD的产生条件" class="headerlink" title="SIGCHLD的产生条件"></a>SIGCHLD的产生条件</h6><ol><li>子进程终止时</li><li>子进程接收到SIGSTOP信号停止时</li><li>子进程处在停止态，接收到SIGCONT后唤醒时</li></ol><h3 id="进程组和会话"><a href="#进程组和会话" class="headerlink" title="进程组和会话"></a>进程组和会话</h3><h4 id="概念和特性"><a href="#概念和特性" class="headerlink" title="概念和特性"></a>概念和特性</h4><ul><li><p>进程组，也称之为作业。BSD于1980年前后向Unix中增加的一个新特性。<strong>代表一个或多个进程的集合。</strong></p></li><li><p>每个进程都属于一个进程组。在waitpid函数和kill函数的参数中都曾使用到。操作系统设计的进程组的概念，是为了简化对多个进程的管理。</p></li><li><p>当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。进程组ID为第一个进程ID(组长进程)。所以，组长进程标识：其进程组ID为其进程ID</p></li><li><p>可以使用<strong>kill -SIGKILL -进程组ID</strong>(负的)来将整个进程组内的进程全部杀死。</p></li><li><p>组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。<strong>只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。</strong></p></li><li><p>进程组生存期：进程组创建到最后一个进程离开(终止或转移到另一个进程组)。</p></li><li><p>一个进程可以为自己或子进程设置进程组ID。</p></li></ul><h4 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h4><ul><li>创建一个会话需要注意以下6点注意事项：</li></ul><ol><li><strong>调用进程不能是进程组组长</strong>，该进程变成新会话首进程(session header)</li><li>该调用进程是组长进程，则出错返回</li><li>该进程成为一个<strong>新进程组的组长进程</strong></li><li>需有root权限(ubuntu不需要)</li><li>新会话丢弃原有的控制终端，<strong>该会话没有控制终端</strong></li><li>建立新会话时，先调用fork, 父进程终止，子进程调用setsid</li></ol><h4 id="getsid函数："><a href="#getsid函数：" class="headerlink" title="getsid函数："></a>getsid函数：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line">功能：获取进程所属的会话ID</span><br><span class="line">参数：</span><br><span class="line">    pid：进程号，(pid为<span class="number">0</span>表示查看当前进程session ID)</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回调用进程的会话ID</span><br><span class="line">    失败：<span class="number">-1</span>，设置errno</span><br></pre></td></tr></table></figure><ul><li>ps ajx命令查看系统中的进程。参数a表示不仅列当前用户的进程，也列出所有其他用户的进程，参数x表示不仅列有控制终端的进程，也列出所有无控制终端的进程，参数j表示列出与作业控制相关的信息。</li><li>组长进程不能成为新会话首进程，新会话首进程必定会成为组长进程。</li></ul><h4 id="setsid函数："><a href="#setsid函数：" class="headerlink" title="setsid函数："></a>setsid函数：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：</span><br><span class="line">    创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID。</span><br><span class="line">    调用了setsid函数的进程，既是新的会长，也是新的组长。</span><br><span class="line">参数：无</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回调用进程的会话ID</span><br><span class="line">    失败：<span class="number">-1</span>，设置errno</span><br></pre></td></tr></table></figure><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><ul><li><p>Daemon(精灵)进程，是Linux中的后台服务进程，通常<strong>独立于控制终端</strong>并且<strong>周期性地执行某种任务</strong>或<strong>等待处理某些发生的事件</strong>。一般采用以d结尾的名字。</p></li><li><p>Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录，注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现：ftp服务器；nfs服务器…</p></li><li><p><strong>守护进程是个特殊的孤儿进程</strong>，这种进程脱离终端，为什么要脱离终端呢？之所以<strong>脱离于终端是为了避免进程被任何终端所产生的信息所打断</strong>，其在执行过程中的信息也不在任何终端上显示。由于在 Linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。</p></li><li><p>创建守护进程，最关键的一步是调用setsid函数创建一个新的Session，并成为Session Leader。</p></li></ul><h4 id="创建守护进程模型"><a href="#创建守护进程模型" class="headerlink" title="创建守护进程模型"></a>创建守护进程模型</h4><ol><li>创建子进程，让父进程退出(所有工作在子进程中形式上脱离控制终端)</li><li>子进程调用 <strong>setsid()</strong> 创建新会话(使子进程完全独立出来，脱离控制)</li><li>通常根据需要，改变工作目录位置 <strong>chdir()</strong> (防止占用可卸载的文件系统)</li><li>通常根据需要，重设umask文件权限掩码(防止继承的文件创建屏蔽字拒绝某些权限，增加守护进程的灵活性)</li><li>通常根据需要，<strong>关闭&#x2F;重定向</strong> (0,1,2重定向到&#x2F;dev&#x2F;null) 文件描述符(继承的打开文件不会用到的，浪费系统资源，无法卸载)</li><li>开始执行守护进程的核心工作：守护进程退出处理程序模型(while大循环)</li></ol><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h4><ul><li>线程是轻量级的进程（LWP：light weight process），<strong>在Linux环境下线程的本质仍是进程。</strong></li><li>进程：有独立的 进程地址空间 。有独立的PCB。<strong>分配资源的最小单位。</strong></li><li>线程：有独立的PCB。没有独立的进程地址空间(共享)。</li></ul><h4 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a>Linux内核线程实现原理</h4><ul><li><p>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。</p></li><li><p>因此在这类系统中，进程和线程关系密切：</p></li></ul><ol><li><p>线程是轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone</p></li><li><p>从内核里看进程和线程是一样的，都有各自不同的PCB.</p></li><li><p>进程可以蜕变成线程</p></li><li><p><strong>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</strong></p></li></ol><ul><li>查看指定进程的LWP号：</li></ul><blockquote><p>ps  -Lf  pid</p></blockquote><p>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数 clone 。</p><p>Ø 如果复制对方的地址空间，那么就产出一个“进程”；</p><p>Ø 如果共享对方的地址空间，就产生一个“线程”。</p><p>Linux内核是不区分进程和线程的, 只在用户层面上进行区分。所以，线程所有操作函数 pthread_* 是库函数，而非系统调用。</p><p><img src="F:\图片管理中心\学习\Snipaste_2023-08-26_21-59-41.png" alt="Snipaste_2023-08-26_21-59-41"></p><h4 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a>线程共享资源</h4><ol><li>文件描述符表</li><li>每种信号的处理方式</li><li>当前工作目录</li><li>用户ID和组ID</li><li>内存地址空间(.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库)<strong>(全局变量)</strong></li></ol><h4 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a>线程非共享资源</h4><ol><li>线程id</li><li>处理器现场(寄存器数据)和栈指针(内核栈)</li><li>独立的栈空间(用户空间栈)(局部变量)</li><li>errno变量(全局变量)</li><li>信号屏蔽字</li><li>调度优先级</li></ol><h4 id="线程优缺点"><a href="#线程优缺点" class="headerlink" title="线程优缺点"></a>线程优缺点</h4><ul><li>优点：</li></ul><ol><li>提高程序并发性</li><li>开销小</li><li>数据通信，共享数据方便</li></ol><ul><li>缺点：</li></ul><ol><li>库函数，不稳定</li><li>调试，编写困难，gdb不支持</li><li>对信号支持不好</li></ol><ul><li>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程，线程差别不是很大。</li></ul><h3 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a>线程控制原语</h3><ul><li>就像每个进程都有一个进程号一样，每个线程也有一个线程号。进程号在整个系统中是唯一的，但线程号不同，线程号只在它所属的进程环境中有效。</li><li>进程号用 pid_t 数据类型表示，是一个非负整数。线程号则用 pthread_t 数据类型来表示，**Linux 使用无符号长整数表示(%lu)**。</li><li>有的系统在实现pthread_t 的时候，用一个结构体来表示，所以在可移植的操作系统实现不能把它做为整数处理。</li><li><strong>检查出错返回：线程中使用。 –fprintf(stderr,”xxx error:%s\n”,strerror(ret));</strong></li></ul><h4 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a>pthread_self函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取线程号。</span><br><span class="line">参数：</span><br><span class="line">    无</span><br><span class="line">返回值：</span><br><span class="line">    调用线程的线程 ID 。</span><br></pre></td></tr></table></figure><h4 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a>pthread_create函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">            <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *),</span></span><br><span class="line"><span class="params">            <span class="type">void</span> *arg )</span>;</span><br><span class="line">功能：</span><br><span class="line">    创建一个线程。</span><br><span class="line">参数：</span><br><span class="line">    thread：线程标识符地址。</span><br><span class="line">    attr：线程属性结构体地址，通常设置为 <span class="literal">NULL</span>。</span><br><span class="line">    start_routine：线程函数的入口地址。</span><br><span class="line">    arg：传给线程函数的参数。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li><p>在一个线程中调用pthread_create()创建新的线程后，当前线程从pthread_create()返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。</p></li><li><p>由于pthread_create的错误码不保存在errno中，因此不能直接用perror()打印错误信息，可以先用**strerror()**把错误码转换成错误信息再打印。</p></li></ul><h4 id="pthread-exit-函数"><a href="#pthread-exit-函数" class="headerlink" title="pthread_exit()函数"></a>pthread_exit()函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line">功能：</span><br><span class="line">    退出调用线程。一个进程中的多个线程是共享该进程的数据段，因此，通常线程退出后所占用的资源并不会释放。</span><br><span class="line">参数：</span><br><span class="line">    retval：存储线程退出状态的指针。无退出值时，传<span class="literal">NULL</span></span><br><span class="line">    <span class="title function_">exit</span><span class="params">()</span>：退出当前进程</span><br><span class="line">    <span class="keyword">return</span>：返回到调用者那里去</span><br><span class="line">返回值：无  </span><br></pre></td></tr></table></figure><p>在进程中我们可以调用exit函数或_exit函数来结束进程，在一个线程中我们可以通过以下三种在不终止整个进程的情况下停止它的控制流。</p><ul><li>线程从执行函数中返回。</li><li>线程调用pthread_exit退出线程。</li><li>线程可以被同一进程中的其它线程取消。</li></ul><h4 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line">功能：</span><br><span class="line">    等待线程结束（此函数会阻塞），并回收线程资源，类似进程的 wait() 函数。如果线程已经结束，那么该函数会立即返回。</span><br><span class="line">参数：</span><br><span class="line">    thread：被等待的线程号。</span><br><span class="line">    retval：用来存储线程退出状态的指针的地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>调用该函数的线程将挂起等待，直到id为thread的线程终止。thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下：</li></ul><ol><li><p>如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。</p></li><li><p>如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED。</p></li><li><p>如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。</p></li></ol><h4 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">功能：</span><br><span class="line">    使调用线程与当前进程分离，分离后不代表此线程不依赖与当前进程，线程分离的目的是将线程资源的回收工作交由系统自动来完成，也就是说当被分离的线程结束之后，系统会自动回收它的资源。所以，此函数不会阻塞。</span><br><span class="line">参数：</span><br><span class="line">    thread：线程号。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止。</strong>但是线程也可以被<em><strong>置为detach状态</strong></em>，这样的线程一旦终止就立刻回收它占用的所有资源，而<em><strong>不保留终止状态</strong></em>。</p></li><li><p><strong>不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。</strong>也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。</p></li></ul><h4 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">功能：</span><br><span class="line">    杀死(取消)线程。需要到达取消点(保存点)</span><br><span class="line">参数：</span><br><span class="line">    thread : 目标线程ID。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：出错编号</span><br></pre></td></tr></table></figure><ul><li><p><strong>注意：线程的取消并不是实时的，而又一定的延时。需要等待线程到达某个取消点(检查点)。</strong></p></li><li><p>类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。</p></li><li><p>杀死线程也不是立刻就能完成，<strong>必须要到达取消点。</strong>(没有到达，那么pthread_cancel无效)</p></li><li><p>我们可以在程序中，<strong>手动添加</strong>一个取消点。使用**pthread_testcancel()**。</p></li><li><p><strong>成功被pthread_cancel()杀死的线程，<em>返回-1</em>.使用pthread_join回收。</strong></p></li><li><p>取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write….. 执行命令<strong>man 7 pthreads</strong>可以查看具备这些取消点的系统调用列表。</p></li><li><p>可粗略认为一个**系统调用(进入内核)**即为一个取消点。</p></li></ul><h4 id="进程和线程控制原语对比"><a href="#进程和线程控制原语对比" class="headerlink" title="进程和线程控制原语对比"></a>进程和线程控制原语对比</h4><table><thead><tr><th align="center">线程控制原语</th><th align="center">进程控制原语</th></tr></thead><tbody><tr><td align="center">pthread_create()</td><td align="center">fork()</td></tr><tr><td align="center">pthread_self()</td><td align="center">getpid()</td></tr><tr><td align="center">pthread_exit()</td><td align="center">exit()&#x2F;return</td></tr><tr><td align="center">pthread_join()</td><td align="center">wait()&#x2F;waitpid()</td></tr><tr><td align="center">pthread_cancel()</td><td align="center">kill()</td></tr><tr><td align="center">pthread_detach()</td><td align="center"></td></tr></tbody></table><h4 id="线程使用注意事项"><a href="#线程使用注意事项" class="headerlink" title="线程使用注意事项"></a>线程使用注意事项</h4><ul><li><p><strong>主线程退出其他线程不退出，主线程应调用pthread_exit</strong></p></li><li><p>避免僵尸线程</p></li></ul><ol><li><p>pthread_join</p></li><li><p>pthread_detach</p></li><li><p>pthread_create指定分离属性</p><p>被join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程栈中的值;</p></li></ol><ul><li><p>malloc和mmap申请的内存可以被其他线程释放**(线程之间共享堆区)**</p></li><li><p>应避免在多线程模型中调用fork，除非马上exec，<strong>子进程中只有调用fork的线程存在，其他线程在子进程中均pthread_exit</strong></p></li><li><p>信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制**(线程对于信号，谁抢到谁处理(处理方式共享)。mask独立，未决信号集共享)**</p></li></ul><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ul><li><p><strong>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其他线程为保证数据一致性，不能调用该功能。</strong></p></li><li><p><strong>所有”多个控制流，共同操作一个共享资源”的情况，都需要同步。</strong></p></li></ul><h4 id="数据混乱原因"><a href="#数据混乱原因" class="headerlink" title="数据混乱原因"></a>数据混乱原因</h4><ol><li>资源共享(独享资源则不会)</li><li>调度随机(意味着数据访问会出现竞争)</li><li>线程间缺乏必要的同步机制。</li></ol><ul><li>以上3点中，<strong>前两点不能改变</strong> ：欲提高效率，传递数据，资源必须共享；只要共享资源，就一定会出现竞争。</li><li>从第三点着手解决。<strong>使多个线程在访问共享资源的时候，出现互斥。</strong></li></ul><h4 id="互斥量Mutex"><a href="#互斥量Mutex" class="headerlink" title="互斥量Mutex"></a>互斥量Mutex</h4><ul><li>Linux中提供一把互斥锁mutex(也称之为互斥量)。</li><li><strong>每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。</strong></li><li><strong>资源还是共享的，线程间也还是竞争的。</strong></li><li>但通过”锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</li></ul><p><strong>但，应注意：同一时刻，只能有一个线程持有该锁。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。</span><br><span class="line">   所以，互斥锁实质上是操作系统提供的一把<span class="string">&quot;建议锁&quot;</span>(又称<span class="string">&quot;协同锁&quot;</span>)，建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。</span><br><span class="line">   因此，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱。</span><br></pre></td></tr></table></figure><h5 id="主要应用函数："><a href="#主要应用函数：" class="headerlink" title="主要应用函数："></a>主要应用函数：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_mutex_init函数</span><br><span class="line">pthread_mutex_destroy函数</span><br><span class="line">pthread_mutex_lock函数</span><br><span class="line">pthread_mutex_trylock函数</span><br><span class="line">pthread_mutex_unlock函数</span><br><span class="line">注意事项：</span><br><span class="line">    尽量保证锁的粒度，越小越好。(访问共享数据前，加锁。访问结束【立即】解锁)</span><br><span class="line">    互斥锁，本质是结构体。我们可以看成整数。初值为<span class="number">1.</span>(pthread_mutex_init()函数调用成功)</span><br><span class="line">    加锁：--操作阻塞线程</span><br><span class="line">    解锁：++操作唤醒阻塞在锁上的线程</span><br><span class="line">    try锁：尝试加锁，成功--，失败返回(不阻塞)，同时设置错误号(EBUSY)</span><br><span class="line">初始化互斥量：</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="number">1.</span>pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);动态初始化</span><br><span class="line"><span class="number">2.</span><span class="type">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER;静态初始化</span><br></pre></td></tr></table></figure><ul><li>以上5个函数的返回值都是：<strong>成功返回0，失败返回错误号</strong></li><li><strong>pthread_mutex_t类型，其本质是一个结构体</strong>。为简化理解，应用时可忽略其实现细节，简单<strong>当成整数看待</strong>。</li><li><strong>pthread_mutex_t mutex；变量mutex只有两种取值1，0。</strong></li></ul><p><img src="F:\图片管理中心\学习\Snipaste_2023-09-06_09-42-04.png" alt="Snipaste_2023-09-06_09-42-04"></p><h6 id="pthread-mutex-init函数"><a href="#pthread-mutex-init函数" class="headerlink" title="pthread_mutex_init函数"></a>pthread_mutex_init函数</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    初始化一个互斥锁。</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址。类型是 <span class="type">pthread_mutex_t</span> 。</span><br><span class="line">    attr：设置互斥量的属性，通常可采用默认属性，即可将 attr 设为 <span class="literal">NULL</span>。</span><br><span class="line">​</span><br><span class="line">    可以使用宏 PTHREAD_MUTEX_INITIALIZER 静态初始化互斥锁，比如：</span><br><span class="line">    <span class="type">pthread_mutex_t</span>  mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">​</span><br><span class="line">这种方法等价于使用 <span class="literal">NULL</span> 指定的 attr 参数调用 pthread_mutex_init() 来完成动态初始化，不同之处在于 PTHREAD_MUTEX_INITIALIZER 宏不进行错误检查。</span><br><span class="line">​</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span>，成功申请的锁默认是打开的。</span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br></pre></td></tr></table></figure><blockquote><p>restrict，C语言中的一种类型<a href="https://baike.baidu.com/item/%E9%99%90%E5%AE%9A%E7%AC%A6/1924249">限定符</a>（Type Qualifiers），用于告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。</p></blockquote><h6 id="pthread-mutex-destroy函数"><a href="#pthread-mutex-destroy函数" class="headerlink" title="pthread_mutex_destroy函数"></a>pthread_mutex_destroy函数</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    销毁指定的一个互斥锁。互斥锁在使用完毕后，必须要对互斥锁进行销毁，以释放资源。</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br></pre></td></tr></table></figure><h6 id="pthread-mutex-lock函数"><a href="#pthread-mutex-lock函数" class="headerlink" title="pthread_mutex_lock函数"></a>pthread_mutex_lock函数</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    对互斥锁上锁，若互斥锁已经上锁，则调用者阻塞，直到互斥锁解锁后再上锁。</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">   调用该函数时，若互斥锁未加锁，则上锁，返回 <span class="number">0</span>；</span><br><span class="line">   若互斥锁已加锁，则函数直接返回失败，即 EBUSY。</span><br></pre></td></tr></table></figure><h6 id="pthread-mutex-unlock函数"><a href="#pthread-mutex-unlock函数" class="headerlink" title="pthread_mutex_unlock函数"></a>pthread_mutex_unlock函数</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    对指定的互斥锁解锁。</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>是使用锁不恰当导致的现象：</li></ul><ol><li>对一个锁反复lock</li><li>两个线程，各自持有一把锁，请求另一把。</li></ol><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202309071905447.png" alt="Snipaste_2023-09-07_19-03-25"></p><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><ul><li><strong>锁只有一把。</strong>以读方式给数据加锁 – 读锁。以写方式给数据加锁 – 写锁。</li><li><strong>读共享，写独占。</strong></li><li><strong>写锁优先级高</strong>。</li><li>相较于互斥量而言，当读线程多的时候，提高访问效率</li></ul><h5 id="主要应用函数"><a href="#主要应用函数" class="headerlink" title="主要应用函数"></a>主要应用函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_rwlock_init函数</span><br><span class="line">pthread_rwlock_destroy函数</span><br><span class="line">pthread_rwlock_rdlock函数</span><br><span class="line">pthread_rwlock_wrlock函数</span><br><span class="line">pthread_rwlock_tryrdlock函数</span><br><span class="line">pthread_rwlock_trywrlock函数</span><br><span class="line">pthread_rwlock_unlock函数   </span><br><span class="line">以上<span class="number">7</span>个函数的返回值都是：成功返回<span class="number">0</span>，失败返回非<span class="number">0</span>，错误号errno</span><br><span class="line"><span class="type">pthread_rwlock_t</span>类型 用于定义一个读写锁变量</span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock    </span><br></pre></td></tr></table></figure><h5 id="pthread-rwlock-init函数"><a href="#pthread-rwlock-init函数" class="headerlink" title="pthread_rwlock_init函数"></a>pthread_rwlock_init函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    用来初始化 rwlock 所指向的读写锁。</span><br><span class="line">​</span><br><span class="line">参数：</span><br><span class="line">    rwlock：指向要初始化的读写锁指针。</span><br><span class="line">    attr：读写锁的属性指针。如果 attr 为 <span class="literal">NULL</span> 则会使用默认的属性初始化读写锁，否则使用指定的 attr 初始化读写锁。</span><br><span class="line">​</span><br><span class="line">    可以使用宏 PTHREAD_RWLOCK_INITIALIZER 静态初始化读写锁，比如：</span><br><span class="line">    <span class="type">pthread_rwlock_t</span> my_rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line">​</span><br><span class="line">    这种方法等价于使用 <span class="literal">NULL</span> 指定的 attr 参数调用 pthread_rwlock_init() 来完成动态初始化，不同之处在于PTHREAD_RWLOCK_INITIALIZER 宏不进行错误检查。</span><br><span class="line">​</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span>，读写锁的状态将成为已初始化和已解锁。</span><br><span class="line">    失败：非 <span class="number">0</span> 错误码。</span><br></pre></td></tr></table></figure><h5 id="pthread-rwlock-destroy函数"><a href="#pthread-rwlock-destroy函数" class="headerlink" title="pthread_rwlock_destroy函数"></a>pthread_rwlock_destroy函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    用于销毁一个读写锁，并释放所有相关联的资源（所谓的所有指的是由 pthread_rwlock_init() 自动申请的资源） 。</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br></pre></td></tr></table></figure><h5 id="pthread-rwlock-rdlock函数"><a href="#pthread-rwlock-rdlock函数" class="headerlink" title="pthread_rwlock_rdlock函数"></a>pthread_rwlock_rdlock函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    以阻塞方式在读写锁上获取读锁（读锁定）。</span><br><span class="line">    如果没有写者持有该锁，并且没有写者阻塞在该锁上，则调用线程会获取读锁。</span><br><span class="line">    如果调用线程未获取读锁，则它将阻塞直到它获取了该锁。一个线程可以在一个读写锁上多次执行读锁定。</span><br><span class="line">    线程可以成功调用 pthread_rwlock_rdlock() 函数 n 次，但是之后该线程必须调用 pthread_rwlock_unlock() 函数 n 次才能解除锁定。</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">   用于尝试以非阻塞的方式来在读写锁上获取读锁。</span><br><span class="line">   如果有任何的写者持有该锁或有写者阻塞在该读写锁上，则立即失败返回。</span><br></pre></td></tr></table></figure><h5 id="pthread-rwlock-wrlock函数"><a href="#pthread-rwlock-wrlock函数" class="headerlink" title="pthread_rwlock_wrlock函数"></a>pthread_rwlock_wrlock函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    在读写锁上获取写锁（写锁定）。</span><br><span class="line">    如果没有写者持有该锁，并且没有写者读者持有该锁，则调用线程会获取写锁。</span><br><span class="line">    如果调用线程未获取写锁，则它将阻塞直到它获取了该锁。</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">   用于尝试以非阻塞的方式来在读写锁上获取写锁。</span><br><span class="line">   如果有任何的读者或写者持有该锁，则立即失败返回。</span><br></pre></td></tr></table></figure><h5 id="pthread-rwlock-unlock函数"><a href="#pthread-rwlock-unlock函数" class="headerlink" title="pthread_rwlock_unlock函数"></a>pthread_rwlock_unlock函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    无论是读锁或写锁，都可以通过此函数解锁。</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br></pre></td></tr></table></figure><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><ul><li><strong>条件变量本身不是锁</strong>。但它也可以造成线程阻塞。<strong>通常与互斥锁配合使用</strong>。给多线程提供一个会合的场所。</li></ul><h5 id="主要应用函数-1"><a href="#主要应用函数-1" class="headerlink" title="主要应用函数"></a>主要应用函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_cond_init函数</span><br><span class="line">pthread_cond_destroy函数 </span><br><span class="line">pthread_cond_wait函数  </span><br><span class="line">pthread_cond_timewait函数</span><br><span class="line">pthread_cond_signal函数</span><br><span class="line">pthread_cond_broadcast函数  </span><br><span class="line">以上<span class="number">6</span>个函数的返回值都是：成功返回<span class="number">0</span>，失败返回错误号</span><br><span class="line"><span class="type">pthread_cond_t</span>类型 用于定义条件变量</span><br><span class="line"><span class="type">pthread_cond_t</span> cond </span><br><span class="line">    </span><br><span class="line">初始化条件变量：</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="number">1.</span>pthread_cond_init(&amp;cond,<span class="literal">NULL</span>);动态初始化</span><br><span class="line"><span class="number">2.</span><span class="type">pthread_cond_t</span> cond=PTHREAD_COND_INITIALIZER;静态初始化   </span><br><span class="line">        </span><br><span class="line">pthread_cond_signal()：唤醒阻塞在条件变量上的 (至少)一个线程 </span><br><span class="line">pthread_con_broadcast()：唤醒阻塞在条件变量上的 所有线程        </span><br></pre></td></tr></table></figure><h5 id="pthread-cond-init函数"><a href="#pthread-cond-init函数" class="headerlink" title="pthread_cond_init函数"></a>pthread_cond_init函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    初始化一个条件变量</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针。</span><br><span class="line">    attr：条件变量属性，通常为默认值，传<span class="literal">NULL</span>即可</span><br><span class="line">        也可以使用静态初始化的方法，初始化条件变量：</span><br><span class="line">        <span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure><h5 id="pthread-cond-destroy函数"><a href="#pthread-cond-destroy函数" class="headerlink" title="pthread_cond_destroy函数"></a>pthread_cond_destroy函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    销毁一个条件变量</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure><h5 id="pthread-cond-wait函数"><a href="#pthread-cond-wait函数" class="headerlink" title="pthread_cond_wait函数"></a>pthread_cond_wait函数</h5><p><img src="C:\Users\27458\AppData\Roaming\Typora\typora-user-images\image-20231105135708680.png" alt="image-20231105135708680"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">    <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    阻塞等待一个条件变量</span><br><span class="line">    a) 阻塞等待条件变量cond（参<span class="number">1</span>）满足</span><br><span class="line">    b) 释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            a) b) 两步为一个原子操作。</span><br><span class="line">    c) 当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex);</span><br><span class="line">​</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">    mutex：互斥锁</span><br><span class="line">​</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">    <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span></span></span><br><span class="line"><span class="params">                           .*<span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line">功能：</span><br><span class="line">    限时等待一个条件变量</span><br><span class="line">​</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">    mutex：互斥锁</span><br><span class="line">    abstime：绝对时间</span><br><span class="line">​</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;      <span class="comment">/* seconds */</span> <span class="comment">// 秒</span></span><br><span class="line">    <span class="type">long</span>   tv_nsec; <span class="comment">/* nanosecondes*/</span> <span class="comment">// 纳秒</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="type">time_t</span> cur = time(<span class="literal">NULL</span>);        <span class="comment">//获取当前时间。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span>;</span>              <span class="comment">//定义timespec 结构体变量t</span></span><br><span class="line">t.tv_sec = cur + <span class="number">1</span>;             <span class="comment">// 定时1秒</span></span><br><span class="line">pthread_cond_timedwait(&amp;cond, &amp;t);</span><br></pre></td></tr></table></figure><h5 id="pthread-cond-signal函数"><a href="#pthread-cond-signal函数" class="headerlink" title="pthread_cond_signal函数"></a>pthread_cond_signal函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    唤醒至少一个阻塞在条件变量上的线程</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    唤醒全部阻塞在条件变量上的线程</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul><li>应用于线程，进程间同步。</li><li>相当于 初始化值为 N 的互斥量。N值，表示可以同时访问共享数据区的线程数。</li></ul><h5 id="主要应用函数-2"><a href="#主要应用函数-2" class="headerlink" title="主要应用函数"></a>主要应用函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sem_init函数</span><br><span class="line">sem_destroy函数</span><br><span class="line">sem_wait函数</span><br><span class="line">sem_trywait函数</span><br><span class="line">sem_timewait函数</span><br><span class="line">sem_post函数 </span><br><span class="line">以上<span class="number">6</span>个函数的返回值都是：成功返回<span class="number">0</span>，失败返回<span class="number">-1</span>，同时设置errno。</span><br><span class="line">    <span class="type">sem_t</span>类型，本质仍是结构体。但应用期间可简单看作为整数，忽略实现细节(类似于使用文件描述符)。</span><br><span class="line">    <span class="type">sem_t</span> sem：规定信号量sem不能&lt;<span class="number">0</span>。  头文件&lt;semaphore.h&gt;</span><br></pre></td></tr></table></figure><h5 id="sem-init函数"><a href="#sem-init函数" class="headerlink" title="sem_init函数"></a>sem_init函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">功能：</span><br><span class="line">    创建一个信号量并初始化它的值。一个无名信号量在被使用前必须先初始化。</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量的地址。</span><br><span class="line">    pshared：等于 <span class="number">0</span>，信号量在线程间共享（常用）；不等于<span class="number">0</span>，信号量在进程间共享。</span><br><span class="line">    value：信号量的初始值。(指定同时访问的线程数)</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="sem-destroy函数"><a href="#sem-destroy函数" class="headerlink" title="sem_destroy函数"></a>sem_destroy函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">功能：</span><br><span class="line">    删除 sem 标识的信号量。</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="信号量P操作-减1"><a href="#信号量P操作-减1" class="headerlink" title="信号量P操作(减1)"></a>信号量P操作(减1)</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将信号量的值减 <span class="number">1</span>。操作前，先检查信号量（sem）的值是否为 <span class="number">0</span>，若信号量为 <span class="number">0</span>，此函数会阻塞，直到信号量大于 <span class="number">0</span> 时才进行减 <span class="number">1</span> 操作。</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量的地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败： - <span class="number">1</span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">   以非阻塞的方式来对信号量进行减 <span class="number">1</span> 操作。</span><br><span class="line">   若操作前，信号量的值等于 <span class="number">0</span>，则对信号量的操作失败，函数立即返回。</span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line">   限时尝试将信号量的值减 <span class="number">1</span></span><br><span class="line">   abs_timeout：绝对时间</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;      <span class="comment">/* seconds */</span> <span class="comment">// 秒</span></span><br><span class="line">    <span class="type">long</span>   tv_nsec; <span class="comment">/* nanosecondes*/</span> <span class="comment">// 纳秒</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="type">time_t</span> cur = time(<span class="literal">NULL</span>);        <span class="comment">//获取当前时间。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span>;</span>              <span class="comment">//定义timespec 结构体变量t</span></span><br><span class="line">t.tv_sec = cur + <span class="number">1</span>;             <span class="comment">// 定时1秒</span></span><br><span class="line">sem_timedwait(&amp;cond, &amp;t);</span><br></pre></td></tr></table></figure><h5 id="信号量V操作-加1"><a href="#信号量V操作-加1" class="headerlink" title="信号量V操作(加1)"></a>信号量V操作(加1)</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将信号量的值加 <span class="number">1</span> 并发出信号唤醒等待线程（sem_wait()）。</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量的地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="Linux随记"><a href="#Linux随记" class="headerlink" title="Linux随记"></a>Linux随记</h2><h3 id="关于僵尸进程和孤儿进程"><a href="#关于僵尸进程和孤儿进程" class="headerlink" title="关于僵尸进程和孤儿进程"></a>关于僵尸进程和孤儿进程</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为<span class="number">1</span>)所收养，并由init进程对它们完成状态收集工作。</span><br><span class="line">   僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有使用wait或waitpid获取子进程的状态信息，那么子进程的进程描述仍然保存在系统中。这种进程称之为僵尸进程。</span><br><span class="line">如何处理：</span><br><span class="line">       孤儿进程将由init接管，成为init的子进程，然后回收资源。</span><br><span class="line">       僵尸进程的危害主要是占用进程描述符。在出现大量僵尸进程的时候，系统会杀死产生僵尸进程的父进程(因为僵尸进程的产生主要是因为父进程出错，没有获取子进程的状态)。在杀死父进程后，僵尸进程就会全部变成孤儿进程，由init接管，回收资源</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QT</title>
      <link href="/2023/09/15/QT/"/>
      <url>/2023/09/15/QT/</url>
      
        <content type="html"><![CDATA[<h1 id="QT"><a href="#QT" class="headerlink" title="QT"></a>QT</h1><h2 id="创建第一个QT程序"><a href="#创建第一个QT程序" class="headerlink" title="创建第一个QT程序"></a>创建第一个QT程序</h2><ol><li><p>点击创建项目后，选择项目路径以及给项目起名称</p></li><li><p>名称 - 不能有中文 不能有空格</p></li><li><p>路径 - 不能有中文路径</p></li><li><p>默认创建有窗口类，myWidget，基类有三种选择：QWidget，QMainWindow，QDialog</p></li><li><p>main函数</p><p>QApplication a 应用程序对象，有且仅有一个</p><p>myWidget w 实例化窗口对象</p><p>w.show() 调用show函数，显示窗口</p><p>return a.exec() 让应用程序对象进入消息循环机制中，代码阻塞到当前行</p></li></ol><h3 id="pro文件"><a href="#pro文件" class="headerlink" title=".pro文件"></a>.pro文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QT       += core gui <span class="comment">//QT包含的模块</span></span><br><span class="line"><span class="built_in">greaterThan</span>(QT_MAJOR_VERSION, <span class="number">4</span>): QT += widgets <span class="comment">//大于4版本以上 包含widget模块</span></span><br><span class="line"></span><br><span class="line">TARGET = <span class="number">01</span>_FirstProject <span class="comment">//目标 生成的.exe程序的名称</span></span><br><span class="line">TEMPLATE = app      <span class="comment">//模板 应用程序模板 Application</span></span><br><span class="line"></span><br><span class="line">SOURCES += \         <span class="comment">//源文件</span></span><br><span class="line">    main.cpp \</span><br><span class="line">    mywidget.cpp</span><br><span class="line"></span><br><span class="line">HEADERS += \         <span class="comment">//头文件</span></span><br><span class="line">    mywidget.h</span><br></pre></td></tr></table></figure><h3 id="h文件"><a href="#h文件" class="headerlink" title=".h文件"></a>.h文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYMAINWINDOW_H <span class="comment">//相当于#pragma once防止重复包含</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYMAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span> <span class="comment">//包含头文件 QWidget 窗口类</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myMainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT <span class="comment">//Q_OBJECT宏，允许类中使用信号和槽的机制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">myMainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>); <span class="comment">//构造函数</span></span><br><span class="line">    ~<span class="built_in">myMainWindow</span>();  <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYMAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><h3 id="cpp文件"><a href="#cpp文件" class="headerlink" title=".cpp文件"></a>.cpp文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mymainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span><span class="comment">//包含一个应用程序类的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main程序的入口  argc命令行变量的数量  argv命令行变量的数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a应用程序对象，在QT中，应用程序对象有且仅有一个</span></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//窗口对象 myWidget-&gt;QWidget</span></span><br><span class="line">    myMainWindow w;</span><br><span class="line">    <span class="comment">//窗口对象 默认不会显示，必须调用show方法显示窗口</span></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">//让应用程序对象进入消息循环</span></span><br><span class="line">    <span class="comment">//让代码阻塞在这行</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mymainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名规范</span></span><br><span class="line"><span class="comment">// 类名 首字母大写，单词和单词之间首字母大写</span></span><br><span class="line"><span class="comment">// 函数名 变量名称 首字母小写，单词和单词之间首字母大写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//快捷键</span></span><br><span class="line"><span class="comment">//注释 ctrl + /</span></span><br><span class="line"><span class="comment">//运行 ctrl + r</span></span><br><span class="line"><span class="comment">//编译 ctrl + b</span></span><br><span class="line"><span class="comment">//字体调节 ctrl + 鼠标滚轮</span></span><br><span class="line"><span class="comment">//查找 ctrl + f</span></span><br><span class="line"><span class="comment">//整行移动 ctrl + shift + 上箭头 或 下箭头</span></span><br><span class="line"><span class="comment">//自动对齐 ctrl + i</span></span><br><span class="line"><span class="comment">//同名之间的.h 和 .cpp切换 F4</span></span><br><span class="line"><span class="comment">//帮助文档 1，F1 2，左侧按钮 3，E:\QT\5.15.2\mingw81_32\bin</span></span><br><span class="line"></span><br><span class="line">myMainWindow::<span class="built_in">myMainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myMainWindow::~<span class="built_in">myMainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="QPushButton创建"><a href="#QPushButton创建" class="headerlink" title="QPushButton创建"></a>QPushButton创建</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable:4819)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mywidget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QPushButton&gt;</span> <span class="comment">//按钮控件的头文件</span></span></span><br><span class="line"></span><br><span class="line">myWidget::<span class="built_in">myWidget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个按钮</span></span><br><span class="line">    QPushButton *btn=<span class="keyword">new</span> QPushButton;</span><br><span class="line">    <span class="comment">//btn-&gt;show(); //show以顶层方式弹出窗口控件</span></span><br><span class="line">    <span class="comment">//让btn对象 依赖在 myWidget窗口中</span></span><br><span class="line">    btn-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//显示文本</span></span><br><span class="line">    btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;first button&quot;</span>);</span><br><span class="line">    <span class="comment">//创建第二个按钮 按照控件的大小创建窗口</span></span><br><span class="line">    QPushButton * btn2=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;second button&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//移动btn2按钮</span></span><br><span class="line">    btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//重置窗口大小</span></span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">600</span>,<span class="number">400</span>);</span><br><span class="line">    <span class="comment">//设置固定窗口大小</span></span><br><span class="line">    <span class="built_in">setFixedSize</span>(<span class="number">600</span>,<span class="number">400</span>);</span><br><span class="line">    <span class="comment">//设置窗口标题</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;first window&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myWidget::~<span class="built_in">myWidget</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象树"><a href="#对象树" class="headerlink" title="对象树"></a>对象树</h2><ol><li>当创建的对象在堆区时候，如果指定的父亲是QObject派生下来的类或者QObject子类派生下来的类，可以不用管理释放的操作，将对象会放入到对象树中。</li><li>一定程度上简化了内存回收机制</li></ol><h2 id="窗口坐标系"><a href="#窗口坐标系" class="headerlink" title="窗口坐标系"></a>窗口坐标系</h2><ul><li>以左上角为原点(0,0)，X向右增加，Y向下增加</li><li>对于嵌套窗口，其坐标是相对于父窗口来说的</li></ul><h2 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h2><h3 id="点击按钮关闭窗口"><a href="#点击按钮关闭窗口" class="headerlink" title="点击按钮关闭窗口"></a>点击按钮关闭窗口</h3><p>人     — 摩擦摩擦 —       神灯   — 出神灯</p><p>按钮 —     点击   —         窗口 — 关闭窗口</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(信号的发送者，发送的具体信号，信号的接受者，信号的处理(槽))</span><br><span class="line">信号槽的优点：松散耦合，信号发送端和接受端本身是没有关联的，通过connect连接，将两端耦合在一起    </span><br></pre></td></tr></table></figure><h3 id="自定义信号和槽"><a href="#自定义信号和槽" class="headerlink" title="自定义信号和槽"></a>自定义信号和槽</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GirlFriend</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">//自定义信号 写到signals下</span></span><br><span class="line">    <span class="comment">//返回值是void，只需要声明，不需要定义</span></span><br><span class="line">    <span class="comment">//可以有参数，可以重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hungry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="comment">//早期QT版本 必须写在public slots，高级版本写在public或者全局下</span></span><br><span class="line">    <span class="comment">//返回值 void 需要声明 也需要实现</span></span><br><span class="line">    <span class="comment">//可以有参数，可以发生重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">treat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个女朋友对象</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;gf=<span class="keyword">new</span> <span class="built_in">GirlFriend</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//创建一个我的对象</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;mc=<span class="keyword">new</span> <span class="built_in">MyClass</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//女朋友饿了，我请客的链接</span></span><br><span class="line">    <span class="built_in">connect</span>(gf,&amp;GirlFriend::hungry,mc,&amp;MyClass::treat);</span><br><span class="line">    <span class="comment">//调用下课函数</span></span><br><span class="line">    <span class="built_in">classIsOver</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::classIsOver</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//下课后，调用后，触发女朋友饿了的信号</span></span><br><span class="line">    <span class="comment">//触发自定义信号，emit 自定义信号</span></span><br><span class="line">    emit gf-&gt;<span class="built_in">hungry</span>();</span><br></pre></td></tr></table></figure><h3 id="自定义信号和槽发生重载"><a href="#自定义信号和槽发生重载" class="headerlink" title="自定义信号和槽发生重载"></a>自定义信号和槽发生重载</h3><ul><li>需要利用函数指针，明确指向函数的地址(void (GirlFriend::*gfSignal)(QString)&#x3D;&amp;GirlFriend::hungry);</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连接带参数的信号和槽</span></span><br><span class="line"><span class="comment">//指针 -&gt; 地址</span></span><br><span class="line"><span class="comment">//函数指针 -&gt; 函数地址</span></span><br><span class="line">    <span class="built_in">void</span>(GirlFriend::*girlfriendSignal)(QString)=&amp;GirlFriend::hungry;</span><br><span class="line">    <span class="built_in">void</span> (MyClass::*myclassSignal)(QString)=&amp;MyClass::treat;</span><br><span class="line">    <span class="built_in">connect</span>(gf,girlfriendSignal,mc,myclassSignal);</span><br><span class="line">    <span class="built_in">classIsOver</span>();</span><br><span class="line"></span><br><span class="line">    emit gf-&gt;<span class="built_in">hungry</span>(<span class="string">&quot;kongbao chicken&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>QString 转成 char *</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//QString -&gt; char * 先转成QByteArray (.toUtf8()) 再转成char *(.data())</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;请女朋友吃饭，女朋友要吃:&quot;</span>&lt;&lt;foodName.<span class="built_in">toUtf8</span>().<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure><h3 id="信号连接信号"><a href="#信号连接信号" class="headerlink" title="信号连接信号"></a>信号连接信号</h3><ul><li>信号可以连接信号</li><li>断开信号：disconnect</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//点击一个下课的按钮，再触发下课</span></span><br><span class="line">QPushButton *btn=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;下课&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">resize</span>(<span class="number">600</span>,<span class="number">400</span>);</span><br><span class="line"><span class="comment">//connect(btn,&amp;QPushButton::clicked,this,&amp;Widget::classIsOver);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//无参信号和槽连接</span></span><br><span class="line"><span class="built_in">void</span>(GirlFriend::*girlfriendSignal2)(<span class="type">void</span>)=&amp;GirlFriend::hungry;</span><br><span class="line"><span class="built_in">void</span> (MyClass::*myclassSignal2)(<span class="type">void</span>)=&amp;MyClass::treat;</span><br><span class="line"><span class="built_in">connect</span>(gf,girlfriendSignal2,mc,myclassSignal2);</span><br><span class="line"><span class="comment">//信号连接信号</span></span><br><span class="line"><span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,gf,girlfriendSignal2);</span><br><span class="line"><span class="comment">//断开信号</span></span><br><span class="line"><span class="built_in">disconnect</span>(gf,girlfriendSignal2,mc,myclassSignal2);</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><ul><li><p>用于定义并创建匿名的函数对象，以简化编程工作</p></li><li><p>[函数对象参数] (操作符重载函数参数) {函数体}</p></li></ul><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">一，函数对象参数：</span><br><span class="line">[]，标识一个Lambda的开始，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数有以下形式：</span><br><span class="line"><span class="number">1</span>，空。没有使用任何函数对象参数。</span><br><span class="line"><span class="number">2</span>，=。按值传递所有局部变量。</span><br><span class="line"><span class="number">3</span>，&amp;。按引用传递所有局部变量。</span><br><span class="line"><span class="number">4</span>，<span class="keyword">this</span>。函数体内可以使用Lambda所在类中的成员变量。类似于=。</span><br><span class="line"><span class="number">5</span>，a。将a按值传递。按值传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是<span class="type">const</span>的。要修改传递进来的a的拷贝，可以添加<span class="keyword">mutable</span>修饰符。</span><br><span class="line">QPushButton *btn2=<span class="keyword">new</span> QPushButton;</span><br><span class="line">[btn]()&#123;</span><br><span class="line">  btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">  btn2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;bbbb&quot;</span>); <span class="comment">//btn2看不到</span></span><br><span class="line">&#125;();</span><br><span class="line"><span class="number">6</span>，&amp;a。将a按引用进行传递。</span><br><span class="line"><span class="number">7</span>，a,&amp;b。将a按值传递，b按引用进行传递。</span><br><span class="line"><span class="number">8</span>，=,&amp;a,&amp;b。除a和b按引用进行传递外，其他参数都按值进行传递。</span><br><span class="line"><span class="number">9</span>，&amp;,a,b。除a和b按值进行传递外，其他参数都按引用进行传递。</span><br><span class="line">二，操作符重载函数参数：</span><br><span class="line">标识重载的()操作符的参数，可以省略。参数可以通过按值(如：(a,b))和按引用(如：(&amp;a,&amp;b))两种方式进行传递。</span><br><span class="line">三，可修改标识符：</span><br><span class="line"><span class="keyword">mutable</span>声明，可以省略。按值传递函数对象时，加上<span class="keyword">mutable</span>修饰符后，可以修改按值传递进来的拷贝(能修改拷贝，不是值本身)</span><br><span class="line">四，函数返回值：</span><br><span class="line">-&gt;返回值类型，标识函数返回值的类型，当返回值为<span class="type">void</span>或者函数体中只有一处<span class="keyword">return</span>的地方(此时编译器可以自动推断出返回值类型)时，这部分可以省略。</span><br><span class="line">    <span class="type">int</span> ret=[]()-&gt;<span class="type">int</span>&#123;<span class="keyword">return</span> <span class="number">1000</span>;&#125;();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;ret=&quot;</span>&lt;&lt;ret;</span><br><span class="line">五，函数体：</span><br><span class="line">&#123;&#125;，标识函数的实现，这部分不能省略，但函数体可以为空。    </span><br><span class="line">  </span><br></pre></td></tr></table></figure></blockquote><h2 id="QMainWindow"><a href="#QMainWindow" class="headerlink" title="QMainWindow"></a>QMainWindow</h2><ul><li>QMainWindow是一个为用户提供主窗口程序的类，包含一个菜单栏(menu bar)，多个工具栏(tool bars)，多个锚接部件(dock widgets)，一个状态栏(status bar)及一个中心部件(central widget)，是许多应用程序的基础，如文本编辑器，图片编辑器。</li></ul><h3 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h3><ol><li>将图片文件拷贝到项目位置下</li><li>右键项目-&gt;添加新文件-&gt;Qt-&gt;Qt recourse file -&gt;给文件起名</li><li>res 生成 res.qrc</li><li>open in editor 编辑资源</li><li>添加前缀 添加文件</li><li>使用 “：+前缀名 + 文件名”</li></ol><h3 id="界面布局"><a href="#界面布局" class="headerlink" title="界面布局"></a>界面布局</h3><ol><li>实现登录窗口</li><li>利用布局方式，给窗口进行美化</li><li>选取widget进行布局，水平布局，垂直布局，栅格布局、</li><li>给用户名，密码，登录，退出按钮进行布局</li><li>默认窗口和控件之间有间隙，可以调整layoutLeftMargin</li><li>利用弹簧进行布局</li></ol><h3 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h3><h4 id="按钮组"><a href="#按钮组" class="headerlink" title="按钮组"></a>按钮组</h4><ol><li>QPushButton 常用按钮</li><li>QToolButton 工具按钮 用于显示图片，如图想显示文字，修改风格；toolButtonStyle，突起风格：autoRaise</li><li>radioButton 单选按钮，设置默认 ui-&gt;rBtnMan-&gt;setChecked(ture);</li><li>checkbox 多选按钮，监听状态，2，选中 1，半选  0，未选中</li></ol><h4 id="QListWidget列表容器"><a href="#QListWidget列表容器" class="headerlink" title="QListWidget列表容器"></a>QListWidget列表容器</h4><ol><li>QListWidgetItem *item 一行内容</li><li>ui-&gt;listWidget-&gt;addItem(item)</li><li>设置居中方式 item-&gt;setTextAlignment(Qt::AlignHCenter)</li><li>可以利用addItems 一次性添加整个诗内容</li></ol><h4 id="QTreeWidget数控件"><a href="#QTreeWidget数控件" class="headerlink" title="QTreeWidget数控件"></a>QTreeWidget数控件</h4><ol><li>设置头：ui-&gt;treeWidget-&gt;setHeaderLabels(QStringList()&lt;&lt;”英雄”&lt;&lt;”英雄介绍”)</li><li>创建根节点：QTreeWidgetItem *liItem&#x3D;new QTreeWidgetItem(QStringList()&lt;&lt;”力量”)</li><li>添加根节点到树控件上：ui-&gt;treeWidget-&gt;addTopLevelItem(liItem)</li><li>添加子节点：Item-&gt;addChild(l1)</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//treeWidget树控件使用</span></span><br><span class="line">    <span class="comment">//设置水平头</span></span><br><span class="line">    ui-&gt;treeWidget-&gt;<span class="built_in">setHeaderLabels</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;英雄&quot;</span>&lt;&lt;<span class="string">&quot;英雄介绍&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QTreeWidgetItem *liItem=<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;力量&quot;</span>);</span><br><span class="line">    QTreeWidgetItem *minItem=<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;敏捷&quot;</span>);</span><br><span class="line">    QTreeWidgetItem *zhiItem=<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;智力&quot;</span>);</span><br><span class="line">    <span class="comment">//加载顶层的节点</span></span><br><span class="line">    ui-&gt;treeWidget-&gt;<span class="built_in">addTopLevelItem</span>(liItem);</span><br><span class="line">    ui-&gt;treeWidget-&gt;<span class="built_in">addTopLevelItem</span>(minItem);</span><br><span class="line">    ui-&gt;treeWidget-&gt;<span class="built_in">addTopLevelItem</span>(zhiItem);</span><br><span class="line">    <span class="comment">//追加子节点</span></span><br><span class="line">    QStringList heroL1;</span><br><span class="line">    heroL1&lt;&lt;<span class="string">&quot;刚被猪 &quot;</span>&lt;&lt;<span class="string">&quot;前排坦克，能在吸收伤害的同时造成可观的范围输出 &quot;</span>;</span><br><span class="line">    QTreeWidgetItem *l1=<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(heroL1);</span><br><span class="line">    liItem-&gt;<span class="built_in">addChild</span>(l1);</span><br><span class="line">    QStringList heroL2;</span><br><span class="line">    heroL2&lt;&lt;<span class="string">&quot;船长 &quot;</span>&lt;&lt;<span class="string">&quot;前排坦克，能肉能输出能控场的全能英雄 &quot;</span>;</span><br><span class="line">    QTreeWidgetItem *l2=<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(heroL2);</span><br><span class="line">    liItem-&gt;<span class="built_in">addChild</span>(l2);</span><br><span class="line"></span><br><span class="line">    QStringList herom1;</span><br><span class="line">    herom1&lt;&lt;<span class="string">&quot;月骑 &quot;</span>&lt;&lt;<span class="string">&quot;中排物理输出，可以使用分裂利刃攻击多个目标 &quot;</span>;</span><br><span class="line">    QTreeWidgetItem *m1=<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(herom1);</span><br><span class="line">    minItem-&gt;<span class="built_in">addChild</span>(m1);</span><br><span class="line">    QStringList herom2;</span><br><span class="line">    herom2&lt;&lt;<span class="string">&quot;小鱼人 &quot;</span>&lt;&lt;<span class="string">&quot;前排战士，擅长偷取敌人的属性来增强自身战力 &quot;</span>;</span><br><span class="line">    QTreeWidgetItem *m2=<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(herom2);</span><br><span class="line">    minItem-&gt;<span class="built_in">addChild</span>(m2);</span><br><span class="line"></span><br><span class="line">    QStringList heroz1;</span><br><span class="line">    heroz1&lt;&lt;<span class="string">&quot;死灵法师 &quot;</span>&lt;&lt;<span class="string">&quot;前排法师坦克，魔法抗性较高，拥有治疗技能 &quot;</span>;</span><br><span class="line">    QTreeWidgetItem *z1=<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(heroz1);</span><br><span class="line">    zhiItem-&gt;<span class="built_in">addChild</span>(z1);</span><br><span class="line">    QStringList heroz2;</span><br><span class="line">    heroz2&lt;&lt;<span class="string">&quot;巫医 &quot;</span>&lt;&lt;<span class="string">&quot;后排辅助法师，可以使用奇特的巫术诅咒敌人与治疗队友 &quot;</span>;</span><br><span class="line">    QTreeWidgetItem *z2=<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(heroz2);</span><br><span class="line">    zhiItem-&gt;<span class="built_in">addChild</span>(z2);</span><br></pre></td></tr></table></figure><h4 id="QTableWidget表格控件"><a href="#QTableWidget表格控件" class="headerlink" title="QTableWidget表格控件"></a>QTableWidget表格控件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TableWidget控件</span></span><br><span class="line">    ui-&gt;tableWidget-&gt;<span class="built_in">setColumnCount</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//设置水平表头</span></span><br><span class="line">    ui-&gt;tableWidget-&gt;<span class="built_in">setHorizontalHeaderLabels</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;姓名&quot;</span>&lt;&lt;<span class="string">&quot;性别&quot;</span>&lt;&lt;<span class="string">&quot;年龄&quot;</span>);</span><br><span class="line">    <span class="comment">//设置行数</span></span><br><span class="line">    ui-&gt;tableWidget-&gt;<span class="built_in">setRowCount</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//设置正文</span></span><br><span class="line">    QStringList nameList;</span><br><span class="line">    nameList&lt;&lt;<span class="string">&quot; 亚瑟 &quot;</span>&lt;&lt;<span class="string">&quot; 安琪拉 &quot;</span>&lt;&lt;<span class="string">&quot; 李白 &quot;</span>&lt;&lt;<span class="string">&quot; 王昭君 &quot;</span>&lt;&lt;<span class="string">&quot; 孙悟空 &quot;</span>;</span><br><span class="line"></span><br><span class="line">    QList&lt;QString&gt; sexList;</span><br><span class="line">    sexList&lt;&lt;<span class="string">&quot; 男 &quot;</span>&lt;&lt;<span class="string">&quot; 女 &quot;</span>&lt;&lt;<span class="string">&quot; 男 &quot;</span>&lt;&lt;<span class="string">&quot; 女 &quot;</span>&lt;&lt;<span class="string">&quot; 中立 &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> col=<span class="number">0</span>;</span><br><span class="line">        ui-&gt;tableWidget-&gt;<span class="built_in">setItem</span>(i,col++,<span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(nameList[i]));</span><br><span class="line">        ui-&gt;tableWidget-&gt;<span class="built_in">setItem</span>(i,col++,<span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(sexList[i]));</span><br><span class="line">        <span class="comment">//int 转 QString</span></span><br><span class="line">        ui-&gt;tableWidget-&gt;<span class="built_in">setItem</span>(i,col++,<span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(QString::<span class="built_in">number</span>(i+<span class="number">18</span>)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="其他控件"><a href="#其他控件" class="headerlink" title="其他控件"></a>其他控件</h4><ul><li>stackedWidget  栈控件：</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置默认定位 scrollArea</span></span><br><span class="line">    ui-&gt;stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//scrollArea按钮</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;SA_Btn,&amp;QPushButton::clicked,[=]()&#123;</span><br><span class="line">        ui-&gt;stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;TB_Btn,&amp;QPushButton::clicked,[=]()&#123;</span><br><span class="line">        ui-&gt;stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;TW_Btn,&amp;QPushButton::clicked,[=]()&#123;</span><br><span class="line">        ui-&gt;stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ul><li>comboBox 下拉框：</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ui-&gt;comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;宝马 &quot;</span>);</span><br><span class="line">    ui-&gt;comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;奔驰 &quot;</span>);</span><br><span class="line">    ui-&gt;comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;拖拉机 &quot;</span>);</span><br><span class="line">    <span class="comment">//点击按钮 选中拖拉机选项</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;CB_Btn,&amp;QPushButton::clicked,[=]()&#123;</span><br><span class="line">        <span class="comment">//ui-&gt;comboBox-&gt;setCurrentIndex(2);</span></span><br><span class="line">        ui-&gt;comboBox-&gt;<span class="built_in">setCurrentText</span>(<span class="string">&quot;拖拉机 &quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>QLabel显示图片</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ui-&gt;lbl_image-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/Saved Pictures/ws_2670752772_thumb.jpg&quot;</span>));</span><br><span class="line">如图片显示不全：选中scaledContents自适应</span><br></pre></td></tr></table></figure><ul><li>QLabel显示动图 gif图片</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMovie *movie=<span class="keyword">new</span> <span class="built_in">QMovie</span>(<span class="string">&quot;:/Saved Pictures/c5fc04a186ac48f5a05bbaebb31727ae.gif&quot;</span>);</span><br><span class="line">    ui-&gt;lbl_movie-&gt;<span class="built_in">setMovie</span>(movie);</span><br><span class="line">    <span class="comment">//播放动图</span></span><br><span class="line">    movie-&gt;<span class="built_in">start</span>();</span><br></pre></td></tr></table></figure><h2 id="Qt中的事件"><a href="#Qt中的事件" class="headerlink" title="Qt中的事件"></a>Qt中的事件</h2><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><ol><li>鼠标进入事件：enterEvent</li><li>鼠标离开事件：leaveEvent</li><li>鼠标按下：mousePressEvent(QMouseEvent *ev)</li><li>鼠标释放：mouseReleaseEvent</li><li>鼠标移动：mouseMoveEvent</li><li>ev-&gt;x() x坐标  ev-.y() y坐标</li><li>ev-&gt;button() 可以判断所有按键 Qt::LeftButton Qt::RightButton</li><li>ev-&gt;buttons() 判断组合按键 判断move时候的左右键 结合&amp;操作符</li><li>格式化字符串 QString(“%1 %2”).arg(111).arg(222)</li></ol><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重写定时器的事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">timerEvent</span><span class="params">(QTimerEvent *e)</span></span>;</span><br><span class="line">    <span class="type">int</span> id1; <span class="comment">//定时器1的唯一标识</span></span><br><span class="line">    <span class="type">int</span> id2; <span class="comment">//定时器2的唯一标识</span></span><br><span class="line"></span><br><span class="line">ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//启动定时器</span></span><br><span class="line">    id1=<span class="built_in">startTimer</span>(<span class="number">1000</span>); <span class="comment">//参数1 间隔 单位 毫秒</span></span><br><span class="line">    id2=<span class="built_in">startTimer</span>(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::timerEvent</span><span class="params">(QTimerEvent *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e-&gt;<span class="built_in">timerId</span>()==id1)&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> number=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//label_2 每隔1秒+1</span></span><br><span class="line">    ui-&gt;label_2-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(number++));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(e-&gt;<span class="built_in">timerId</span>()==id2)&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> number2=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//label_3 每隔2秒+1</span></span><br><span class="line">    ui-&gt;label_3-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(number2++));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定时器第二种方式</span></span><br><span class="line">    QTimer *timer=<span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//启动定时器</span></span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">500</span>);</span><br><span class="line">    <span class="built_in">connect</span>(timer,&amp;QTimer::timeout,[=]()&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> number3=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//label_4 每隔0.5秒+1</span></span><br><span class="line">        ui-&gt;label_4-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(number3++));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点击暂停按钮，实现停止定时器</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;btn1,&amp;QPushButton::clicked,[=]()&#123;</span><br><span class="line">        timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//点击启动按钮，实现启动定时器</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;btn2,&amp;QPushButton::clicked,[=]()&#123;</span><br><span class="line">        timer-&gt;<span class="built_in">start</span>(<span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="event事件分发器"><a href="#event事件分发器" class="headerlink" title="event事件分发器"></a>event事件分发器</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307221057680.png" alt="Snipaste_2023-07-22_10-52-01"></p><ol><li>用途：用于事件的分发</li><li>也可以做拦截操作，不建议</li><li>bool event(QEvent *e);</li><li>返回值 如果是true 代表用户处理这个事件，不向下分发了</li><li>e-&gt;type&#x3D;&#x3D;鼠标按下</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myLabel::event</span><span class="params">(QEvent *e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果是鼠标按下。在event事件分发中做拦截操作</span></span><br><span class="line">    <span class="keyword">if</span>(e-&gt;<span class="built_in">type</span>()==QEvent::MouseButtonPress)&#123;</span><br><span class="line">        QMouseEvent *ev=<span class="built_in">static_cast</span>&lt;QMouseEvent *&gt;(e);</span><br><span class="line">        QString str=<span class="built_in">QString</span>(<span class="string">&quot;Event函数中，鼠标按下了 x=%1 y=%2 globalX=%3 globalY=%4&quot;</span>).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">y</span>()).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">globalX</span>()).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">globalY</span>());</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;str;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//true代表用户自己处理这个事件，不向下分发</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他事件 交给父类处理 默认处理</span></span><br><span class="line">    <span class="keyword">return</span> QLabel::<span class="built_in">event</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件过滤器"><a href="#事件过滤器" class="headerlink" title="事件过滤器"></a>事件过滤器</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307221124552.png" alt="Snipaste_2023-07-22_11-24-25"></p><ol><li>在程序将时间分发到事件分发器前，可以利用过滤器做拦截</li><li>步骤：<ol><li>给控件安装事件过滤器</li><li>重写eventFilter函数(obj,ev)  <strong>&#x2F;&#x2F;obj用来判断控件，ev用来判断事件</strong></li></ol></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给label 安装事件过滤器</span></span><br><span class="line">    <span class="comment">//步骤1  安装事件过滤器</span></span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//步骤2 重写eventfilter事件</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Widget::eventFilter</span><span class="params">(QObject *obj,QEvent *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj==ui-&gt;label)&#123;</span><br><span class="line">        <span class="comment">//如果是鼠标按下。在过滤器中做拦截操作</span></span><br><span class="line">        <span class="keyword">if</span>(e-&gt;<span class="built_in">type</span>()==QEvent::MouseButtonPress)&#123;</span><br><span class="line">            QMouseEvent *ev=<span class="built_in">static_cast</span>&lt;QMouseEvent *&gt;(e);</span><br><span class="line">            QString str=<span class="built_in">QString</span>(<span class="string">&quot;过滤器中，鼠标按下了 x=%1 y=%2 globalX=%3 globalY=%4&quot;</span>).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">y</span>()).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">globalX</span>()).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">globalY</span>());</span><br><span class="line">                          <span class="built_in">qDebug</span>()&lt;&lt;str;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//true代表用户自己处理这个事件，不向下分发</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他事件 交给父类处理 默认处理</span></span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">eventFilter</span>(obj,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QPainter绘图"><a href="#QPainter绘图" class="headerlink" title="QPainter绘图"></a>QPainter绘图</h3><ol><li>绘图事件 void paintEvent()</li><li>声明一个画家对象 QPainter painter(this) this指定绘图设备</li><li>画线 画圆 画矩形 画文字</li><li>设置画笔 QPen  设置画笔宽度，风格</li><li>设置画刷 QBrush 设置画刷风格</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent*)</span></span>&#123;</span><br><span class="line">    <span class="comment">//实例化画家对象 this指定的是绘图设备</span></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置画笔</span></span><br><span class="line">    <span class="function">QPen <span class="title">pen</span><span class="params">(QColor(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="comment">//设置画笔宽度</span></span><br><span class="line">    pen.<span class="built_in">setWidth</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//设置画笔风格</span></span><br><span class="line">    pen.<span class="built_in">setStyle</span>(Qt::DotLine);</span><br><span class="line">    <span class="comment">//让画家 使用这个画笔</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置画刷</span></span><br><span class="line">    <span class="function">QBrush <span class="title">brush</span><span class="params">(Qt::cyan)</span></span>;</span><br><span class="line">    <span class="comment">//设置画刷风格</span></span><br><span class="line">    brush.<span class="built_in">setStyle</span>(Qt::Dense7Pattern);</span><br><span class="line">    <span class="comment">//让画家使用画刷</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画线</span></span><br><span class="line">    painter.<span class="built_in">drawLine</span>(<span class="built_in">QPoint</span>(<span class="number">0</span>,<span class="number">0</span>),<span class="built_in">QPoint</span>(<span class="number">100</span>,<span class="number">100</span>));</span><br><span class="line">    <span class="comment">//画圆</span></span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPoint</span>(<span class="number">100</span>,<span class="number">100</span>),<span class="number">50</span>,<span class="number">50</span>); <span class="comment">//Ellipse 椭圆</span></span><br><span class="line">    <span class="comment">//画矩形</span></span><br><span class="line">    <span class="comment">//painter.drawRect(QRect(QPoint(50,50),QPoint(100,100)));</span></span><br><span class="line">    <span class="comment">//painter.drawRect(QRect(QPoint(100,100),QSize(100,50)));</span></span><br><span class="line">    painter.<span class="built_in">drawRect</span>(<span class="built_in">QRect</span>(<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>));</span><br><span class="line">    <span class="comment">//画文字</span></span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="built_in">QRect</span>(<span class="number">10</span>,<span class="number">200</span>,<span class="number">150</span>,<span class="number">50</span>),<span class="string">&quot;好好学习，天天向上 &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="QPainter高级设置"><a href="#QPainter高级设置" class="headerlink" title="QPainter高级设置"></a>QPainter高级设置</h4><ol><li>抗锯齿 效率低：painter.setRenderHint()</li><li>对画家进行移动：painter.translate(100,0);</li><li>保存状态：save</li><li>还原状态：restore</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPoint</span>(<span class="number">100</span>,<span class="number">50</span>),<span class="number">50</span>,<span class="number">50</span>);</span><br><span class="line"><span class="comment">//设置抗锯齿能力 效率较低</span></span><br><span class="line">painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);</span><br><span class="line">painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPoint</span>(<span class="number">200</span>,<span class="number">50</span>),<span class="number">50</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//画矩形</span></span><br><span class="line">painter.<span class="built_in">drawRect</span>(<span class="built_in">QRect</span>(<span class="number">20</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">50</span>));</span><br><span class="line"><span class="comment">//移动画家</span></span><br><span class="line">painter.<span class="built_in">translate</span>(<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//保存画家状态</span></span><br><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">painter.<span class="built_in">drawRect</span>(<span class="built_in">QRect</span>(<span class="number">20</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">50</span>));</span><br><span class="line">painter.<span class="built_in">translate</span>(<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//还原画家保存状态</span></span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br><span class="line">painter.<span class="built_in">drawRect</span>(<span class="built_in">QRect</span>(<span class="number">20</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">50</span>));</span><br></pre></td></tr></table></figure><ol start="5"><li>如果想手动调用绘图事件 利用update</li><li>利用画家画图片 painter.drawPixmap(x,y,QPixmap(“路径”))</li></ol><h4 id="绘图设备"><a href="#绘图设备" class="headerlink" title="绘图设备"></a>绘图设备</h4><ul><li><strong>绘图设备是指继承QPainterDevice的子类</strong>。Qt中一共提供了四个这样的类</li></ul><ol><li>QPixmap：专门为图像在屏幕上的显示做了优化</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//QPixmap绘图设备 专门为平台做了显示的优化</span></span><br><span class="line"><span class="function">QPixmap <span class="title">pix</span><span class="params">(<span class="number">300</span>,<span class="number">300</span>)</span></span>;</span><br><span class="line"><span class="comment">//填充颜色</span></span><br><span class="line">pix.<span class="built_in">fill</span>(Qt::white);</span><br><span class="line"><span class="comment">//声明画家</span></span><br><span class="line"><span class="function">QPainter <span class="title">painter</span><span class="params">(&amp;pix)</span></span>;</span><br><span class="line">painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(Qt::green));</span><br><span class="line">painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPoint</span>(<span class="number">150</span>,<span class="number">150</span>),<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//保存</span></span><br><span class="line">pix.<span class="built_in">save</span>(<span class="string">&quot;E:/QT/QT_Project/pix.png&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>QBitmap：是QPixmap的一个子类，它的色深限定为1(只显示黑白)，可以使用QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap</p></li><li><p>QImage：专门为图像的像素级访问做了优化</p></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//QImage绘图设备 可以对像素进行访问</span></span><br><span class="line">    <span class="function">QImage <span class="title">image</span><span class="params">(<span class="number">300</span>,<span class="number">300</span>,QImage::Format_RGB32)</span></span>;</span><br><span class="line">    <span class="comment">//声明画家</span></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(&amp;image)</span></span>;</span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(Qt::blue));</span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPoint</span>(<span class="number">150</span>,<span class="number">150</span>),<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//保存</span></span><br><span class="line">    image.<span class="built_in">save</span>(<span class="string">&quot;E:/QT/QT_Project/image.png&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘图事件里</span></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">//利用QImage 对像素进行修改</span></span><br><span class="line">    QImage img;</span><br><span class="line">    img.<span class="built_in">load</span>(<span class="string">&quot;:/Saved Pictures/ws_2994142969_thumb.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//修改像素点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">50</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">50</span>;j&lt;<span class="number">100</span>;j++)&#123;</span><br><span class="line">            QRgb value=<span class="built_in">qRgb</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>);</span><br><span class="line">            img.<span class="built_in">setPixel</span>(i,j,value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    painter.<span class="built_in">drawImage</span>(<span class="number">0</span>,<span class="number">0</span>,img);</span><br></pre></td></tr></table></figure><ol start="4"><li>QPicture：可以记录和重现QPainter的各条命令</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//QPicture 绘图设备 可以记录和重现 绘图指令</span></span><br><span class="line">    QPicture pic;</span><br><span class="line">    QPainter painter;</span><br><span class="line">    painter.<span class="built_in">begin</span>(&amp;pic);<span class="comment">//开始往pic上画</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(Qt::cyan));</span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPoint</span>(<span class="number">150</span>,<span class="number">150</span>),<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    painter.<span class="built_in">end</span>();<span class="comment">//结束画画</span></span><br><span class="line">    <span class="comment">//保存到磁盘</span></span><br><span class="line">    pic.<span class="built_in">save</span>(<span class="string">&quot;E:/QT/QT_Project/picture.wzh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘图事件里</span></span><br><span class="line"><span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">//重现QPicture的绘图指令</span></span><br><span class="line">    QPicture pic;</span><br><span class="line">    pic.<span class="built_in">load</span>(<span class="string">&quot;E:/QT/QT_Project/picture.wzh&quot;</span>);</span><br><span class="line">    painter.<span class="built_in">drawPicture</span>(<span class="number">0</span>,<span class="number">0</span>,pic);</span><br></pre></td></tr></table></figure><h3 id="QFile"><a href="#QFile" class="headerlink" title="QFile"></a>QFile</h3><h4 id="QFile进行读写操作"><a href="#QFile进行读写操作" class="headerlink" title="QFile进行读写操作"></a>QFile进行读写操作</h4><ol><li>QFile file(path 文件路径)</li><li>读</li></ol><ul><li><p>file.open(打开方式)QIODevice::readOnly</p></li><li><p>全部读取 file.readAll()  按行读file.readLine()  atend()判断是否读到文件尾</p></li><li><p>默认支持编码格式  utf-8</p></li><li><p>利用编码格式类 指定格式 QTextCodec</p></li><li><p>QTextCodec *codec&#x3D;QTextCodec::codecForName(“gbk”);</p><p>ui-&gt;textEdit-&gt;setText(codec-&gt;toUnicode(array))</p></li><li><p>文件对象关闭 close</p></li></ul><ol start="3"><li>写</li></ol><ul><li>file.open(QIODevice::writeOnly &#x2F; Append)</li><li>file.write(内容)</li><li>file.close 关闭</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点击选取文件按钮，弹出文件对话框</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton,&amp;QPushButton::clicked,[=]()&#123;</span><br><span class="line">        QString path=QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>,<span class="string">&quot;打开文件&quot;</span>,<span class="string">&quot;C:\\Users\\27458\\Desktop&quot;</span>);</span><br><span class="line">        <span class="comment">//将路径放入到lineEdit中</span></span><br><span class="line">        ui-&gt;lineEdit-&gt;<span class="built_in">setText</span>(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编码格式类</span></span><br><span class="line">        <span class="comment">//QTextCodec *codec=QTextCodec::codecForName(&quot;gbk&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取内容，放入到textEdit中</span></span><br><span class="line">        <span class="comment">//QFile默认支持的格式是 utf-8</span></span><br><span class="line">        QFile <span class="built_in">file</span>(path); <span class="comment">//参数为读取文件的路径</span></span><br><span class="line">        <span class="comment">//设置打开方式</span></span><br><span class="line">        file.<span class="built_in">open</span>(QIODevice::ReadOnly);</span><br><span class="line">        <span class="comment">//QByteArray array=file.readAll();</span></span><br><span class="line">        QByteArray array;</span><br><span class="line">        <span class="keyword">while</span>(!file.<span class="built_in">atEnd</span>())&#123;</span><br><span class="line">            array+=file.<span class="built_in">readLine</span>(); <span class="comment">//按行读</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将读取到的数据 放入textEdit中</span></span><br><span class="line">        ui-&gt;textEdit-&gt;<span class="built_in">setText</span>(array);</span><br><span class="line">        <span class="comment">//ui-&gt;textEdit-&gt;setText(codec-&gt;toUnicode(array));</span></span><br><span class="line">        <span class="comment">//对文件对象进行关闭</span></span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行写文件</span></span><br><span class="line">        file.<span class="built_in">open</span>(QIODevice::Append); <span class="comment">//用追加方式进行写</span></span><br><span class="line">        file.<span class="built_in">write</span>(<span class="string">&quot;哦哦哦哦哦 &quot;</span>);</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><h4 id="QFileInfo文件读取信息"><a href="#QFileInfo文件读取信息" class="headerlink" title="QFileInfo文件读取信息"></a>QFileInfo文件读取信息</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QFileInfo <span class="title">info</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;大小: &quot;</span>&lt;&lt;info.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;后缀名: &quot;</span>&lt;&lt;info.<span class="built_in">suffix</span>()&lt;&lt;<span class="string">&quot;文件名称: &quot;</span>&lt;&lt;info.<span class="built_in">fileName</span>()&lt;&lt;<span class="string">&quot;文件路径: &quot;</span>&lt;&lt;info.<span class="built_in">filePath</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;创建日期: &quot;</span>&lt;&lt;info.<span class="built_in">created</span>().<span class="built_in">toString</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;最后更新日期: &quot;</span>&lt;&lt;info.<span class="built_in">lastModified</span>().<span class="built_in">toString</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb开发</title>
      <link href="/2023/03/23/JavaWeb/"/>
      <url>/2023/03/23/JavaWeb/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaWeb开发"><a href="#JavaWeb开发" class="headerlink" title="JavaWeb开发"></a>JavaWeb开发</h1><h2 id="什么是HTML，CSS"><a href="#什么是HTML，CSS" class="headerlink" title="什么是HTML，CSS"></a>什么是HTML，CSS</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1.HTML：超文本编辑语言</span><br><span class="line">超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片，音频，视频等内容。</span><br><span class="line">标记语言：由标签构成的语言</span><br><span class="line">      HTML标签都是预定义好的。例如：使用<span class="tag">&lt;<span class="name">a</span>&gt;</span>展示超链接，使用<span class="tag">&lt;<span class="name">img</span>&gt;</span>展示图片，<span class="tag">&lt;<span class="name">video</span>&gt;</span>展示视频。</span><br><span class="line">      HTML代码直接在浏览器中运行，HTML标签由浏览器解析</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">CSS：层叠样式表，用于控制页面的样式(表现)</span><br></pre></td></tr></table></figure><h2 id="HTML快速入门"><a href="#HTML快速入门" class="headerlink" title="HTML快速入门"></a>HTML快速入门</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML入门<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>HELLO HTML<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;v2-ed0f23aed22d79c440935c9d1b0eb580_r.jpg&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>HTML标签不区分大小写</p></li><li><p>HTML标签属性值单双引号都可以</p></li><li><p>HTML语法松散</p><p>!加回车自动生成标准结构</p></li></ul><h3 id="新闻排版"><a href="#新闻排版" class="headerlink" title="新闻排版"></a>新闻排版</h3><ul><li>图片标签：<img><ul><li>src：指定图像的url(绝对路径&#x2F;相对路径)</li><li>width：图像的宽度(像素&#x2F;相对于父元素的百分比)</li><li>height：图像的高度(像素&#x2F;相对于父元素的百分比)</li></ul></li><li>标题标签：<h1>-<h6></li><li>水平线标签：<hr></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件类型为HTML --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 字符集为UTF-8 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置浏览器兼容性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>焦点访谈：中国底气 新思想夯实大国粮仓<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- src:图片资源路径 width：宽度(px:像素；%:相对于父元素的百分比) height：高度(px:像素；%:相对于父元素的百分比) --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 路径书写方式：</span></span><br><span class="line"><span class="comment">    绝对路径：</span></span><br><span class="line"><span class="comment">    1.绝对路径磁盘：</span></span><br><span class="line"><span class="comment">    2.绝对网络路径：</span></span><br><span class="line"><span class="comment">    相对路径：</span></span><br><span class="line"><span class="comment">    ./:当前目录，./可以省略</span></span><br><span class="line"><span class="comment">    ../:上一级目录</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/news_logo.png&quot;</span>&gt;</span>新浪政务&gt;正文</span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>焦点访谈：中国底气 新思想夯实大国粮仓<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">   2023年03月02日 21:50 央视网</span><br><span class="line">   <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="新闻样式"><a href="#新闻样式" class="headerlink" title="新闻样式"></a>新闻样式</h3><p>CSS引入方式：</p><ul><li>行内样式：写在标签的style属性中(不推荐)</li><li>内嵌样式：写在style标签中(可以写在页面任何位置，但通常约定写在head标签中)</li><li>外嵌样式：写在一个单独的.css文件中(需要通过link标签在网页中引入)</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>焦点访谈：中国底气 新思想夯实大国粮仓<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方式二：内嵌样式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;style&gt;</span></span><br><span class="line"><span class="comment">        h1&#123;</span></span><br><span class="line"><span class="comment">            /* color: aqua; */</span></span><br><span class="line"><span class="comment">            /* color:rgb(0, 0, 255); */</span></span><br><span class="line"><span class="comment">            color:#ff0000;  /* 可简写为#f00 */</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &lt;/style&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方式三：外嵌样式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./css/news.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/news_logo.png&quot;</span>&gt;</span>新浪政务&gt;正文</span><br><span class="line">   <span class="comment">&lt;!-- 方式一：行内样式 --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- &lt;h1 style=&quot;color: red;&quot;&gt;焦点访谈：中国底气 新思想夯实大国粮仓&lt;/h1&gt; --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span> &gt;</span>焦点访谈：中国底气 新思想夯实大国粮仓<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">   2023年03月02日 21:50 央视网</span><br><span class="line">   <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>颜色表示形式</li></ul><table><thead><tr><th align="center">表示方式</th><th>表示含义</th><th>取值</th></tr></thead><tbody><tr><td align="center">关键字</td><td>预定义的颜色名</td><td>red,green,blue…</td></tr><tr><td align="center">rgb表示法</td><td>红绿蓝三原色，每项取值范围：0-255</td><td>rgb(0,0,0),rgb(255,255,255),rgb(255,0,0)</td></tr><tr><td align="center">十六进制表示法</td><td>#开头，将数字转换成十六进制表示</td><td>#000000,#ff0000，简写：#000</td></tr></tbody></table><ul><li>CSS选择器：用来选取需要设置样式的元素(标签)</li></ul><ol><li>元素选择器</li></ol><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">h1</span>&gt;hello css&lt;/<span class="selector-tag">h1</span>&gt;    <span class="selector-tag">h1</span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>id选择器</li></ol><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">h1</span> id=&quot;hid&quot;&gt;css id selector&lt;/<span class="selector-tag">h1</span>&gt;   <span class="selector-id">#hid</span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>类选择器</li></ol><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">h1</span> class=&quot;cls&quot;&gt;css class selector&lt;/<span class="selector-tag">h1</span>&gt;  <span class="selector-class">.cls</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>注：<span>是一个开发网页时大量会用到的没有语义的布局标签</p><p>一行可以显示多个(组合行内元素)，宽度和高度默认由内容撑开</p><p>优先级：</p><ul><li>id选择器&gt;类选择器&gt;元素选择器</li></ul><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><ul><li>标签</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;...&quot;</span> <span class="attr">target</span>=<span class="string">&quot;...&quot;</span>&gt;</span>央视网<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>属性</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">href：指定资源访问的url</span><br><span class="line">target：指定在何处打开资源链接</span><br><span class="line">_self：默认值，在当前页面打开</span><br><span class="line">_blank：在空白页面打开</span><br></pre></td></tr></table></figure><h3 id="正文排版"><a href="#正文排版" class="headerlink" title="正文排版"></a>正文排版</h3><ul><li>视频标签：<video></li></ul><ol><li>src：规定视频的url</li><li>controls：显示播放控件</li><li>width：播放器的宽度</li><li>height：播放器的高度</li></ol><ul><li>音频标签：<audio></li></ul><ol><li>src：规定音频的url</li><li>controls：显示播放控件</li></ol><ul><li>段落标签：<p></li><li>文本加粗标签：<b> &#x2F; <strong></li><li>换行，段落标签：换行-<br> 段落：<p></li><li>CSS样式：</li></ul><ol><li>line-height：设置行高</li><li>text-indent：定义第一个行内容的缩进</li><li>text-align：规定元素中的文本的水平对齐方式</li></ol><ul><li>注意：在HTML中无论输入多少个空格，只会显示一个。可以使用空格占用符：&amp;nbsp</li></ul><h3 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h3><p><img src="/JavaWeb.assets/Snipaste_2023-07-03_17-10-06-1688429275539.png" alt="Snipaste_2023-07-03_17-10-06"></p><ul><li><p>布局标签：实际开发网页中，会大量频繁的使用div和span这两个没有语义的布局标签。</p></li><li><p>标签：<div> <span></p></li><li><p>特点：</p><ul><li>div标签：</li></ul><ol><li>一行只显示一个(独占一行)</li><li>宽度默认是父元素的宽度，高度默认由内容撑开</li><li>可以设置宽高(width,height)</li></ol><ul><li>span标签：</li></ul><ol><li>一行可以显示多个</li><li>宽度和高度默认由内容撑开</li><li>不可以设置宽高(width,height)</li></ol></li></ul><h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><ul><li>场景：在网页中以表格(行，列)形式整齐展示数据，如：班级表</li><li>标签：</li></ul><table><thead><tr><th align="center">标签</th><th>描述</th><th>属性&#x2F;备注</th></tr></thead><tbody><tr><td align="center"><table></td><td>定义表格整体，可以包裹多个<tr></td><td>border：规定表格边框的宽度  width：规定表格的宽度 cellspacing：规定单元之间的空间</td></tr><tr><td align="center"><tr></td><td>表格的行，可以包裹多个<td></td><td></td></tr><tr><td align="center"><td></td><td>表格单元格(普通)，可以包裹内容</td><td>如果是表头单元格，可以替换为<th></td></tr></tbody></table><h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><ul><li>场景：在网页中主要负责数据采集功能，如 注册，登录等数据采集</li><li>标签：<form></li><li>表单项：不同类型的input元素，下拉列表，文本域等</li></ul><ol><li><p><input>：定义表达项，通过type属性控制输入形式</p></li><li><p><select >：定义下拉列表</p></li><li><textarea>：定义文本域</li></ol><ul><li>属性：</li></ul><ol><li>action：规定当提交表单时向何处发送表单数据，url。如果不指定，默认提交到当前页面</li><li>method：规定用于发送表单数据的方式。</li></ol><ul><li>get：在url后面拼接表单数据，比如：?username&#x3D;Jack&amp;age&#x3D;10，url长度有限制。默认值</li><li>post：在消息体(请求体)中传递的，参数大小无限制</li></ul><h3 id="表单项标签"><a href="#表单项标签" class="headerlink" title="表单项标签"></a>表单项标签</h3><p><img src="/JavaWeb.assets/Snipaste_2023-07-04_09-38-56.png" alt="Snipaste_2023-07-04_09-38-56"></p><h2 id="Web入门"><a href="#Web入门" class="headerlink" title="Web入门"></a>Web入门</h2><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><ol><li>Web服务器</li></ol><ul><li>对HTTP协议操作进行封装，简化web程序开发</li><li>部署web项目，对外提供网上信息浏览服务</li></ul><ol start="2"><li>Toncat</li></ol><ul><li>一个轻量级的web服务器，支持servlet，jsp等少量javaEE规范</li><li>也被称为web容器，servlet容器。</li></ul><h3 id="分层解耦"><a href="#分层解耦" class="headerlink" title="分层解耦"></a>分层解耦</h3><h4 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h4><ul><li>controller：控制层，接收前端发送的请求，对请求进行处理，并响应数据。</li><li>service：业务逻辑层，处理具体的业务逻辑。</li><li>dao：数据访问层(Data Access Object)(持久层)，负责数据访问操作，包括数据的增，删，改，查。</li></ul><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081007884.png" alt="image-20230708100752745"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081014914.png" alt="image-20230708101418774"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081014895.png" alt="image-20230708101429777"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081014664.png" alt="image-20230708101445559"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081014270.png" alt="image-20230708101453102"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span> 与 <span class="meta">@Autowired</span> 区别</span><br><span class="line">    <span class="meta">@Autowired</span>是spring框架提供的注解，而<span class="meta">@Resource</span>是JDK提供的注解</span><br><span class="line">    <span class="meta">@Autowired</span>默认是按照类型注入，而<span class="meta">@Resource</span>默认是按照名称注入</span><br></pre></td></tr></table></figure><h4 id="数据连接池"><a href="#数据连接池" class="headerlink" title="数据连接池"></a>数据连接池</h4><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307141648609.png" alt="image-20230714164804494"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307141648406.png" alt="image-20230714164827280"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307141650771.png" alt="image-20230714165035652"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>maven</title>
      <link href="/2023/03/19/maven/"/>
      <url>/2023/03/19/maven/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="maven基础概念"><a href="#maven基础概念" class="headerlink" title="maven基础概念"></a>maven基础概念</h2><h3 id="Maven的作用"><a href="#Maven的作用" class="headerlink" title="Maven的作用"></a>Maven的作用</h3><ul><li>依赖管理：方便快捷的管理项目依赖的资源(jar包)，避免版本冲突问题</li><li>统一项目结构：提供标准，统一的项目结构</li><li>项目构建：标准跨平台(Linux,Windows,MacOS)的自动化项目构建方式</li></ul><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><ul><li>仓库：用于存储资源，包含各种jar包</li><li>仓库分类：</li></ul><ol><li><p>本地仓库：自己电脑上存储资源的仓库，连接远程仓库获取资源</p></li><li><p>远程仓库：非本机电脑上的仓库，为本地仓库提供资源</p><p>中央仓库：Maven团队维护，存储所有资源的仓库</p><p>私服：部门&#x2F;公司范围内存储资源的仓库，从中央仓库获取资源</p></li><li><p>私服的作用：</p><p>保存具有版权的资源，包含购买和自主研发的jar</p><p>中央仓库中的jar都是开源的，不能存储具有版权的资源</p><p>一定范围内共享资源，仅对内部开放，不对外共享</p></li></ol><h3 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h3><ul><li>定义：</li></ul><ol><li>Maven中的坐标是资源的唯一标识，通过该坐标可以唯一定位资源位置。</li><li>使用坐标来定义项目或引入项目中的依赖。</li></ol><ul><li>Maven坐标主要组成</li></ul><ol><li>groupId：定义当前Maven项目隶属组织名称(通常是域名反写)</li><li>artifactId：定义当前Maven项目名称(通常是模块名称)</li><li>version：定义当前项目版本号</li></ol><h3 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h3><ul><li>依赖：指当前项目运行所需要的jar包，一个项目中可以引入多个依赖。</li><li>配置：</li></ul><ol><li>在pom.xml中编写<dependencies>标签</li><li>在<dependencies>标签中 使用<dependency>引入坐标</li><li>定义坐标的groupId artifactId version</li><li>点击刷新按钮，引入最新加入的坐标</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意事项：</span><br><span class="line">如果引入的依赖，在本地仓库不存在，将会连接远程仓库/中央仓库，然后下载依赖。</span><br><span class="line">如果不知道依赖的坐标信息，可以到https://mvnrepository.com/中搜索</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring学习</title>
      <link href="/2023/03/16/Spring/"/>
      <url>/2023/03/16/Spring/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="1-充分解耦"><a href="#1-充分解耦" class="headerlink" title="1. 充分解耦"></a>1. 充分解耦</h2><ul><li>使用IOC容器管理bean(IOC)</li><li>在IOC容器内将有依赖关系的bean进行关系绑定(DI)</li><li>最终效果：使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程随记</title>
      <link href="/2023/03/16/openmp/"/>
      <url>/2023/03/16/openmp/</url>
      
        <content type="html"><![CDATA[<h1 id="openmp多线程"><a href="#openmp多线程" class="headerlink" title="openmp多线程"></a>openmp多线程</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><ol><li>firstprivate</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">firstprivate</span>(a)在多线程中a继承主线程中a的值，不干预其他线程的值</span><br></pre></td></tr></table></figure><ol start="2"><li>lastprivate</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lastprivate</span>(a)必须在有<span class="keyword">for</span>的多线程中使用，并继承最后的值</span><br></pre></td></tr></table></figure><ol start="3"><li>threadprivate</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#omp <span class="keyword">pragma</span> threadprivate(a)只能定义全局变量，且a可以在相同线程继承，不能在其他线程互通</span></span><br></pre></td></tr></table></figure><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><h3 id="schedule-实现工作量的划分和调度"><a href="#schedule-实现工作量的划分和调度" class="headerlink" title="schedule(实现工作量的划分和调度)"></a>schedule(实现工作量的划分和调度)</h3><ol><li>static</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">schedule(<span class="type">static</span>,size)  size为每次调度的迭代数量</span><br><span class="line">    将每次循环迭代划分为大小相等的块，</span><br></pre></td></tr></table></figure><ol start="2"><li>dynamic</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">schedule(dynamic)   size默认<span class="number">1</span></span><br><span class="line">    将计算任务分配给各个线程，谁快谁干得多</span><br></pre></td></tr></table></figure><ol start="3"><li>guided</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">schedule(guided)  与dynamic类似，但是块的大小一开始比较大，后来逐渐减少，从而减少了线程访问队列的时间</span><br></pre></td></tr></table></figure><ol start="4"><li>runtime</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">schedule(runtime)  运行过程中根据环境变量OMP_SCHEDULE来确定调度的类型，运行调度的实现仍然是上述三种调度方式的一种</span><br></pre></td></tr></table></figure><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><h3 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp critical的作用：</span></span><br><span class="line">各个线程并行执行<span class="keyword">for</span>里面的语句，但当执行<span class="number">1</span>到critical里面时，要注意有没有其他线程正在里面执行。如果有的话，要等其他线程执行完再进去执行。这样避免了race condition问题。</span><br><span class="line">    显而易见，它的执行速度会变低，因为可能存在线程等待的情况。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reduction</span>(+:sum)的作用：</span><br><span class="line">    告诉编译器：下面的<span class="keyword">for</span>循环要分成多个线程跑，但每个线程都要保存变量sum的拷贝，循环结束后，所有线程把自己的sum累加起来作为最后的输出。</span><br><span class="line">    reduction虽然方便，但它只支持一些基本操作，比如+，*，&amp;，|，^,&amp;&amp;,||八种</span><br></pre></td></tr></table></figure><h4 id="数据竞争原因"><a href="#数据竞争原因" class="headerlink" title="数据竞争原因"></a>数据竞争原因</h4><ul><li>多个线程访问同一个变量</li><li>线程之间没有同步机制，或者一个线程要执行写操作</li></ul><h4 id="避免数据竞争的方法"><a href="#避免数据竞争的方法" class="headerlink" title="避免数据竞争的方法"></a>避免数据竞争的方法</h4><ul><li>尽量使用私有变量</li><li>尽量在并行区域内使用局部变量</li><li>对并行区域外的变量进行读操作，尽量使用const类型</li><li>对并行区域外的变量进行写操作，用锁函数，原子操作，临界指令等包含数据</li></ul><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><h3 id="负载平衡"><a href="#负载平衡" class="headerlink" title="负载平衡"></a>负载平衡</h3><p>负载平衡是指将任务平均分配到并行执行系统的各个处理器上，使之充分发挥各个处理器的计算能力</p><p>难点：</p><ol><li>编程人员需要划分程序中的并行执行块。随着核数增多难度增大。d</li><li>负载错误划分会随着CPU核数增加而放大。</li><li>硬件和软件升级会破坏原有的负载平衡。</li></ol><h3 id="静态负载平衡"><a href="#静态负载平衡" class="headerlink" title="静态负载平衡"></a>静态负载平衡</h3><ul><li>人为地将工作区域分成多个可并行执行的部分，并将其均衡地分配给多个处理器运行。</li></ul><h3 id="动态负载平衡"><a href="#动态负载平衡" class="headerlink" title="动态负载平衡"></a>动态负载平衡</h3><ul><li>指在程序执行过程中，任务动态分配从而实现负载平衡。</li><li>系统实现任务调度，程序员只能选择动态平衡的策略，减轻程序员的工作量。</li><li>一般而言，动态平衡的系统性能比静态平衡要好。</li></ul><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><h3 id="循环工作量划分与调度"><a href="#循环工作量划分与调度" class="headerlink" title="循环工作量划分与调度"></a>循环工作量划分与调度</h3><ul><li>子句schedule实现工作量的划分与调度</li></ul><p>基本原则：</p><ul><li>分解代价低</li><li>任务计算要均衡</li><li>尽量避免Cache(缓存)冲突</li></ul><h3 id="四种调度类型"><a href="#四种调度类型" class="headerlink" title="四种调度类型"></a>四种调度类型</h3><ol><li>静态调度：static</li><li>动态调度：dynamic</li><li>指导性调度：guided</li><li>运行调度：runtime</li></ol><h3 id="三种调度参数"><a href="#三种调度参数" class="headerlink" title="三种调度参数"></a>三种调度参数</h3><ul><li>单调：每个线程递增迭代顺序执行</li><li>非单调：每个线程未指定顺序执行</li><li>向量化simd：根据硬件条件决定适合的向量化调度方式</li></ul><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><h3 id="子句collapse"><a href="#子句collapse" class="headerlink" title="子句collapse"></a>子句collapse</h3><ul><li><p>子句collapse仅能用于一个嵌套循环</p></li><li><p>将多重循环展开为一个更大的循环，从而增加线程组上划分调度的循环总次数</p></li><li><p>语法格式：collapse(n)</p></li></ul><h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><h3 id="指令sections"><a href="#指令sections" class="headerlink" title="指令sections"></a>指令sections</h3><ul><li>指令sections主要用于非循环代码的循环</li></ul><p><strong>注意事项：</strong></p><ul><li>一个程序可定义多个sections，彼此属于串行，由不同线程组执行。每个sections结构可定义多个section，彼此属于并行，由不同线程执行。</li><li>如果没有使用nowait，则sections结构结束时会有隐藏的barrier。</li><li>sections内部不能存在跳出结构之外的跳转语句。</li></ul><h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><h3 id="指令single"><a href="#指令single" class="headerlink" title="指令single"></a>指令single</h3><p><strong>注意事项：</strong></p><ul><li>一个single结构只能由一个线程(不一定为主线程)执行</li><li>不执行single的其他线程会在single结构结束处等待。若添加nowait，则不会等待</li><li>single内部不能存在跳出结构之外的跳转语句</li></ul><ol><li><p>可以并行的for循环，一般采用指令for分配工作，schedule确定分配方式。</p><p>schedule默认参数为static，均分工作</p><p>如果迭代计算负载差异较大，建议使用dynamic或guided分配方式</p></li><li><p>没有依赖的程序块，可采用指令sections并行</p></li><li><p>#pragma omp for，#pragma omp single，#pragma omp sections都包含隐式barrier</p></li></ol><h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><h3 id="锁函数"><a href="#锁函数" class="headerlink" title="锁函数"></a>锁函数</h3><ul><li>锁是为了保证一块代码或一块内存的一致性，从而使其上的操作串行化</li><li>openmp的锁操作：<ol><li>初始化(initialize)</li><li>上锁(set)</li><li>解锁(unset)</li><li>测试(test)</li><li>销毁(destroy)</li></ol></li></ul><h3 id="简单锁"><a href="#简单锁" class="headerlink" title="简单锁"></a>简单锁</h3><ul><li>简单锁不可以多次上锁，即使是同一个线程也不可以</li></ul><h3 id="嵌套锁"><a href="#嵌套锁" class="headerlink" title="嵌套锁"></a>嵌套锁</h3><ul><li>简单锁是一个一重嵌套锁</li><li>简单锁与嵌套锁的区别在于使用嵌套锁会引起锁计数器从而记录嵌套锁已被上锁次数</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>所谓死锁：各线程彼此等待对方拥有的资源</li></ul><p><em><strong>出现死锁的四个条件：</strong></em></p><ul><li>访问互斥：线程对资源独占访问，即每次只允许一个线程访问资源</li><li>资源独享：线程占用的资源在未使用结束前，不能被其他线程占用</li><li>等待解除占用：线程占有资源的同时继续请求其他资源，但是申请资源被其他线程占用</li><li>循环等待：线程对资源的请求形成循环链</li></ul><p><em><strong>破除死锁的条件：</strong></em></p><ul><li><p>针对访问互斥：</p><p>对将共享资源转变为私有资源</p><p>按一定顺序获取资源(锁)</p></li><li><p>针对等待解除占用，放弃已占用的资源</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2023/03/14/JavaScript/"/>
      <url>/2023/03/14/JavaScript/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript入门"><a href="#JavaScript入门" class="headerlink" title="JavaScript入门"></a>JavaScript入门</h1><h2 id="引入JavaScript"><a href="#引入JavaScript" class="headerlink" title="引入JavaScript"></a>引入JavaScript</h2><ol><li>内部脚本：将JS代码定义在HTML页面中</li></ol><ul><li>JavaScript代码必须位于<script></script>&gt;标签之间</li><li>在HTML文档中，可以在任意地方，放任意数量的<script></li><li>一般会把脚本置于<body>元素的底部，可以改善显示速度</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;hello javascript&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>    //可以出现多次，在html任意位置</span><br></pre></td></tr></table></figure><ol start="2"><li>外部脚本：将JS代码定义在外部JS文件中，然后引入到HTML页面中</li></ol><ul><li><p>外部JS文件中，只包含JS代码，不包含<script>标签</p></li><li><script>标签不能自闭和</li></ul><p>abs.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;hello javascript&quot;</span>)</span><br></pre></td></tr></table></figure><p>test.html</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;abs.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="书写语法"><a href="#书写语法" class="headerlink" title="书写语法"></a>书写语法</h3><ul><li>区分大小写：与java一样，变量名，函数名以及其他一切东西都是区分大小写的</li><li>每行结尾的分号可有可无</li></ul><h3 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h3><ul><li>使用window.alert()写入警告框</li><li>使用document.write()写入HTML输出</li><li>使用console.log()写入浏览器控制台</li></ul><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><ul><li>var定义的变量可以存放不同类型的值(javascript是一门弱类型语言)</li><li>作用域比较大，全局变量</li><li>可以重复定义</li></ul><p>变量类型 变量名=变量值;</p><p>js不区分整数和小数:</p><p>NAN          //not a number  (将NAN转换为boolean类型，为false)</p><p>Infinity     //表示无限大</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age=<span class="number">18</span>;</span><br><span class="line"><span class="keyword">var</span> name=<span class="string">&quot;张三&quot;</span>;</span><br></pre></td></tr></table></figure><p>变量名需要遵循如下规则：</p><ul><li>组成字符可以是任何字母，数字，下划线或美元符号</li><li>数字不能开头</li><li>建议使用驼峰命名</li></ul><p>注：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>关键字定义变量：用法类似于<span class="keyword">var</span>，但是声明的变量，只在<span class="keyword">let</span>关键字所在的代码块内有效，且不允许重复声明</span><br><span class="line"><span class="keyword">const</span>关键字：用来声明一个只读的常量。一但声明，常量的值就不能改变。</span><br><span class="line">使用<span class="keyword">typeof</span>运算符可以获取数据类型。例：<span class="keyword">typeof</span> a</span><br></pre></td></tr></table></figure><h3 id="等于"><a href="#等于" class="headerlink" title="等于"></a>等于</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">==    <span class="comment">//类型不一样，值一样，判断为true</span></span><br><span class="line">===   <span class="comment">//绝对等于，类型不一样，值一样，判断为false</span></span><br></pre></td></tr></table></figure><ul><li>NAN===NAN,这个与所有值都不相等，包括自己。false   </li><li>只能通过isNaN(NaN)来判断这个数是否是NaN</li></ul><h3 id="浮点数问题"><a href="#浮点数问题" class="headerlink" title="浮点数问题"></a>浮点数问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>/<span class="number">3</span>)===(<span class="number">1</span>-<span class="number">2</span>/<span class="number">3</span>)<span class="comment">//false</span></span><br></pre></td></tr></table></figure><blockquote><p>尽量避免使用浮点数进行运算，存在精度问题！</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="number">1</span>/<span class="number">3</span>-(<span class="number">1</span>-<span class="number">2</span>/<span class="number">3</span>))&lt;<span class="number">0.00000001</span></span><br></pre></td></tr></table></figure><h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h3><ul><li>null                    //对象为空 (typeof null ->object)</li><li>undefined        //当声明的变量未初始化时，该变量的默认值是undefined</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>Java的数值必须是相同类型的对象，JS中不需要这样</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;hello&#x27;</span>,<span class="literal">null</span>,<span class="literal">true</span>];<span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="title function_">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;hello&#x27;</span>);<span class="comment">//方式二</span></span><br><span class="line">访问：</span><br><span class="line">arr[索引]=值;</span><br><span class="line">特点：长度可变，类型可变</span><br></pre></td></tr></table></figure><p>取数组下标，如果越界了，就会:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><ul><li>属性</li></ul><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">length</td><td align="center">设置或返回数组中元素的数量</td></tr></tbody></table><ul><li>方法</li></ul><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">forEach()</td><td align="center">遍历数组中的每个有值的元素，并调用一次传入的函数</td></tr><tr><td align="center">push()</td><td align="center">将新元素添加到数组的末尾，并返回新的长度</td></tr><tr><td align="center">splice()</td><td align="center">从数组中删除元素</td></tr></tbody></table><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul><li>对象是大括号，数组中是中括号</li><li>JavaScript中所有的键都是字符串，值是任意对象！</li></ul><blockquote><p>每个属性之间使用逗号隔开，最后一个不需要添加</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名=&#123;</span><br><span class="line">    属性名: 属性值,</span><br><span class="line">    属性名: 属性值,</span><br><span class="line">    属性名: 属性值,</span><br><span class="line">    函数名称:<span class="keyword">function</span>(<span class="params">形参列表</span>)&#123;&#125;   --函数名称()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Person person=new Person(1,2,3,4);</span></span><br><span class="line"><span class="keyword">var</span> person&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">tags</span>:[<span class="string">&#x27;js&#x27;</span>,<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;web&#x27;</span>]      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用一个不存在的对象属性，不会报错！</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.<span class="property">haha</span></span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><ul><li>动态的删减属性，通过delete删除对象的属性</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> person.<span class="property">name</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>动态的添加属性，直接给新的属性添加值即可</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.<span class="property">haha</span>=<span class="string">&quot;haha&quot;</span></span><br><span class="line"><span class="string">&quot;haha&quot;</span></span><br></pre></td></tr></table></figure><ul><li>判断属性值是否在这个对象中！xxx in xxx!</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;age&#x27;</span> <span class="keyword">in</span> person</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>判断一个属性是否是这个对象自身拥有的 hasOwnProperty()</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>)</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">person.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="严格检查模式"><a href="#严格检查模式" class="headerlink" title="严格检查模式"></a>严格检查模式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>    <span class="comment">//严格检查模式，预防Javascript的随意性导致产生的一些问题，必须写在Javascript的第一行</span></span><br><span class="line"><span class="comment">//局部变量建议使用let去定义</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">stricpt</span>&gt;</span></span><br><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">   let i=1; </span><br><span class="line"><span class="tag">&lt;/<span class="name">stricpt</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>正常字符串我们使用单引号或双引号包裹</li><li>多行字符串编写</li><li>将字符串字面值转为数字。如果字面值不是数字，则转为NAN</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg=</span><br><span class="line">    <span class="string">`hello</span></span><br><span class="line"><span class="string">world</span></span><br><span class="line"><span class="string">你好</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><ul><li>模板字符串</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> msg=<span class="string">`你好呀,<span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line"><span class="comment">//let定义的是局部变量，不可重复声明</span></span><br></pre></td></tr></table></figure><ul><li>字符串的可变性：不可变</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student[<span class="number">0</span>])---s</span><br><span class="line">student[<span class="number">0</span>]=<span class="number">1</span>---<span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student)---student</span><br></pre></td></tr></table></figure><ul><li>substring</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[)</span><br><span class="line"> student.<span class="title function_">substring</span>(<span class="number">1</span>)  <span class="comment">//从第一个字符串截取到最后一个字符串</span></span><br><span class="line"> student.<span class="title function_">substringt</span>(<span class="number">1</span>,<span class="number">3</span>)  <span class="comment">//[1,3)</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">chatAt()</td><td align="center">返回在指定位置的字符</td></tr><tr><td align="center">indexOf()</td><td align="center">检索字符串</td></tr><tr><td align="center">trim()</td><td align="center">去除字符串两边的空格</td></tr><tr><td align="center">substring</td><td align="center">提取字符串中两个指定的索引号之间的字符(含头不含尾)</td></tr></tbody></table><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li>定义：JavaScript函数通过function关键字进行定义，语法为：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">定义方式<span class="number">1</span>：</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">参数<span class="number">1</span>，参数<span class="number">2.</span>..</span>)&#123;</span><br><span class="line">    <span class="comment">//要执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line">定义方式<span class="number">2</span>：</span><br><span class="line"><span class="keyword">var</span> functionName=<span class="keyword">function</span>(<span class="params">参数<span class="number">1</span>，参数<span class="number">2.</span>..</span>)&#123;</span><br><span class="line">    <span class="comment">//要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：</li></ul><ol><li>形式参数不需要类型。</li><li>返回值也不需要定义类型，可以在函数内部直接使用return返回即可</li></ol><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><ul><li>JSON是通过Javascript对象标记法书写的文本</li><li>由于其语法简单。层次结果鲜明，现多用于作为数据载体，在网络中进行数据传输。</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">-定义：</span><br><span class="line">var 变量名 = &#x27;<span class="punctuation">&#123;</span><span class="attr">&quot;key1&quot;</span><span class="punctuation">:</span>value1<span class="punctuation">,</span><span class="attr">&quot;key2&quot;</span><span class="punctuation">:</span>value2<span class="punctuation">&#125;</span>&#x27;;</span><br><span class="line">-示例</span><br><span class="line">var userStr=&#x27;<span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Jerry&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">18</span><span class="punctuation">,</span><span class="attr">&quot;addr&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;北京&quot;</span><span class="punctuation">,</span><span class="string">&quot;上海&quot;</span><span class="punctuation">,</span><span class="string">&quot;西安&quot;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span>&#x27;;</span><br><span class="line">-JSON字符串转为JS对象</span><br><span class="line">var jsObject=JSON.parse(userStr);</span><br><span class="line">-JS对象转为JSON字符串</span><br><span class="line">var jsonStr=JSON.stringify(jsObject);</span><br></pre></td></tr></table></figure><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><ul><li>概念：浏览器对象模型，允许JavaScript与浏览器对话，JavaScript将浏览器的各个组成部分封装成对象</li><li>组成：</li></ul><ol><li>Window：浏览器窗口对象</li><li>Navigator：浏览器对象</li><li>Screen：屏幕对象</li><li>History：历史记录对象</li><li>Location：地址栏对象</li></ol><h4 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h4><ul><li>获取：直接使用window，其中window.可以省略。</li><li>属性</li></ul><ol><li>history：对History对象的只读引用</li><li>location：用于窗口或框架的Location对象。</li><li>navigator：对Navigator对象的只读引用。</li></ol><ul><li>方法</li></ul><ol><li>alert()：显示带有一段消息和一个确认按钮的警告框。</li><li>confirm()：显示带有一段消息以及确认按钮和取消按钮的对话框。</li><li>setInterval()：按照指定的周期(以毫秒计)来调用函数或计算表达式。</li><li>setTimeout：在指定的毫秒数后调用函数或计算表达式。</li></ol><h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><ul><li>属性</li></ul><ol><li>href：设置或返回完整的URL。例：location.href="<a href="https://www.baidu.com/">https://www.baidu.com</a>"</li></ol><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307070810542.png" alt="Snipaste_2023-07-05_11-00-51"></p><ul><li>HTML中的Element对象可以通过Document对象获取，而Document对象是通过window对象获取的。</li><li>Document对象中提供以下获取Element元素对象的函数</li></ul><ol><li>根据id属性值获取，返回单个Element对象</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> h1=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;h1&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>根据标签名称获取，返回单个Element对象数组</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divs=<span class="variable language_">document</span>.<span class="title function_">getElementByTagName</span>(<span class="string">&#x27;div&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>根据name属性值获取，返回单个Element对象数组</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hobbys=<span class="variable language_">document</span>.<span class="title function_">getElementByName</span>(<span class="string">&#x27;hobby&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>根据class属性值获取，返回单个Element对象数组</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">class</span>=<span class="variable language_">document</span>.<span class="title function_">getElementByClassName</span>(<span class="string">&#x27;cls&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><ul><li>事件：HTML事件是发生在HTML元素上的"事件"。比如：</li></ul><ol><li>按钮被点击</li><li>鼠标移动到元素上</li><li>按下键盘按键</li></ol><ul><li>事件监听：JavaScript可以在事件被侦测到时执行代码。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql学习</title>
      <link href="/2023/03/12/mysql/"/>
      <url>/2023/03/12/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="基础MYSQL学习"><a href="#基础MYSQL学习" class="headerlink" title="基础MYSQL学习"></a>基础MYSQL学习</h1><h2 id="点击进入学习视频"><a href="#点击进入学习视频" class="headerlink" title="点击进入学习视频"></a><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=1&vd_source=807f4136109f993802c3f5a8bd0986c8">点击进入学习视频</a></h2><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h3><ul><li>查询所有数据库—show databases;</li><li>查询当前数据库—select database();</li><li>创建—create database[if not exists] 数据库名 [default charset 字符集] [collate 排序规则];</li><li>删除—drop database [if not exists] 数据库名</li><li>使用—use 数据库名</li></ul><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><ul><li><p>创建—create table 表名(</p><p>字段1  字段1类型 [comment] 注释,</p><p>…….</p><p>)[comment 表注释];</p></li><li><p>查询—查询当前数据库所有表—show tables;</p></li></ul><p>​       查询表结构—desc 表名;</p><p>​       查询指定表的建表语句—show create table 表名;</p><ul><li><p>修改</p><p>—添加字段—alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];</p></li></ul><p>​       —修改数据类型—alter table 表名 modify 字段名 新数据类型(长度);</p><p>​       —修改字段名和字段类型—alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];</p><p>​       —删除字段—alter table 表名 drop 字段名;</p><p>​       —修改表名—alter table 表名 rename to 新表名;</p><ul><li><p>删除</p><p>—删除表—drop table [if exits] 表名;</p></li></ul><p>​       —删除指定表，并重新创建该表，表中数据全被删除，表结构还在—truncate table 表名;</p><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><ul><li><p>insert into 表名 (字段1，字段2，…) values (值1，值2，…)                               —给指定字段添加数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into employee(id,name) values(1,&#x27;张三&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>insert into 表名 values (值1，值2，…)                                                                —给全部字段添加数据</p></li><li><p>insert into 表名 (字段1，字段2，…) values (值1，值2，…),(值1，值2，…);    </p><p>insert into 表名 values (值1，值2，…),(值1，值2，…),(值1，值2，…);            —批量添加数据</p><ul><li><em><strong>注意：</strong></em></li><li>插入数据时，指定的字段顺序需要与值的顺序是一一对应的</li><li><strong>字符串和日期型数据应该包含在引号中</strong></li><li>插入的数据大小，应该在字段的规定范围内</li></ul></li></ul><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><ul><li><p>update 表名 set 字段1&#x3D;值1,字段2&#x3D;值2,…..[where 一条件]</p></li><li><p><em><strong>注意</strong></em>：修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update employee set name =&#x27;wzhvv&#x27;,gender=&#x27;男&#x27; where id=1;</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><ul><li>delete from 表名 [where 条件]</li><li><em><strong>注意</strong></em>：delete语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据</li><li>delete语句不能删除某一个字段的值(可以使用update)</li></ul><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><ul><li><p>查询多个字段</p><p>—select 字段1，字段2…from 表名;</p><p>—select * from 表名;</p></li><li><p>设置别名</p></li></ul><p>​       —select 字段1[as 别名1]，字段2[as 别名2]…from 表名;</p><ul><li><p>去除重复记录</p><p>—select distinct 字段列表 from 表名;</p></li><li><p>条件查询</p></li></ul><p>​        —select 字段列表 from 表名 where 条件列表;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&gt;  或  !=     //不等于</span><br><span class="line">between and    //在某个范围之内（含最小，最大值）</span><br><span class="line">in(...)        //在in之后的列表中的值，多选一，满足其一即可</span><br><span class="line">例：select name from emp where id in(id=1,id=2);</span><br><span class="line">like &#x27;占位符&#x27;     //模糊匹配（&#x27;-&#x27;匹配单个字符，&#x27;%&#x27;匹配任意个字符）</span><br><span class="line">isnull         //是null</span><br></pre></td></tr></table></figure><ul><li>聚合函数</li></ul><p>​        —select 聚合函数（字段列表）from 表名;      &#x2F;&#x2F;null值不参与所有聚合函数运算</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">count      <span class="comment">//统计数量</span></span><br><span class="line">avg        <span class="comment">//平均值</span></span><br><span class="line">....</span><br><span class="line">select <span class="title function_">avg</span><span class="params">(e.salary)</span> from emp.e,dept d where e.dept_id=d.id and d.name=<span class="string">&#x27;研发部&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>分组查询</li></ul><p>​        —select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where和having区别</span><br><span class="line">    执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组，而having是分组之后对结果进行过滤。</span><br><span class="line">    判断条件不同：where不能对聚合函数进行判断，而having可以。</span><br><span class="line">    注意：</span><br><span class="line">       执行顺序：where&gt;聚合函数&gt;having</span><br><span class="line">       分组之后：查询的字段一般为聚合函数和分组字段，查询其他字段无意义。</span><br><span class="line">    select workaddress,count(*) from emp where age&lt;=45 group by workaddress having count(*)&gt;=3;</span><br><span class="line">    注意：使用聚合函数时，也使用了其他数据，其他数据要放在group by后面</span><br></pre></td></tr></table></figure><ul><li>排序查询</li></ul><p>​        —select 字段列表 from 表名 order by 字段1 排序方式1，字段2 排序方式2;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">asc    <span class="comment">//升序（默认值）</span></span><br><span class="line">desc   <span class="comment">//降序</span></span><br><span class="line">    注意：</span><br><span class="line">        如果多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。</span><br><span class="line">        select name,age from emp where age &lt;=<span class="number">35</span> order by age asc ,entrydate desc;</span><br></pre></td></tr></table></figure><ul><li>分页查询</li></ul><p>​       —select 字段列表 from 表名 limit 起始索引，查询记录数;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">起始索引从<span class="number">0</span>开始，起始索引=（查询页码-<span class="number">1</span>）*每页显示记录数。</span><br><span class="line">    select * from emp where gender=<span class="string">&#x27;男&#x27;</span> and between <span class="number">20</span> and <span class="number">40</span> order by age,entrydate desc limit <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><ul><li>查询用户</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">select * from user;</span><br></pre></td></tr></table></figure><ul><li>创建用户</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create user &#x27;用户名&#x27; @ &#x27;主机名&#x27; identified by &#x27;密码&#x27;;   //主机名可以用%通配-&gt;任意主机都可访问</span><br></pre></td></tr></table></figure><ul><li>修改用户密码</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter user &#x27;用户名&#x27; @ &#x27;主机名&#x27; identified with mysql_native_password by &#x27;新密码&#x27;;</span><br></pre></td></tr></table></figure><ul><li>删除用户</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop user &#x27;用户名&#x27; @ &#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure><h3 id="查询权限"><a href="#查询权限" class="headerlink" title="查询权限"></a>查询权限</h3><ul><li><p>权限表</p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081715688.png" alt="权限表"></p></li><li><p>查询权限</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show grants for &#x27;用户名&#x27; @ &#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure><ul><li>授予权限</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant 权限列表 on 数据库名.表名 to &#x27;用户名&#x27; @ &#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure><ul><li>撤销权限</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">revoke 权限列表 on 数据库名.表名 from &#x27;用户名&#x27; @ &#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure><ul><li>注意：多个权限之间，使用逗号隔开</li><li>授权时，数据库名和表名可以使用*进行通配，代表所有。</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 函数(参数)</span><br></pre></td></tr></table></figure><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><ul><li><p>concat(s1,s2…sn)                             &#x2F;&#x2F;字符串拼接，s1,s2…sn拼接成一个字符串</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select concat(&#x27;hello&#x27;,&#x27;mysql&#x27;);    //hellomysql</span><br></pre></td></tr></table></figure></li><li><p>lower(str)                                          &#x2F;&#x2F;将字符串str全部转为小写</p></li><li><p>upper(str)                                         &#x2F;&#x2F;将字符串str全部转为大写</p></li><li><p>lpad(str,n,pad)                                 &#x2F;&#x2F;左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select lpad(&#x27;01&#x27;,5,&#x27;-&#x27;);      //---01</span><br><span class="line">update emp set workno=lapd(workno,5,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>rpad(str,n,pad)                                &#x2F;&#x2F;右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</p></li><li><p>trim(str)                                            &#x2F;&#x2F;去掉字符串头部和尾部的空格</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select trim(&#x27;  hello  mysqkl  &#x27;);       //hello mysql</span><br></pre></td></tr></table></figure></li><li><p>substring(str,start,len)                   &#x2F;&#x2F;返回从字符串str从start位置起的len个长度的字符串，索引从1开始</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select substring(&#x27;hello mysql&#x27;,1,7);     //hello m</span><br></pre></td></tr></table></figure></li></ul><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><ul><li><p>ceil(x)                         &#x2F;&#x2F;向上取整</p></li><li><p>floor(x)                       &#x2F;&#x2F;向下取整</p></li><li><p>mod(x,y)                    &#x2F;&#x2F;返回x&#x2F;y的模，即x%y的值</p></li><li><p>rand()                         &#x2F;&#x2F;返回0-1的随机数</p></li><li><p>round(x,y)                  &#x2F;&#x2F;求参数x的四舍五入的值，保留y位小数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select lpad(round(rand()*1000000,0),6,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><ul><li><p>curdate()                                                                       &#x2F;&#x2F;返回当前日期</p></li><li><p>curtime()                                                                    &#x2F;&#x2F;返回当前时间</p></li><li><p>now()                                                                            &#x2F;&#x2F;返回当前日期和时间</p></li><li><p>YEAR(date)                                                                  &#x2F;&#x2F;获取指定date的年份</p></li><li><p>MONTH(date)                                                             &#x2F;&#x2F;获取指定date的月份</p></li><li><p>DAY(date)                                                                    &#x2F;&#x2F;获取指定date的日期</p></li><li><p>date_add(date,INTERVAL expr type)                      &#x2F;&#x2F;返回一个日期&#x2F;时间值加上一个时间间隔expr和type类型后的时间值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select date_add(now(),INTERVAL 70 DAY);</span><br></pre></td></tr></table></figure></li><li><p>datediff(date1,date2)                                               &#x2F;&#x2F;返回起始时间date1 和date2之间的天数，结果为date1-date2；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select datediff(&#x27;2021-09-01&#x27;,&#x27;2018-09-01&#x27;);</span><br><span class="line">select name,datediff(curdate(),entrydate) as &#x27;entrydays&#x27; from emp order by entrydays desc;</span><br></pre></td></tr></table></figure></li></ul><h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><ul><li>if(value,t,f)                                                                                            &#x2F;&#x2F;如果value为true，返回t，否则返回f</li><li>ifnull(value1,value2)                                                                           &#x2F;&#x2F;如果value1不为null，返回value1，否则返回value2</li><li>case when [val1] then [res1]…else[default] end                           &#x2F;&#x2F;如果val为true，返回res1，…否则返回default默认值</li><li>case [expr] when[val1] then [res1]…else [default] end               &#x2F;&#x2F;如果expr的值等于val1，返回res1， …否则返回default默认值</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">    name,</span><br><span class="line">    (case workaddress when &#x27;北京&#x27; then &#x27;一线城市&#x27; when &#x27;上海&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; end) as &#x27;工作地址&#x27;</span><br><span class="line">from emp;</span><br></pre></td></tr></table></figure><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>约束是作用于表中字段上的规则，用于限制存储在表中的数据。</li></ul><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul><li>保证数据库中数据的正确，有效性和完整性。</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">非空约束 --- 限制该字段的数据不能为null --- not null</span><br><span class="line">唯一约束 --- 保证该字段的所有数据都是唯一，不重复的 --- unique</span><br><span class="line">主键约束 --- 主键是一行数据的唯一标识，要求非空且唯一 --- primary key</span><br><span class="line">默认约束 --- 保存数据时，如果未指定该字段的值，则采用默认值 --- default</span><br><span class="line">检查约束 --- 保证字段值满足某一个条件 --- check</span><br><span class="line">外键约束 --- 用来让两张表的数据之间建立连接，保证数据的一致性和完整性 --- foreign key</span><br><span class="line">注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。</span><br></pre></td></tr></table></figure><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><ul><li>添加外键</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名&#123;</span><br><span class="line">字段名 数据类型,</span><br><span class="line">....</span><br><span class="line">[constraint(约束)] [外键名称] foreign key (外键字段名) references(引用) 主表(主表列名)</span><br><span class="line">&#125;;     //创建表时添加</span><br><span class="line">alter table 表名 add constraint 外键名称 foreign key (外键字段名) references 主表(主表列名);   //表结构创好时添加</span><br><span class="line">例：alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);</span><br></pre></td></tr></table></figure><ul><li>删除外键</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 drop foreign key 外键名称;</span><br></pre></td></tr></table></figure><ul><li>删除&#x2F;更新行为</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">not action --- 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(同restrich)</span><br><span class="line">restrich --- 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(同not action)</span><br><span class="line">cascade --- 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录。</span><br><span class="line">set null --- 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null(这就要求该外键允许取null)</span><br><span class="line">set default --- 父表有变更时，子表将外键列设置成一个默认的值(lnnodb不支持)</span><br><span class="line">alter table 表名 add constraint 外键名称 foreign key (外键字段) references 主表名(主表字段名) on update cascade(可变) on delete cascade(可变);</span><br></pre></td></tr></table></figure><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一对一 --- 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的</span><br><span class="line">一对多 --- 在多的一方建立外键，指向一的一方的主键</span><br><span class="line">多对多 --- 建立第三张中间表，中间表至少包含两个外键，分别关联两方外键</span><br></pre></td></tr></table></figure><h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询"></a>多表查询</h3><ul><li>内连接</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">隐式内连接：select 字段列表 from 表1,表2 where 条件...;</span><br><span class="line">显式内链接：select 字段列表 from 表1 [inner](可删) join 表2 on 连接条件...;</span><br><span class="line">隐式内连接 语法更简单，显示内连接 效率更高，两个在查询结果上来说是相同的</span><br><span class="line">例：select e.name,e.age,e.job,d,name from emp e inner join dept d on e.dept_id=d.id where e.age&lt;30;</span><br></pre></td></tr></table></figure><ul><li>外连接</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">左外连接：select 字段列表 from 表1 left [outer](可删) join 表2 on 条件...;</span><br><span class="line">右外连接：select 字段列表 from 表1 right [outer](可删) join 表2 on 条件...;</span><br></pre></td></tr></table></figure><ul><li>自连接</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段列表 from 表A 别名A join 表A 别名B on 条件...;</span><br><span class="line">自连接查询，可以是内连接查询，也可以是外连接查询。</span><br><span class="line">注意：必须使用表别名</span><br></pre></td></tr></table></figure><ul><li>联合查询</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段列表 from 表A ...</span><br><span class="line">union [all]</span><br><span class="line">select 字段列表 from 表B ...;</span><br><span class="line">对于联合查询的多张表的列数必须保持一致，字段类型也必须保持一致</span><br><span class="line">union all会将全部的数据直接合并到一起，union会对合并后的数据去重</span><br></pre></td></tr></table></figure><ul><li><p>子查询&#x2F;嵌套查询</p><p>根据子查询位置，分为：where之后，from之后，select之后</p><p>根据子查询结果不同，分为：</p></li></ul><ol><li>列子查询</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子查询返回的结果是一列(可以是多行)，这种子查询称为列子查询。</span><br><span class="line">常用操作符：in , not in , any , some , all</span><br><span class="line">in --- 在指定的集合范围内，多选一</span><br><span class="line">not in --- 不在指定的集合范围内</span><br><span class="line">all --- 子查询返回列表中，在任意一个满足即可</span><br><span class="line">some --- 与any等同，使用some的地方都可以用any</span><br><span class="line">all --- 子查询返回列表的所有值都必须满足</span><br></pre></td></tr></table></figure><ol start="2"><li>行子查询</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子查询返回的结果是一行(可以是多列)，这种子查询称为行子查询。</span><br><span class="line">常用的操作符：= , &lt;&gt; , in , not in</span><br><span class="line">select * from emp where (salary,managerid)=(select salary,managerid from emp where name=&#x27;张无忌&#x27;);</span><br></pre></td></tr></table></figure><ol start="3"><li>表字查询</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子查询返回结果是多行多列，这种子查询称为表子查询</span><br><span class="line">常用的操作符：in</span><br><span class="line">select * from emp where (salary,job) in(select salary,job from emp where name=&#x27;鹿杖客&#x27; or name=&#x27;宋远桥&#x27;);</span><br><span class="line">select e.*,d.* from (select * from emp where entrydate&gt;&#x27;2006-01-01&#x27;) e left outer join dept d on e.dept_id=d.id;</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><ul><li>查看&#x2F;设置事务提交方式</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@autocommit;</span><br><span class="line">set @@sutocommit=0;</span><br></pre></td></tr></table></figure><ul><li>提交事务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure><ul><li>回滚事务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rollback;</span><br></pre></td></tr></table></figure><ul><li>开启事务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start transaction 或 begin</span><br></pre></td></tr></table></figure><p>提交事务和回滚事务同上</p><h3 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h3><ul><li>原子性(Atomicity):事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性(Consistency):事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性(Isolation):数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性(Durability):事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><ul><li>脏读：一个事务读到另外一个事务还没有提交的数据。</li><li>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</li><li>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了幻影。</li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081715064.png" alt="事务隔离等级"></p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h3><ul><li>在创表时，指定存储引擎</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名&#123;</span><br><span class="line">....</span><br><span class="line">&#125;engine=innodb;</span><br></pre></td></tr></table></figure><ul><li>查看当前数据库支持的存储引擎</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure><h3 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h3><ul><li>InnoDB</li></ul><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081715066.png"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081715573.png"></p><ul><li>MyISAM</li></ul><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081715778.png"></p><ul><li>Memory</li></ul><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081715999.png"></p><ul><li>比较</li></ul><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081715438.png"></p><h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081715604.png"></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>索引是帮助mysql高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><ul><li><p>优势：提高数据检索的效率，降低数据库的IO成本。</p><p>​            通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</p></li><li><p>劣势：索引列也是要占用空间的。</p></li></ul><p>​                   索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT，UPDATE，DELETE时，效率降低。</p><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081715623.png"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081716463.png"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081716682.png"></p><h3 id="Btree索引"><a href="#Btree索引" class="headerlink" title="Btree索引"></a>Btree索引</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081716643.png" alt="Btree"></p><h3 id="B-tree索引"><a href="#B-tree索引" class="headerlink" title="B+tree索引"></a>B+tree索引</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081716370.png" alt="B+tree"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081716343.png"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081716434.png"></p><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081716389.png" alt="Hash"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081716489.png"></p><h3 id="B-tree索引优势"><a href="#B-tree索引优势" class="headerlink" title="B+tree索引优势"></a>B+tree索引优势</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081717258.png"></p><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081717444.png"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081717371.png"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081717449.png"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081717645.png"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081717707.png"></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li>创建索引</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create [unique|fulltext] index index_name on table_name(index_col_name...)</span><br><span class="line">例：create index ind_user_name on tb_user(name)</span><br><span class="line">   create unique index tb_user_phone on tb_user(phone)</span><br></pre></td></tr></table></figure><ul><li>查看索引</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show index from table_name;</span><br></pre></td></tr></table></figure><ul><li>删除索引</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop index index_name on table_name;</span><br><span class="line">例：drop index tb_user_email on tb_user;</span><br></pre></td></tr></table></figure><h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h3><h4 id="SQL执行频率"><a href="#SQL执行频率" class="headerlink" title="SQL执行频率"></a>SQL执行频率</h4><p>MySQL客户端连接成功后，通过show [session | global] status命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的insert,update,delete,select的访问频次</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show global status like &#x27;COM_______&#x27;; //(7个下划线)</span><br></pre></td></tr></table></figure><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><ol><li>查看慢查询日志开关开启情况</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;show_query_log&#x27;;</span><br></pre></td></tr></table></figure><ol start="2"><li><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081717606.png"></li></ol><h4 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h4><p>show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。<strong>通过have_profiling参数，能够看到当前MySQL是否支持profile操作</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@have_profiling;  select @@profiling;(查询是否打开)</span><br></pre></td></tr></table></figure><p>默认profling是关闭的，可以通过set语句在session&#x2F;global级别开启profling:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set profiling=1;</span><br></pre></td></tr></table></figure><p>执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看每一条SQL的耗时基本情况</span><br><span class="line">show profiles;</span><br><span class="line"> Query_ID | Duration   | Query                                     |</span><br><span class="line">+----------+------------+-------------------------------------------+</span><br><span class="line">|        1 | 0.00043350 | select @@profiling                        |</span><br><span class="line">|        2 | 0.00080550 | select * from tb_user where id=1          |</span><br><span class="line">|        3 | 0.00092550 | select * from tb_user where name=&#x27;白起&#x27; </span><br><span class="line">#查看指定query_id的SQL语句各个阶段的耗时情况</span><br><span class="line">show profile for query query_id;</span><br><span class="line">例：show profile for query 3;</span><br><span class="line">#查看指定query_id的SQL语句CPU的使用情况</span><br><span class="line">show profile cpu for query query_id;</span><br></pre></td></tr></table></figure><h4 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h4><p><strong>explain</strong>或者<strong>desc</strong>命令获取mysql如何执行select语句的信息，包括在select语句执行过程中如何连接和连接的顺序</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#直接在select语句之前加上关键字explain/desc</span><br><span class="line">explain select 字段列表 from 表名 where 条件;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307151515003.png" alt="image-20230715151514766"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typr：</span><br><span class="line">NULL：查询时不访问任何表。如：select <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">const：主键或唯一索引</span><br><span class="line">ref：非唯一索引</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307151515124.png" alt="image-20230715151539986"></p><h4 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h4><ul><li>验证索引效率</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在未建立索引之前，执行如下SQL语句，查看SQL的耗时</span><br><span class="line">select * from tb_sku where sn=&#x27;10000003145001&#x27;;</span><br><span class="line">针对字段创建索引</span><br><span class="line">create index idx_sku_sn on tb_sku(sn);</span><br><span class="line">然后再次执行相同的SQL语句，再次查看SQL的耗时</span><br><span class="line">select * from tb_sku where sn=&#x27;10000003145001&#x27;;</span><br></pre></td></tr></table></figure><ul><li>最左前缀法则</li></ul><p>如果索引了多列(联合索引)，要遵循最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。</p><p><strong>如果跳跃某一列，索引将部分失效(后面的字段索引失效)</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from tb_user where profession=&#x27;软件工程&#x27; and age=31 and status=&#x27;0&#x27;; //key_len=54</span><br><span class="line">explain select * from tb_user where profession=&#x27;软件工程&#x27; and age=31;  //key_len=49</span><br><span class="line">explain select * from tb_user where age=31 and status=&#x27;0&#x27;; //type=all,索引失效</span><br><span class="line">explain select * from tb_user where profession=&#x27;软件工程&#x27; and status=&#x27;0&#x27;; //key_len=47,status失效</span><br><span class="line">explain select * from tb_user where age=31 and status=&#x27;0&#x27; and profession=&#x27;软件工程&#x27;;//key_len=54</span><br><span class="line">索引中最左边元素必须存在，与所放位置无关</span><br></pre></td></tr></table></figure><ul><li>范围查询</li></ul><p>联合索引中，出现范围查询(&gt;,&lt;)，<strong>范围查询右侧的列索引失效</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from tb_user where profession=&#x27;软件工程&#x27; and age&gt;30 and status=&#x27;0&#x27;;//key_len=49</span><br><span class="line">explain select * from tb_user where profession=&#x27;软件工程&#x27; and age&gt;=30 and status=&#x27;0&#x27;;//key_len=54</span><br></pre></td></tr></table></figure><ul><li>索引列运算</li></ul><p>不要在索引列上进行运算操作，索引将失效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from tb_user where substring(phone,10,2)=&#x27;15&#x27;;</span><br></pre></td></tr></table></figure><ul><li>字符串不加引号</li></ul><p>字符串类型字段使用时，不加引号，索引将失效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from tb_user where profession=&#x27;软件工程&#x27; and age=31 and status=0;</span><br><span class="line">explain select * from tb_user where phone=17799990015;(字符串不加引号，隐式类型转换)</span><br></pre></td></tr></table></figure><ul><li>模糊查询</li></ul><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from tb_user where profession like &#x27;软件%&#x27;;</span><br><span class="line">explain select * from tb_user where profession like &#x27;%工程&#x27;;</span><br><span class="line">explain select * from tb_user where profession like &#x27;%工%&#x27;;</span><br></pre></td></tr></table></figure><ul><li>or连接条件</li></ul><p>用or分隔开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from tb_user where id=10 or age=23;</span><br><span class="line">explain select * from tb_user where phone=&#x27;17799990015&#x27; or age=23;</span><br></pre></td></tr></table></figure><p>由于age没有索引，所以即使id，phone有索引，索引也会失效。所以需要针对于age也要建立索引。</p><ul><li>数据分布影响</li></ul><p>如果MYSQL评估使用索引比全表更慢，则不使用索引。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from tb_user where phone&gt;=&#x27;17799990005&#x27;;</span><br><span class="line">select * from tb_user where phone&gt;=&#x27;17799990015&#x27;;</span><br></pre></td></tr></table></figure><ul><li>SQL提示</li></ul><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use index:(建议使用，可能不遵循)</span><br><span class="line">explain select * from tb_user use index(idx_user_pro) where profession=&#x27;软件工程&#x27;;</span><br><span class="line">ignore index:(不用)</span><br><span class="line">explain select * from tb_user ignore index(idx_user_pro) where profession=&#x27;软件工程&#x27;;</span><br><span class="line">force index:(强制)</span><br><span class="line">explain select * from tb_user force index(idx_user_pro) where profession=&#x27;软件工程&#x27;;</span><br></pre></td></tr></table></figure><ul><li>覆盖索引</li></ul><p>尽量使用覆盖索引(查询使用了索引，并且需要返回的列，在该索引中已经全部找到)，减少select *</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select id,profession from tb_user where profession=&quot;软件工程&quot; and age=31 and status=&#x27;0&#x27;;</span><br><span class="line">explain select id,profession,age,status from tb_user where profession=&quot;软件工程&quot; and age=31 and status=&#x27;0&#x27;;</span><br><span class="line"></span><br><span class="line">explain select id,profession,age,status,name from tb_user where profession=&quot;软件工程&quot; and age=31 and status=&#x27;0&#x27;;</span><br><span class="line">explain select * from tb_user where profession=&quot;软件工程&quot; and age=31 and status=&#x27;0&#x27;;</span><br></pre></td></tr></table></figure><p><strong>知识小贴士：</strong></p><p><strong>using index condition：查找使用了索引，但是需要回表查询数据</strong></p><p>using where;using index：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081717853.png" alt="Snipaste_2023-04-28_10-39-28"></p><ul><li>前缀索引</li></ul><p>当字段类型为字符串(varchar，text等)时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">create index idx_xxxx on table_name(column(n));</span><br><span class="line">前缀长度：</span><br><span class="line">可以根据索引的选择性来决定，而选择性是指不重复的索引值(基数)和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</span><br><span class="line">select count(distinct email)/count(*) from tb_user;   1</span><br><span class="line">select count(distinct substring(email,1,5))/count(*) from tb_user;  0.9513，变为4时为0.9123</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081718102.png" alt="Snipaste_2023-05-02_14-16-52"></p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><h4 id="insert优化"><a href="#insert优化" class="headerlink" title="insert优化"></a>insert优化</h4><ol><li>批量插入</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into tb_user values(1,&#x27;TOM&#x27;),(2,&#x27;CAT&#x27;),...;</span><br></pre></td></tr></table></figure><ol start="2"><li>手动提交事务</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">insert into tb_user values(1,&#x27;TOM&#x27;),(2,&#x27;CAT&#x27;),...;</span><br><span class="line">...</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><ol start="3"><li>主键顺序插入</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主键乱序插入：8 1 9 21 88 2 4 15 89 5 7 3</span><br><span class="line">主键顺序插入：1 2 3 4 5 7 8 9 15 21 88 89</span><br></pre></td></tr></table></figure><h4 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h4><ul><li>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。操作如下：</li></ul><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307161630957.png" alt="Snipaste_2023-07-16_16-15-09"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#客户端连接服务端时，加上参数 --local-infile</span><br><span class="line">mysql--local-infile -u root -p</span><br><span class="line">#设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="line">set global local_infile=1;</span><br><span class="line">#执行local指令将准备好的数据，加载到表结构中</span><br><span class="line">load data local infile &#x27;/root/sql1.log&#x27; into table &#x27;tb_user&#x27; fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;</span><br></pre></td></tr></table></figure><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><ul><li>介绍</li></ul><p>视图(view)是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p><p>通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><ul><li>创建</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create [or replace](可省略) view 视图名称[(列名列表)] as select语句 [with[cascaded | local] check option]</span><br></pre></td></tr></table></figure><ul><li>查询</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看创建视图语句：show create view 视图名称;</span><br><span class="line">查看视图数据：select * from 视图名称...;</span><br></pre></td></tr></table></figure><ul><li>修改</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一：create [or replace](不可省略) view 视图名称[(列名列表)] as select语句 [with[cascaded | local] check option]</span><br><span class="line">方式二：alter view 视图名称[(列名列表)] as select 语句 [with[cascaded | local] check option]</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop view [if exists] 视图名称 [视图名称]...;</span><br></pre></td></tr></table></figure><ul><li>视图的检查选项</li></ul><p>当使用with check option子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的定义。MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项：</p><p>cascaded 和 local，默认值为cascaded。</p><p>CASCADED:</p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081718108.png" alt="Snipaste_2023-05-03_16-03-56"></p><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307081718728.png" alt="Snipaste_2023-05-03_16-10-56"></p><ul><li>视图的更新</li></ul><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：</p><ol><li>聚合函数或窗口函数(sum(),min(),max(),count()等)</li><li>distinct</li><li>group by</li><li>having</li><li>union或者union all</li></ol><ul><li>作用</li></ul><ol><li>简单</li></ol><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件</p><ol start="2"><li>安全</li></ol><p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据</p><ol start="3"><li>数据独立</li></ol><p>视图可帮助用户屏蔽真实表结构变化带来的影响</p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li>介绍</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</span><br><span class="line">存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。</span><br></pre></td></tr></table></figure><ul><li>特点</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">封装，复用</span><br><span class="line">可以接收参数，也可以返回数据</span><br><span class="line">减少网络交互，效率提升</span><br></pre></td></tr></table></figure><ul><li>创建</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create procedure 存储过程名称([参数列表])</span><br><span class="line">begin</span><br><span class="line">     --SQL语句</span><br><span class="line">end;     </span><br></pre></td></tr></table></figure><ul><li>调用</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">call 名称([参数]);</span><br></pre></td></tr></table></figure><ul><li>查看</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select * from information_schema.routines where routine_schema=&#x27;xxx&#x27;;--查询指定数据库的存储过程及状态信息</span><br><span class="line">show create procedure 存储过程名称;--查询某个存储过程的定义</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drop procedure [id exists] 存储过程名称;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在命令行中，执行创建存储过程的SQL时，需要通过关键字delimiter指定SQL语句的结束符</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><p>系统变量是MYSQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(global)，会话变量(session)</p><ul><li>查看系统变量</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show [session | global] variables;   --查看所有系统变量</span><br><span class="line">show [session | global] variables like&#x27;...&#x27;;  --可以通过like模糊匹配的方式查找变量</span><br><span class="line">show @@[session | global] 系统变量名;  --查看指定变量的值</span><br></pre></td></tr></table></figure><ul><li>设置系统变量</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set [session | global] 系统变量名=值;</span><br><span class="line">set @@[session | global] 系统变量名=值;</span><br></pre></td></tr></table></figure><p>注意：</p><p>如果没有指定session&#x2F;global，默认是session，会话变量</p><p>mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在&#x2F;etc&#x2F;my.cnf中配置</p><h4 id="用户定义变量"><a href="#用户定义变量" class="headerlink" title="用户定义变量"></a>用户定义变量</h4><p>用户定义变量是用户根据需要自己定义的变量，用户变量不要提前声明，在用的时候**直接用”@变量名”**使用就可以。其作用域为当前连接</p><ul><li>赋值</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set @var_name=expr[,@var_name=expr]...;</span><br><span class="line">set @var_name:=expr[,@var_name=expr]...;</span><br><span class="line">set @myname=&#x27;wzhvv&#x27;;</span><br><span class="line">set @myage:=10;</span><br><span class="line">set @mygender:=&#x27;男&#x27;,@myhobby:=&#x27;mysql&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select @var_name=expr[,@var_name=expr]...;</span><br><span class="line">select 字段名 into @var_name from 表名;</span><br><span class="line">select @mycocor:=&#x27;red&#x27;;</span><br><span class="line">select count(*) into @mycount from tb_user;</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select @var_name;</span><br><span class="line">select @myname,@myage,@mygender,@myhobby;</span><br></pre></td></tr></table></figure><p>注意：</p><p>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL</p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>局部变量是根据需要定义的在局部生效的变量，访问之前，需要declare声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其声明的begin…end块</p><ul><li>声明</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">declare 变量名 变量类型 [default...];</span><br></pre></td></tr></table></figure><p>变量类型就是数据库字段类型：int，begint，char，varchar，date，time等</p><ul><li>赋值</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set 变量名=值;</span><br><span class="line">set 变量名:=值;</span><br><span class="line">set 字段名 into 变量名 from 表名...;</span><br></pre></td></tr></table></figure><h3 id="流程结构"><a href="#流程结构" class="headerlink" title="流程结构"></a>流程结构</h3><h4 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h4><p>语法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if 条件1 then</span><br><span class="line">....</span><br><span class="line">elseif 条件2 then</span><br><span class="line">....</span><br><span class="line">else</span><br><span class="line">....</span><br><span class="line">end if;</span><br></pre></td></tr></table></figure><h4 id="参数-in-out-input"><a href="#参数-in-out-input" class="headerlink" title="参数(in,out,input)"></a>参数(in,out,input)</h4><table><thead><tr><th align="center">类型</th><th align="center">含义</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">in</td><td align="center">该类参数作为输入，也就是需要调用时传入值</td><td align="center">默认</td></tr><tr><td align="center">out</td><td align="center">该类参数作为输出，也就是该参数可以作为返回值</td><td align="center"></td></tr><tr><td align="center">inout</td><td align="center">既可以作为输入参数，也可以作为输出参数</td><td align="center"></td></tr></tbody></table><p>用法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create procedure 存储过程([in/out/inout 参数名 参数类型])</span><br><span class="line">begin</span><br><span class="line">   --SQL语句</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><p>语法一：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case case_value</span><br><span class="line">      when when_value1 then statement_list1</span><br><span class="line">      [when when_value2 then statement_list2]...</span><br><span class="line">      [else statement_list]</span><br><span class="line">end case;     </span><br></pre></td></tr></table></figure><p>语法二：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case</span><br><span class="line">    when search_condition1 then statement_list1</span><br><span class="line">    [when search_condition2 then statement_list2]...</span><br><span class="line">    [else statement_list]</span><br><span class="line">end case;</span><br></pre></td></tr></table></figure><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>while循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑</span><br><span class="line">while 条件 do</span><br><span class="line">     SQL逻辑...</span><br><span class="line">end while;   </span><br></pre></td></tr></table></figure><h4 id="repeat-相当于do…while"><a href="#repeat-相当于do…while" class="headerlink" title="repeat(相当于do…while)"></a>repeat(相当于do…while)</h4><p>repeat是有条件的循环控制语句，当满足条件的时候退出循环。具体语法为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#先执行一次逻辑，然后判定逻辑是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span><br><span class="line">repeat </span><br><span class="line">     SQL逻辑...</span><br><span class="line">     until 条件</span><br><span class="line">end repeat;     </span><br></pre></td></tr></table></figure><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><p>loop实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。loop可以配合以下两个语句使用：</p><ul><li>leave：配合循环使用，退出循环</li><li>iterate：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[begin_lable:] loop</span><br><span class="line">       SQL逻辑...</span><br><span class="line">end loop [end_lable];     </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leave lable;   --退出指定标记的循环体</span><br><span class="line">iterate lable; --直接进入下一次循环</span><br></pre></td></tr></table></figure><h4 id="游标-cursor"><a href="#游标-cursor" class="headerlink" title="游标-cursor"></a>游标-cursor</h4><p>游标(cursor)是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明，open，fetch和close，其语法分别如下。</p><ul><li>声明游标</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare 游标名称 cursor for 查询语句;</span><br></pre></td></tr></table></figure><ul><li>打开游标</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open 游标名称;</span><br></pre></td></tr></table></figure><ul><li>获取游标记录</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fetch 游标名称 into 变量[，变量];</span><br></pre></td></tr></table></figure><ul><li>关闭游标</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close 游标名称;</span><br></pre></td></tr></table></figure><h4 id="条件处理程序-handler"><a href="#条件处理程序-handler" class="headerlink" title="条件处理程序(handler)"></a>条件处理程序(handler)</h4><p>条件处理程序(handle)可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare handler_action handler for condition_value [,condition_value]...statement;</span><br><span class="line">handler_action</span><br><span class="line">        continue:继续执行当前程序</span><br><span class="line">        exit:终止执行当前程序</span><br><span class="line">condition_value</span><br><span class="line">        sqlstate sqlstate_value:状态码，如02000</span><br><span class="line">        sqlwarning:所有以01开头的sqlstate代码的简写</span><br><span class="line">        not found:所有以02开头的sqlstate代码的简写</span><br><span class="line">        sqlexeception:所有没有被sqlwarning或not found捕获的sqlstate代码的简写</span><br></pre></td></tr></table></figure><h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><p>存储函数是有返回值的存储过程，存储函数的参数只能是in类型的。具体语法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create function 存储函数名称([参数列表])</span><br><span class="line">returns type [characteristic...]</span><br><span class="line">begin</span><br><span class="line">    --SQL语句</span><br><span class="line">    return ...;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">characteristic说明:</span><br><span class="line">-deterministic:相同的输入参数总是产生相同的结果</span><br><span class="line">-no sql:不包含sql语句</span><br><span class="line">-reads sql data:包含读取数据的语句，但不包含写入数据的语句</span><br></pre></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是与表相关的数据库对象，指在insert&#x2F;update&#x2F;delete之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</p><p>使用别名old和new来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><table><thead><tr><th align="center">触发器类型</th><th align="center">new和old</th></tr></thead><tbody><tr><td align="center">insert型触发器</td><td align="center">new表示将要或者已经新增的数据</td></tr><tr><td align="center">update型触发器</td><td align="center">old表示修改之前的数据，new表示将要或已经修改后的数据</td></tr><tr><td align="center">delete型触发器</td><td align="center">old表示将要或者已经删除的数据</td></tr></tbody></table><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建：</span><br><span class="line">create trigger trigger_name</span><br><span class="line">before/after insert/update/delete</span><br><span class="line">on tbl_name for each row --行级触发器</span><br><span class="line">begin</span><br><span class="line">    trigger_stmt;</span><br><span class="line">end;</span><br><span class="line">查看</span><br><span class="line">show triggers;</span><br><span class="line">删除</span><br><span class="line">drop trigger [schema_name] trigger_name; --如果没有指定schema_name,默认为当前数据库</span><br></pre></td></tr></table></figure><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="概述：-1"><a href="#概述：-1" class="headerlink" title="概述："></a>概述：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源(CPU，RAM，I/O)的争用以外，数据也是一种供许多用户共享的资源，如何保证数据并发访问的一致性，有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</span><br></pre></td></tr></table></figure><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ol><li>全局锁：锁定数据库中的所有表</li><li>表级锁：每次操作锁住整张表</li><li>行级锁：每次操作锁住对应的行数据</li></ol><h1 id="数据库随记"><a href="#数据库随记" class="headerlink" title="数据库随记"></a>数据库随记</h1><h2 id="MySQL查询语句的执行顺序"><a href="#MySQL查询语句的执行顺序" class="headerlink" title="MySQL查询语句的执行顺序"></a>MySQL查询语句的执行顺序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先找到要查询表格或连接要查询的表格，因此FROM才是第一步；</span><br><span class="line"></span><br><span class="line">接下来是进行条件筛选，所以是WHERE紧随其后；</span><br><span class="line"></span><br><span class="line">然后如果遇到表格有分组的需要，则需要先GROUP BY；</span><br><span class="line"></span><br><span class="line">分组时如果也存在筛选条件，这里就要用HAVING进行分组筛选；</span><br><span class="line"></span><br><span class="line">这些执行过后才是查询操作SELECT；</span><br><span class="line"></span><br><span class="line">SELECT的时候如果遇到重复数据，就需要去重，即使用DISTINCT;</span><br><span class="line"></span><br><span class="line">接下来如果要对查询后的数据进行排序，会用到ORDER BY；</span><br><span class="line"></span><br><span class="line">最后如果要指定返回的查询数据范围、条数则要用LIMIT/OFFSET函数。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown学习</title>
      <link href="/2023/03/11/markdawn/"/>
      <url>/2023/03/11/markdawn/</url>
      
        <content type="html"><![CDATA[<h1 id="MarkDown学习"><a href="#MarkDown学习" class="headerlink" title="MarkDown学习"></a>MarkDown学习</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>#+空格创建标题，根据#数量创建不同级标题</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>** ** 加粗</p><p><em>hello world</em>  斜体 一个*号</p><p>~~ ~~ 删除线</p><p><del>hello world</del></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>大于号</p></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>三个-号或者三个*号</p><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307062352946.jpg" alt="小王子"></p><p>!+[]+（图片路径）</p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="https://wzhvv.github.io/">点击跳转到我的博客</a></p><p>[]+(地址)</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol><li>1+.+空格</li><li>有序号的换行</li></ol><ul><li>-+空格</li><li>无序号的换行</li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307062352810.png" alt="表格的使用"></p><p>然后进入代码模式删掉之间的空格</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">​```+要写的代码样式，如java或c</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
