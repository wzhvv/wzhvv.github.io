<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Linux | HAO</title><meta name="author" content="wzhvv"><meta name="copyright" content="wzhvv"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux学习终端 一系列输入输出设备的总称  shell家族 shell：命令解释器，根据输入的命令执行相应命令。  查看当前系统有哪些shell：  cat &#x2F;etc&#x2F;shells查看当前系统正在使用的shell：  echo $SHELL  Unix–&gt;shell Linux–&gt;bash 类Unix系统目录 根目录下bin存放二进制可执行文件  根目录下boot存放开机时的启动程">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux">
<meta property="og:url" content="http://example.com/2023/11/25/Linux/index.html">
<meta property="og:site_name" content="HAO">
<meta property="og:description" content="Linux学习终端 一系列输入输出设备的总称  shell家族 shell：命令解释器，根据输入的命令执行相应命令。  查看当前系统有哪些shell：  cat &#x2F;etc&#x2F;shells查看当前系统正在使用的shell：  echo $SHELL  Unix–&gt;shell Linux–&gt;bash 类Unix系统目录 根目录下bin存放二进制可执行文件  根目录下boot存放开机时的启动程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.png">
<meta property="article:published_time" content="2023-11-25T06:19:44.000Z">
<meta property="article:modified_time" content="2023-11-25T06:19:44.626Z">
<meta property="article:author" content="wzhvv">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/11/25/Linux/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: wzhvv","link":"链接: ","source":"来源: HAO","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-11-25 14:19:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="HAO"><span class="site-name">HAO</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-25T06:19:44.000Z" title="发表于 2023-11-25 14:19:44">2023-11-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-25T06:19:44.626Z" title="更新于 2023-11-25 14:19:44">2023-11-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h1><h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><ul>
<li>一系列输入输出设备的总称</li>
</ul>
<h3 id="shell家族"><a href="#shell家族" class="headerlink" title="shell家族"></a>shell家族</h3><ul>
<li>shell：命令解释器，根据输入的命令执行相应命令。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看当前系统有哪些shell：</span><br><span class="line">  <span class="built_in">cat</span> /etc/shells</span><br><span class="line">查看当前系统正在使用的shell：</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br></pre></td></tr></table></figure>

<p>Unix–&gt;shell</p>
<p>Linux–&gt;bash</p>
<h2 id="类Unix系统目录"><a href="#类Unix系统目录" class="headerlink" title="类Unix系统目录"></a>类Unix系统目录</h2><ul>
<li><p>根目录下bin存放二进制可执行文件</p>
</li>
<li><p>根目录下boot存放开机时的启动程序</p>
</li>
<li><p>根目录下dev存放设备文件</p>
</li>
<li><p>根目录下etc存放用户信息和相关配置文件</p>
</li>
<li><p>根目录下home存放用户</p>
</li>
<li><p>根目录下root存放宿主目录(家目录)</p>
</li>
<li><p>根目录下lib存放库路径</p>
</li>
<li><p>根目录下media，mnt用于挂载磁盘和卸载磁盘</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">插入磁盘，挂载成文件，默认在media下</span><br></pre></td></tr></table></figure>

<ul>
<li>根目录下usr存放第三方应用库(用户资源管理目录)</li>
</ul>
<h2 id="Linux命令基础"><a href="#Linux命令基础" class="headerlink" title="Linux命令基础"></a>Linux命令基础</h2><ol>
<li>什么是命令，命令行</li>
</ol>
<ul>
<li>命令：即Linux操作指令，是系统内置的程序，可以以字符化的形式去使用。</li>
<li>命令行：即Linux终端，可以提供字符化的操作页面供命令执行。</li>
</ul>
<ol start="2">
<li>Linux命令的通用格式</li>
</ol>
<ul>
<li>command(命令本身) [-options(可选，命令的一些选项，可以通过选项控制命令的行为细节)] [parameter(可选，命令的参数，多数用于i命令的指向目标)]</li>
</ul>
<h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><ol>
<li>ls命令参数的作用</li>
</ol>
<ul>
<li>可以指定要查看的文件夹(目录)的内容，如果不给定参数，要查看当前工作目录的内容。</li>
</ul>
<ol start="2">
<li>ls命令的选项</li>
</ol>
<ul>
<li><p>-a选项，可以展示出隐藏的内容</p>
<p> 以’.’开头的文件或文件夹默认被隐藏，需要-a才能显示出来</p>
</li>
<li><p>-l选项，以列表的形式展示内容，并展示更多细节</p>
</li>
<li><p>-h选项，需要和-l选项搭配使用，以更加人性化的方式显示文件的大小单位</p>
</li>
<li><p><strong>-d选项，查看目录本身</strong></p>
</li>
<li><p>-R选项，递归展示所有信息，包括文件夹内的</p>
</li>
</ul>
<ol start="3">
<li>命令的选项组合使用</li>
</ol>
<ul>
<li>命令的选项是可以组合使用的，比如：ls-lah等同于ls-a-l-h</li>
</ul>
<h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h3><ol>
<li>cd命令的作用</li>
</ol>
<ul>
<li><p>cd命令可以切换当前工作目录，语法是：cd [Linux路径]</p>
<p>没有选项，只有参数，表示目标路径</p>
<p>使用参数，切换到指定路径</p>
<p>不使用参数，切换工作目录到当前用户的HOME</p>
</li>
</ul>
<ol start="2">
<li>特殊路径符</li>
</ol>
<ul>
<li>‘.’   表示当前目录，比如cd .&#x2F;Desktop表示切换到当前目录下的Desktop目录内，和cd Desktop效果一致</li>
<li>‘..’  表示上一级目录，比如：cd .. 即可切换到上一级目录，cd ..&#x2F;.. 切换到上二级的目录</li>
<li>‘~’  表示HOME目录，比如：cd ~ 即可切换到HOME目录或cd ~&#x2F;Desktop &#x3D; cd &#x2F;home&#x2F;wzhvv&#x2F;Desktop 切换到HOME内的Desktop目录</li>
<li>‘-‘，cd -表示返回进入此目录之前的目录</li>
</ul>
<h3 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h3><ul>
<li>pwd命令，没有选项，没有参数，直接使用即可</li>
<li>作用：输出当前所在的工作目录</li>
</ul>
<h3 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h3><ol>
<li>mkdir命令的语法和功能</li>
</ol>
<ul>
<li>mkdir用以创建新的目录(文件夹)</li>
<li>语法：mkdir [-p] Linux路径</li>
<li>参数必填，表示要创建的目录的路径，相对，绝对，特殊路径符都可以使用</li>
</ul>
<ol start="2">
<li>-p选项的作用</li>
</ol>
<ul>
<li>可选，表示自动创建不存在的父目录，适用于创建连续多层级的目录</li>
</ul>
<h3 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h3><ul>
<li>用于创建一个新文件</li>
<li>语法：touch Linux路径</li>
<li>参数必填，表示要创建的文件的路径，相对，绝对，特殊路径都可以使用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> <span class="string">&#x27;abc xyz&#x27;</span> 或 <span class="built_in">touch</span> abc\ xyz</span><br></pre></td></tr></table></figure>

<h3 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h3><ul>
<li>用于查看文件内容</li>
<li>语法：cat Linux路径</li>
<li>参数必填，表示要查看的文件的路径，相对，绝对路径符都可以使用</li>
<li>直接使用cat，可以读终端，输什么显示什么</li>
<li><strong>倒着写成tac，文件输出从下往上</strong></li>
</ul>
<h3 id="more-x2F-less命令"><a href="#more-x2F-less命令" class="headerlink" title="more&#x2F;less命令"></a>more&#x2F;less命令</h3><ul>
<li>用于查看文件的内容，可翻页查看</li>
<li>语法：more Linux路径</li>
<li>参数必填，表示要查看的文件的路径，相对，绝对，特殊路径符都可以使用</li>
<li>使用空格进行翻页，使用q退出查看，也可以ctrl+c退出，但less只能用q退出</li>
</ul>
<h3 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h3><ul>
<li>默认显示文件前十行</li>
<li>可以指定行数</li>
</ul>
<h3 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h3><ul>
<li>查看文件尾部内容，并且可以持续追踪</li>
<li>语法：tail [-f  -num] linux路径</li>
<li>-f：持续跟踪，-num：启动的时候查看尾部多少行，默认10</li>
<li>linux路径，表示被查看的文件</li>
</ul>
<h3 id="tree命令"><a href="#tree命令" class="headerlink" title="tree命令"></a>tree命令</h3><ul>
<li>按结构树的形状显示文件和目录</li>
</ul>
<h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h3><ul>
<li>用于复制文件和文件夹</li>
<li>语法：cp [-r] 参数1 参数2</li>
<li>-r选项，可选，用于复制文件夹使用，表示递归</li>
<li>-a选项，可选，复制全部文件和文件夹，文件时间不变</li>
<li>参数1，linux路径，表示被复制的文件或文件夹</li>
<li>参数2，linux路径，表示要复制去的地方</li>
</ul>
<h3 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h3><ul>
<li>用于移动文件和文件夹</li>
<li>语法：mv 参数1 参数2</li>
<li>参数1，linux路径，表示被移动的文件或文件夹</li>
<li>参数2，linux路径，表示要移动去的地方，如果目标不存在，则进行改名，确保目标存在</li>
</ul>
<h3 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h3><ul>
<li>用于删除文件和文件夹</li>
<li>语法： rm [-r -f] 参数1 参数2 … 参数n</li>
<li>-r选项， 可选，文件夹删除</li>
<li>-f选项，可选，用于强制删除(不提示，一般用于root用户)</li>
<li>参数，表示被删除的文件或文件夹路径，支持多个，空格隔开</li>
<li>参数也支持通配符*，用以做模糊匹配</li>
</ul>
<h3 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h3><ul>
<li>查找命令所在的程序文件</li>
<li>语法：which  要查找的命令</li>
<li>无需选项，只需要参数表示查找哪个命令</li>
</ul>
<h3 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h3><ul>
<li><strong>用于查找指定的文件</strong></li>
<li>按文件名查找：find 起始路径 -name “被查找文件名”<ul>
<li>支持通配符</li>
<li>符号*表示通配符，即匹配任意内容(包括空)</li>
<li>test*，表示匹配任何以test开头的内容</li>
<li>*test，表示匹配任何以test结尾的内容</li>
<li>*test *，表示匹配任何包含test的内容</li>
</ul>
</li>
<li>按文件大小查找：find 起始路径 -size   +|-    n[kMG]<ul>
<li>+，-表示大于和小于</li>
<li>n表示大小数字</li>
<li>kMG表示大小单位，k(小写字母)表示kb，M表示MB，G表示GB。默认为b，一块-&gt;512byte</li>
</ul>
</li>
<li>-type 按文件类型搜索</li>
<li>-maxdepth 指定搜索深度</li>
<li>atime(访问)，mtime(属性修改)，ctime(文件内容修改) 天</li>
<li>-exec：将find搜索的结果集执行某一指定命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /usr/ -name <span class="string">&quot;*tmp*&quot;</span> -<span class="built_in">exec</span> <span class="built_in">ls</span> -l &#123;&#125; \; --&#123;&#125;：将-<span class="built_in">exec</span>前面的内容放入&#123;&#125;中执行</span><br></pre></td></tr></table></figure>

<ul>
<li>-ok：以交互式的方式将find搜索的结果集执行某一指定命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find ./ -name <span class="string">&quot;*tmp&quot;</span> -ok <span class="built_in">rm</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<ul>
<li>-xargs：将find搜索的结果集执行某一指定命令。当结果集数量过大时，可以分片映射。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /usr/ -name <span class="string">&#x27;*tmp*&#x27;</span> | xargs <span class="built_in">ls</span> -ld //默认以空格作为拆分依据</span><br></pre></td></tr></table></figure>

<ul>
<li>print0</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /usr/ -name <span class="string">&#x27;*tmp*&#x27;</span> -print0 | xargs -print0 <span class="built_in">ls</span> -ld //此时默认以null作为拆分依据</span><br><span class="line">find /usr/ -name <span class="string">&#x27;*tmp*&#x27;</span> -print0 | xargs -0 <span class="built_in">ls</span> -ld //此时不询问</span><br></pre></td></tr></table></figure>

<h3 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h3><ul>
<li><strong>找文件内容</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -r <span class="string">&#x27;copy&#x27;</span> ./ -n</span><br><span class="line">ps aux | grep <span class="string">&#x27;cupsd&#x27;</span> --检索进程结果集</span><br></pre></td></tr></table></figure>

<ul>
<li>从文件中通过关键字过滤文件行</li>
<li>语法：grep [-n] 关键字  文件路径</li>
<li>选项-n，可选，表示在结果中显示匹配的行的行号</li>
<li>参数，关键字，必填，表示过滤的关键字，带有空格或其他特殊符号，建议使用” “将关键字包围起来</li>
<li>参数，文件路径，必填，表示要过滤内容的文件路径，<strong>可作为管道符的输入</strong></li>
</ul>
<h3 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h3><ul>
<li>命令统计文件的行数，单词数量，字节数，字符数等</li>
<li>语法：wc [-c -m -l -w] 文件路径</li>
<li>不带选项默认统计：行数，单词数，字节数</li>
<li>-c字节数，-m字符数，-l行数，-w单词数</li>
<li>参数，被统计的文件路径，可作为管道符的输入</li>
</ul>
<h3 id="whoami命令"><a href="#whoami命令" class="headerlink" title="whoami命令"></a>whoami命令</h3><ul>
<li>查看当前登录用户</li>
</ul>
<h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符 |"></a>管道符 |</h3><ul>
<li>将管道符左边命令的结果，作为右边命令的输入</li>
</ul>
<h3 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h3><ul>
<li>可以使用echo命令在命令行内输出指定内容</li>
<li>语法：echo 输出的内容**(env：查看所有环境变量)**</li>
<li>无需选项，只有一个参数，表示要输出的内容，复杂内容可以用” “包围</li>
</ul>
<h3 id="96-反引号符"><a href="#96-反引号符" class="headerlink" title="&#96;反引号符"></a>&#96;反引号符</h3><ul>
<li>被&#96;包围的内容，会被<strong>作为命令执行</strong>，而非普通字符</li>
</ul>
<h3 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h3><ul>
<li>“&gt;”，将左侧命令的结果，覆盖写入到符号右侧指定的文件中</li>
<li>“&gt;&gt;”，将左侧命令的结果，追加写入到符号右侧指定的文件中</li>
</ul>
<h3 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307211010017.png" alt="vi/vim编辑器"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入还可以是：I A O S s</span><br><span class="line">命令模式退出：ZZ(保存 退出)</span><br><span class="line">末行模式返回命令模式：ESC 2次 或 执行末行命令</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i：插入光标前一个字符</span><br><span class="line">I：插入行首</span><br><span class="line">a：插入光标后一个字符</span><br><span class="line">A：插入行末</span><br><span class="line">o：向下新开一行，插入行首</span><br><span class="line">O：向上新开一行，插入行首</span><br><span class="line">s：删除当前光标，插入</span><br><span class="line">S：删除当前行，插入</span><br></pre></td></tr></table></figure>

<h3 id="vi基本快捷键"><a href="#vi基本快捷键" class="headerlink" title="vi基本快捷键"></a>vi基本快捷键</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">跳转到指定行：1. 88G(命令模式) 2. 88(末行模式)</span><br><span class="line">跳转文件首：gg(命令模式)</span><br><span class="line">跳转文件尾：G(命令模式)</span><br><span class="line">自动格式化程序：gg=G(命令模式)</span><br><span class="line">大括号对应：%(命令模式)</span><br><span class="line">光标移至行首：0(命令模式) 执行结束，工作模式不变</span><br><span class="line">光标移至行尾：$(命令模式) 执行结束，工作模式不变</span><br><span class="line">删除单个字符：x(命令模式) 执行结束，工作模式不变</span><br><span class="line">替换单个字符：将待替换的字符用光标选中，r(命令模式)，再按预替换的字符</span><br><span class="line">删除一个单词：dw(命令模式) 光标置于单词的首字母进行操作</span><br><span class="line">删除光标至行尾：D 或 d$(命令模式)</span><br><span class="line">删除光标至行首：d0(命令模式)</span><br><span class="line">删除指定区域：按v(命令模式) 切换为 <span class="string">&quot;可视模式&quot;</span>，使用 hjkl 挪移光标来选中待删除区域。按 d 删除该区域数据</span><br><span class="line">删除指定一行：在光标所在行，按<span class="built_in">dd</span>(命令模式)</span><br><span class="line">删除指定N行：在光标所在行，按Ndd(命令模式)</span><br><span class="line">复制一行：yy</span><br><span class="line">粘贴：p：向后 P：向前(删除本质是剪切)</span><br><span class="line">查找：1.找设想内容：命令模式下，按“/”输入欲搜索关键字，回车。使用n检索下一个</span><br><span class="line">     2.找看到的内容：命令模式下，将光标置于单词任意一个字符上，按“*”(向下找) 或 “<span class="comment">#”(向上找)</span></span><br><span class="line">单行替换：将光标置于待替换行上，进入末行模式，输入 :s /原数据/新数据</span><br><span class="line">通篇替换：末行模式下，输入 :%s /原数据/新数据/g g：不加，只替换每行首个</span><br><span class="line">指定行的替换：末行模式下， :起始行号,终止行号s /原数据/新数据/g g：不加，只替换每行首个</span><br><span class="line">            :29,35s /printf/println/g  </span><br><span class="line">撤销，反撤销：u ctrl+r   (命令模式)</span><br><span class="line">分屏：sp：横屏分 ctrl+ww切换</span><br><span class="line">     vsp：竖屏分 ctrl+ww切换</span><br><span class="line">跳转至man手册：将光标置于待查看函数单词上，使用K(命令模式)跳转。指定卷，nK (1：一卷表命令，2：二卷系统调用，3：三卷是库...) </span><br><span class="line">查看宏定义：将光标置于待查看宏定义单词上，使用 [d 查看定义语句</span><br><span class="line">在末行模式执行shell命令：:!命令 -&gt; :!<span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure>

<h3 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h3><ol>
<li>&#x2F;etc&#x2F;vim&#x2F;vimrc</li>
<li>~&#x2F;.vimrc</li>
<li>~&#x2F;.vimrc优先级高</li>
</ol>
<h3 id="Linux的root用户-超级管理员"><a href="#Linux的root用户-超级管理员" class="headerlink" title="Linux的root用户(超级管理员)"></a>Linux的root用户(超级管理员)</h3><p>root用户拥有最大的系统操作权限，而普通用户在许多地方的权限是受限的。</p>
<ul>
<li>普通用户的权限，一般在其HOME目录内是不受限的</li>
<li>一旦出了HOME目录，大多数地方，普通用户仅有只读和执行权限，无修改权限</li>
</ul>
<h4 id="su命令"><a href="#su命令" class="headerlink" title="su命令"></a>su命令</h4><ul>
<li><p>su命令就是用于账户切换的系统命令，其来源英文单词：Switch User</p>
</li>
<li><p>语法：su [-] [用户名]</p>
</li>
<li><p>“-“ 符号是可选的，表示是否在切换用户后加载环境变量，建议带上</p>
</li>
<li><p>参数：用户名，表示要切换的用户，用户名也可以省略，省略表示切换到root</p>
</li>
<li><p>切换用户后，可以通过exit命令退回上一个用户，也可以使用快捷键：ctrl+d</p>
</li>
<li><p>使用普通用户，切换到其他用户需要输入密码，如切换到root用户</p>
</li>
<li><p>使用root用户切换到其他用户，无需密码，可以直接切换</p>
</li>
</ul>
<h4 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h4><p>在我们得知root密码的时候，可以通过su命令切换到root得到最大权限</p>
<p>但是我们不建议长期使用root用户，避免带来系统损坏</p>
<p>我们可以使用sudo命令，为普通的命令授权，临时以root身份执行</p>
<ul>
<li>语法：sudo 其他命令</li>
<li>在其他命令之前，带上sudo，即可为一条命令临时赋予root授权</li>
<li>但是并不是所有的用户，都有权力使用sudo，我们需要为普通用户配置sudo认证</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307211010234.png" alt="sudo认证"></p>
<h3 id="用户，用户组"><a href="#用户，用户组" class="headerlink" title="用户，用户组"></a>用户，用户组</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307211010056.png" alt="image-20230502161110601"></p>
<h4 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h4><p>以下命令需root用户执行</p>
<ul>
<li>创建用户组</li>
</ul>
<p>groupadd 用户组名</p>
<ul>
<li>删除用户组</li>
</ul>
<p>groupdel 用户组名</p>
<h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p>以下命令需root用户执行</p>
<ul>
<li>创建用户</li>
</ul>
<p>useradd [-g -d] 用户名</p>
<ul>
<li><p>选项：-g指定用户的组，不指定-g，会创建同名组并自动加入，指定-g需要组已经存在，如已存在同名组，必须使用-g</p>
</li>
<li><p>选项：-d指定用户HOME路径，不指定，HOME目录默认在：&#x2F;home&#x2F;用户名</p>
</li>
<li><p>删除用户</p>
</li>
</ul>
<p>userdel [-r] 用户名</p>
<ul>
<li><p>选项：-r，删除用户的HOME目录，不使用-r，删除用户时，HOME目录保留</p>
</li>
<li><p>查看用户所属组</p>
</li>
</ul>
<p>id[用户名]</p>
<ul>
<li><p>参数：用户名，被查看的用户，如果不提供则查看自身</p>
</li>
<li><p>修改用户所属组</p>
</li>
</ul>
<p>usermod -aG 用户组 用户名，将指定用户加入指定用户组</p>
<p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307211010030.png" alt="image-20230502163205161"></p>
<p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307211010683.png" alt="image-20230502163242470"></p>
<h3 id="查看权限控制信息"><a href="#查看权限控制信息" class="headerlink" title="查看权限控制信息"></a>查看权限控制信息</h3><h4 id="认知权限信息"><a href="#认知权限信息" class="headerlink" title="认知权限信息"></a>认知权限信息</h4><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307211010192.png" alt="Snipaste_2023-05-03_09-49-46"></p>
<p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307211010851.png" alt="屏幕截图 2023-03-11 194556"></p>
<h4 id="rwx"><a href="#rwx" class="headerlink" title="rwx"></a>rwx</h4><ul>
<li>r表示读权限</li>
<li>w表示写权限</li>
<li>x表示执行权限</li>
</ul>
<p>针对文件，文件夹的不同，rwx的含义有细微差别</p>
<ul>
<li>r，针对文件可以查看文件内容<ul>
<li>针对文件夹，可以查看文件夹内容，如ls命令</li>
</ul>
</li>
<li>w，针对文件表示可以修改此文件<ul>
<li>针对文件夹，可以在文件夹内：创建，删除，改名等操作</li>
</ul>
</li>
<li>x，针对文件表示可以将文件作为程序执行<ul>
<li>针对文件夹，表示可以更改工作目录到此文件夹，即cd进入</li>
</ul>
</li>
</ul>
<h4 id="Linux系统文件类型"><a href="#Linux系统文件类型" class="headerlink" title="Linux系统文件类型"></a>Linux系统文件类型</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">普通文件：-</span><br><span class="line">目录文件：d</span><br><span class="line">字符设备文件：c</span><br><span class="line">块设备文件：b</span><br><span class="line">软链接：l</span><br><span class="line">管道文件：p</span><br><span class="line">套接字：s</span><br><span class="line">未知文件</span><br></pre></td></tr></table></figure>



<h3 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h3><ul>
<li>功能：修改文件，文件夹的权限细节</li>
<li>限制：只能是文件，文件夹的所属用户或root用户有权修改</li>
<li>语法：chmod [-R] 权限 文件或文件夹</li>
<li>选项：-R，对文件夹内的全部内容应用同样的规则</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">-chmod u=rwx,g=rx,o=x hello.txt，将文件权限修改为：rwx r-x --x</span><br><span class="line"> 其中：u表示user所属用户权限，g表示group组权限，o表示other其他用户权限 a表示所有(all)用户，系统默认值</span><br><span class="line">-chmod -R u=rwx,g=rx,o=x test，将文件夹test以及文件夹内全部内容权限设置为：rwx r-x --x</span><br><span class="line">-chmod [who] [+ | - | =] [mode] 文件名</span><br><span class="line">+：添加某个权限。</span><br><span class="line">-：取消某个权限。</span><br><span class="line">=：赋予给定权限并取消其他所有权限(如果有的话)。</span><br></pre></td></tr></table></figure>

<h4 id="权限的数字序号"><a href="#权限的数字序号" class="headerlink" title="权限的数字序号"></a>权限的数字序号</h4><ul>
<li>r代表4，w代表2，x代表1</li>
<li>rwx的相互组合可以得到从0到7的8种权限组合</li>
<li>如7代表：rwx，5代表：r-x，1代表：–x</li>
</ul>
<h3 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h3><ul>
<li>功能：修改文件，文件夹的所属用户，用户组</li>
<li>限制：只可root执行</li>
<li>语法：chown [-R] [用户] [:] [用户组] 文件或文件夹<ul>
<li>选项，-R，同chmod。对文件夹内全部内容应用相同规则</li>
<li>选项，用户，修改所属用户</li>
<li>选项，用户组，修改所属用户组</li>
<li>：，用于分割用户和用户组</li>
</ul>
</li>
</ul>
<p>示例：</p>
<ul>
<li>chown root hello.txt，将hello.txt<strong>所属用户</strong>修改为root</li>
<li>chown :root hello.txt，将hello.txt<strong>所属用户组</strong>修改为root</li>
<li>chown root:whvv hello.txt，将hello.txt所属用户修改为root，用户组修改为wzhvv</li>
<li>chown -R root test，将文件夹test的所属用户修改为root并对文件夹内全部内容应用同样规则</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">创建用户：sudo adduser 新用户名</span><br><span class="line">修改文件所属用户：sudo <span class="built_in">chown</span> 新用户名 待修改文件</span><br><span class="line">删除用户：sudo deluser 用户名</span><br><span class="line">创建用户组：sudo addgroup 新组名</span><br><span class="line">修改所属用户组：sudo <span class="built_in">chgrp</span> 新用组户 待修改文件</span><br><span class="line">删除组：sudo delgroup 用户组名</span><br></pre></td></tr></table></figure>



<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul>
<li>“ctrl + c”，强制停止</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1，Linux某些程序的运行，如果想要强制停止它，可以使用快捷键ctrl+c</span><br><span class="line">2，命令输入错误，也可以通过快捷键ctrl+c，退出当前输入，重新输入</span><br></pre></td></tr></table></figure>

<ul>
<li>“ctrl+z”，暂停到后台，使用<strong>fg</strong>恢复。</li>
<li>“ctrl + d”，退出或登出</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1，可以通过快捷键：ctrl + d，退出账户的登录</span><br><span class="line">2，或者退出某些特定程序的专属页面</span><br><span class="line">ps：不能用于退出vi/vim</span><br></pre></td></tr></table></figure>

<ul>
<li>历史命令搜索</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1，可以通过history命令，查看历史输入过的命令</span><br><span class="line">2，可以通过!命令前缀，自动执行上一次匹配前缀的命令</span><br><span class="line">3，可以通过快捷键：ctrl + r，输入内容去匹配历史命令</span><br><span class="line">如果搜索到的内容是你需要的，那么：</span><br><span class="line">- 回车键可以直接执行</span><br><span class="line">- 键盘左右键，可以得到此命令(不执行)</span><br><span class="line">4，ctrl+p 查看上一条指令</span><br><span class="line">5，ctrl+n 查看下一条指令</span><br></pre></td></tr></table></figure>

<ul>
<li>光标移动快捷键</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctrl + a，跳到命令开头</span><br><span class="line">ctrl + e，跳到命令结尾</span><br><span class="line">ctrl + 键盘左键，向左跳一个单词</span><br><span class="line">ctrl + 键盘右键，向右跳一个单词</span><br></pre></td></tr></table></figure>

<ul>
<li>清屏</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">通过快捷键ctrl + l，可以清空终端内容</span><br><span class="line">或通过命令clear得到同样效果</span><br></pre></td></tr></table></figure>

<ul>
<li>命令和路径补齐</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在bash下敲命令时，Tab键可以补全已经敲了一部分的文件名和目录名。在Ubuntu系统下，默认启用了bash completion，可以补全命令的某些参数，Makefile目标等。</span><br></pre></td></tr></table></figure>

<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p>apt：deb包软件管理器，用于自动化安装配置Linux软件，并可以自动解决依赖问题。</p>
<p>语法：apt [-y] [install | remove | search] 软件名称</p>
<ul>
<li>选项：-y，自动确认，无需手动确认安装或卸载过程</li>
<li>install：安装</li>
<li>remove：卸载</li>
<li>search：搜索</li>
</ul>
<p>apt命令需要root权限，需要联网</p>
<ul>
<li>使用软件包(.deb)安装：sudo dpkg -i 安装包名</li>
</ul>
<h3 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h3><p>作用：可以控制软件(服务)的启动，关闭，开机自启动</p>
<ul>
<li>系统内置服务均可被systemctl控制</li>
<li>第三方软件，如果自动注册了可以被systemctl控制</li>
<li>第三方软件，如果没有自动注册，可以手动注册</li>
</ul>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start | stop | status | enable | disable 服务名</span><br></pre></td></tr></table></figure>

<ul>
<li>start 启动</li>
<li>stop 关闭</li>
<li>status 查看状态</li>
<li>enable 开启开机自启</li>
<li>disable 关闭开机自启</li>
</ul>
<h3 id="ln命令创建软链接"><a href="#ln命令创建软链接" class="headerlink" title="ln命令创建软链接"></a>ln命令创建软链接</h3><p>在系统中创建软链接，可以将文件，文件夹链接到其它位置</p>
<p>类似Windows系统中的<strong>快捷方式</strong></p>
<p>语法：ln -s 参数1 参数2</p>
<ul>
<li>-s选项，创建软链接</li>
<li>参数1：被链接的文件或文件夹</li>
<li>参数2：要链接去的目的地</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">参数1默认是相对路径，当将参数2移动时将无法正确访问</span><br><span class="line">为保证软链接可以任意搬移，创建时务必对源文件使用绝对路径</span><br></pre></td></tr></table></figure>

<h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><ul>
<li>语法：ln 参数1 参数2</li>
</ul>
<p>操作系统给每一个文件赋予唯一的inode，当有相同inode的文件存在时，彼此同步。</p>
<p>删除时，只将硬链接计数减一。减为0时，inode被释放</p>
<ul>
<li>目的：实现文件共享。</li>
</ul>
<h3 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h3><p>通过date命令可以在命令行中查看系统时间</p>
<p>语法：date [-d] [+格式化字符串]</p>
<ul>
<li><p>-d 按照给定的字符串显示日期，一般用于日期计算</p>
</li>
<li><p>格式化字符串：通过特定的字符串标记，来控制显示的日期格式</p>
<ul>
<li>%Y          年</li>
<li>%y          月份后两位数字(00 99)</li>
<li>%m        月份(01 12)</li>
<li>%d         日(01 31)</li>
<li>%H        小时(00 23)</li>
<li>%M       分钟(00 59)</li>
<li>%S         秒(00 60)</li>
<li>%s         自 1970-01-01 00:00:00 UTC到现在的秒数</li>
</ul>
</li>
<li><p>其中支持的时间标记为：</p>
<ul>
<li>year</li>
<li>month</li>
<li>day</li>
<li>hour</li>
<li>minute</li>
<li>second</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date -d &quot;+1 day&quot; +%Y%m%d   #显示后一天的日期</span><br></pre></td></tr></table></figure>

<ul>
<li>-d 选项可以和格式化字符串配合一起使用</li>
</ul>
<h3 id="修改Linux时区"><a href="#修改Linux时区" class="headerlink" title="修改Linux时区"></a>修改Linux时区</h3><p>使用root权限，执行如下命令，修改时区为东八区时区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -f /etc/localtime</span><br><span class="line">sudo ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure>

<p>将系统自带的localtime文件删除，并将&#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai文件链接为localtime文件即可</p>
<h3 id="ntp命令"><a href="#ntp命令" class="headerlink" title="ntp命令"></a>ntp命令</h3><p>我们可以通过ntp程序自动校准系统时间</p>
<p>安装ntp：apt -y install ntp</p>
<p>启动并设置开机自启：</p>
<ul>
<li>systemctl start ntpd</li>
<li>systemctl enable ntpd</li>
</ul>
<p>当ntpd启动后会定期的帮助我们联网校准系统的时间</p>
<ul>
<li>也可以手动校准(需root权限)：ntpdate -u ntp.aliyun.com</li>
</ul>
<p>通过阿里云提供的服务网址配合ntpdate(安装ntp后会附带这个命令)命令自动校准</p>
<h3 id="ip地址和主机名"><a href="#ip地址和主机名" class="headerlink" title="ip地址和主机名"></a>ip地址和主机名</h3><h4 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h4><p>每一台联网的电脑都会有一个地址，用于和其他计算机进行通讯</p>
<p>ip地址主要有两个版本，v4和v6版本</p>
<p>IPv4版本的地址格式是：a.b.c.d，其中abcd表示0~255的数字，如192.168.88.101就是一个标准的IP地址</p>
<ul>
<li>可以通过命令：ifconfig，查看本机的ip地址，如无法使用ifconfig命令，可以安装：apt -y install net-tools</li>
</ul>
<h4 id="特殊ip地址"><a href="#特殊ip地址" class="headerlink" title="特殊ip地址"></a>特殊ip地址</h4><ul>
<li>127.0.0.1，这个ip地址用于指代本机</li>
<li>0.0.0.0，特殊ip地址<ul>
<li>可以用于指代本机</li>
<li>可以在端口绑定中用来确定绑定关系</li>
<li>在一些ip地址限制中，表示所有ip的意思，如放行规则设置为0.0.0.0，表示允许任意ip访问</li>
</ul>
</li>
</ul>
<h4 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h4><p>每一台电脑除了对外联络地址(ip地址)以外，也可以有一个名字，称之为主机名</p>
<ul>
<li>可以使用命令：hostname查看主机名</li>
<li>可以使用命令：hostnamectl set-hostname 主机名，修改主机名(需root)</li>
</ul>
<h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><p>ip地址难以记忆，我们可以通过字符化的地址去访问服务器。如在浏览器内打开<a target="_blank" rel="noopener" href="http://www.baidu.com,会打开百度的网址,百度的网址称之为域名./">www.baidu.com，会打开百度的网址，百度的网址称之为域名。</a></p>
<p><img src="/Linux.assets/Snipaste_2023-05-09_17-11-50.png" alt="Snipaste_2023-05-09_17-11-50"></p>
<h4 id="配置主机名映射"><a href="#配置主机名映射" class="headerlink" title="配置主机名映射"></a>配置主机名映射</h4><p>我们ubuntu是通过ip地址连接到的Linux服务器，那有没有可能通过域名(主机名)连接呢？</p>
<p>可以，我们只需要在Windows系统的：C:\Windows\System32\drivers\etc\hosts文件中配置记录即可</p>
<h3 id="配置Linux固定ip地址"><a href="#配置Linux固定ip地址" class="headerlink" title="配置Linux固定ip地址"></a>配置Linux固定ip地址</h3><h4 id="为什么需要固定ip"><a href="#为什么需要固定ip" class="headerlink" title="为什么需要固定ip"></a>为什么需要固定ip</h4><p>当前我们虚拟机的Linux操作系统，其ip地址是通过DCHP服务获取的</p>
<p>DCHP：动态获取ip地址，即每次重启设备后都会获取一次，可能导致ip地址频繁变更</p>
<p>原因1：办公电脑ip地址变化无所谓，但是我们要远程连接到Linux系统，如果ip地址经常变化我们就要频繁修改适配很麻烦</p>
<p>原因2：在配置虚拟机ip地址和主机名的映射，如果ip频繁更改，我们需要频繁更新映射关系</p>
<h3 id="网络请求和下载"><a href="#网络请求和下载" class="headerlink" title="网络请求和下载"></a>网络请求和下载</h3><h4 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">可以通过ping命令检查指定的网络服务器是否是可联通状态</span><br><span class="line">    语法：ping [-c num] ip或主机名</span><br><span class="line">    选项：-c，检查的次数，不使用-c选项，将无限次数持续检查</span><br><span class="line">    参数：ip或主机名，被检查的服务器的ip地址或主机名地址</span><br></pre></td></tr></table></figure>

<h4 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">wget是非交互式的文件下载器，可以在命令行内下载网络文件</span><br><span class="line">    语法：wget [-b] url</span><br><span class="line">    选项：-b，可选，后台下载，会将日志写入到当前工作目录的wget-log文件</span><br><span class="line">    参数：url，下载链接</span><br></pre></td></tr></table></figure>

<p>注意：无论下载是否完成，都会生成要下载的文件。如果下载未完成，请及时删除这个文件</p>
<h4 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">curl可以发送http网络请求，可用于：下载文件，获取信息等</span><br><span class="line">    语法：curl [-O] url</span><br><span class="line">    选项：-O，用于下载文件，当url是下载链接时，可以使用此选项保存文件</span><br><span class="line">    参数：url，要发起请求的网络地址</span><br></pre></td></tr></table></figure>

<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>端口：是设备与外界通讯交流的出入口。端口可以分为：物理端口和虚拟端口两类</p>
<ul>
<li>物理端口：又可称之为接口，是可见的端口，如USB接口，RJ45网口，HDMH端口等</li>
<li>虚拟端口：是指计算机内部的端口，是不可见的，是用来操作系统和外部进行交互使用的</li>
</ul>
<h4 id="虚拟端口作用"><a href="#虚拟端口作用" class="headerlink" title="虚拟端口作用"></a>虚拟端口作用</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">计算机程序之间的通讯，通过IP只能锁定计算机，但是无法锁定具体的程序</span><br><span class="line">通过端口可以锁定计算机上具体的程序，确保程序之间进行沟通</span><br><span class="line">IP地址相当于小区地址，在小区内可以有许多用户(程序)，而门牌号(端口)就是各个住户(程序)的联系地址</span><br></pre></td></tr></table></figure>

<h3 id="端口分类"><a href="#端口分类" class="headerlink" title="端口分类"></a>端口分类</h3><p>Linux系统是一个超大号小区，可以支持65535个端口，这6万多个端口分为3类进行使用：</p>
<ul>
<li>公认端口：1~1023，通常用于一些系统内置或知名程序的预留使用，如SSH服务的22端口，HTTPS服务的443端口，非特殊需要，不要占用这个范围的端口</li>
<li>注册端口：1024~49151，通常可以随意使用，用于松散的绑定一些程序\服务</li>
<li>动态端口：49152~65535，通常不会固定绑定程序，而是当程序对外进行网络链接时，用于临时使用。</li>
</ul>
<p>例：计算机A的微信连接计算机B的微信，A使用的50001即动态端口，临时找一个端口作为出口</p>
<p>计算机B的微信使用端口5678，即注册端口，长期绑定此端口等待别人连接</p>
<h3 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h3><ul>
<li><p>使用namp命令：namp 被查看的IP地址</p>
</li>
<li><p>使用netstat命令，查看指定端口的占用情况</p>
<p>语法：netstat -anp | grep 端口号，安装netstat: apt -y install net-tools</p>
</li>
</ul>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul>
<li>tar zcvf 要生成的压缩包名 压缩材料 -使用gzip方式进行压缩</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zcvf test.tar.gz file1 dir2</span><br><span class="line">z:gzip 压缩  gzip file 生成 file.gz</span><br><span class="line">c:create 创建</span><br><span class="line">v:显示压缩过程(可省略)</span><br><span class="line">f:file 一个压缩文件</span><br></pre></td></tr></table></figure>

<ul>
<li><p>tar jcvf 要生成的压缩包名 压缩材料 -使用bzip2方式进行压缩</p>
</li>
<li><p>rar压缩：rar a -r 压缩包名(带.rar后缀) 压缩材料</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rar a -r testrar.rar stdio.h test.mp3</span><br></pre></td></tr></table></figure>

<ul>
<li>zip压缩：zip -r 压缩包名(带.zip后缀) 压缩材料</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip -r testzip.zip <span class="built_in">dir</span> test.mp3</span><br></pre></td></tr></table></figure>



<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><ul>
<li><p>将压缩命令中的c–&gt;x</p>
</li>
<li><p>tar zxvf 生成的压缩包名 -使用gzip方式进行解压缩</p>
</li>
<li><p>tar jxvf 生成的压缩包名 -使用bzip2方式进行解压缩</p>
</li>
<li><p>rar解压：unrar x 压缩包名(带.rar后缀)</p>
</li>
<li><p>zip解压：unzip -r 压缩包名(带.zip后缀)</p>
</li>
</ul>
<h3 id="gcc编译"><a href="#gcc编译" class="headerlink" title="gcc编译"></a>gcc编译</h3><h4 id="gcc编译四步骤"><a href="#gcc编译四步骤" class="headerlink" title="gcc编译四步骤"></a>gcc编译四步骤</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc编译可以执行程序4步骤：预处理，编译，汇编，链接</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307240847832.png" alt="Snipaste_2023-07-24_08-35-42"></p>
<h4 id="gcc编译常用命令"><a href="#gcc编译常用命令" class="headerlink" title="gcc编译常用命令"></a>gcc编译常用命令</h4><ul>
<li><strong>I：指定头文件所在目录位置</strong>(用来寻找inc下的.h文件)</li>
<li>c：只做预处理，编译，汇编。得到二进制文件</li>
<li>g：编译时添加调试语句(调试语句系统隐藏)。主要支持gdb调试</li>
<li>On：n&#x3D;0~3 编译优化，n越大优化得越多(去除无用代码，默认n&#x3D;2)<strong>(主要用于嵌入式编程)</strong></li>
<li>Wall(warning all)：显示<strong>所有</strong>警告信息(轻重都显示)</li>
<li>D<DEF>：向程序中的”动态”注册宏定义。(可以直接输出宏)</li>
<li>l：指定动态库库名</li>
<li>L：指定动态库路径</li>
</ul>
<h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><h4 id="静态库制作"><a href="#静态库制作" class="headerlink" title="静态库制作"></a>静态库制作</h4><ol>
<li>将 .c 生成 .o 文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c add.c -o add.o</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用ar 工具制作静态库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ar rcs lib库名.a add.o sub.o...</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编译静态库到可执行文件中</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc test.c lib库名.a -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h4 id="头文件守卫：防止头文件被重复包含"><a href="#头文件守卫：防止头文件被重复包含" class="headerlink" title="头文件守卫：防止头文件被重复包含"></a>头文件守卫：防止头文件被重复包含</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HEAD_H_</span></span><br><span class="line">.......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><h4 id="动态库制作"><a href="#动态库制作" class="headerlink" title="动态库制作"></a>动态库制作</h4><ol>
<li>将 .c 生成 .o 文件，(生成与位置无关的代码 -fPIC)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c add.c -o add.o -fPIC</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 gcc -shared 制作动态库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -shared -o lib库名.so add.o sub.o</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编译可执行程序时，指定所使用的动态库。 -l：指定库名(去掉lib前缀和.so后缀)  -L：指定库路径。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc test.c -o a.out -lmymath -L./lib</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>运行可以执行程序 .&#x2F;a.out 出错!  !  !</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">原因：链接器：工作于链接阶段，工作时需要 -l 和 -L</span><br><span class="line">     动态链接器：工作于程序运行阶段，工作时需要提供动态库所在目录位置</span><br><span class="line">解决方式：     </span><br><span class="line">     (1)通过环境变量：<span class="built_in">export</span> LD_LIBRARY_PATH=动态库路径</span><br><span class="line">     ./a.out 成功! ! ! (临时生效，终端重启环境变量失效)</span><br><span class="line">     (2)永久生效：写入 终端配置文件。 .bashrc</span><br><span class="line">     1.vi ~/.bashrc</span><br><span class="line">     2.写入<span class="built_in">export</span> LD_LIBRARY_PATH=动态库路径(建议使用绝对路径) 保存</span><br><span class="line">     3.. .bashrc | <span class="built_in">source</span> .bashrc | 重启终端 --&gt; 让修改后的.bashrc 生效</span><br><span class="line">     4../a.out成功! ! !</span><br><span class="line">     (3)拷贝自定义动态库到/lib(标准C库所在目录位置)</span><br><span class="line">     (4)配置文件法</span><br><span class="line">     1.sudo vim /etc/ld.so.conf</span><br><span class="line">     2.写入 动态库绝对路径 保存</span><br><span class="line">     3.sudo ldconfig -v 使配置文件生效</span><br><span class="line">     4../a.out 成功 ! ! ! ---使用 ldd a.out查看</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202309301600857.png" alt="Snipaste_2023-07-25_15-31-39"></p>
<h3 id="数据段合并"><a href="#数据段合并" class="headerlink" title="数据段合并"></a>数据段合并</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202309301601021.png" alt="Snipaste_2023-07-28_09-23-10"></p>
<h3 id="gdb调试-调试逻辑错误"><a href="#gdb调试-调试逻辑错误" class="headerlink" title="gdb调试(调试逻辑错误)"></a>gdb调试(调试逻辑错误)</h3><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><ul>
<li>-g：使用该参数编译可以执行文件，得到调试表</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb a.out</span><br></pre></td></tr></table></figure>

<ul>
<li>list(l)：list 1 列出源码。根据源码<strong>指定行号</strong>设置断点</li>
<li><strong>start：从第一行开始执行源码</strong></li>
<li>breakpoint(b)：b 20  在20行位置设置断点</li>
<li>run(r)：运行程序</li>
<li>next(n)：下一条指令(会越过函数)</li>
<li>step(s)：下一条指令(会进入函数)</li>
<li>print(p)：p i 查看变量的值</li>
<li>continue：继续执行断点后续指令</li>
<li>quit：退出当前gdb调试</li>
</ul>
<h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><ul>
<li>run：使用run查找段错误出现位置</li>
<li>finish：结束当前函数调用</li>
<li>set args：设置main函数命令行参数**(在run | start 之前做)**</li>
<li>run 字符串1 字符串2…：设置main函数命令行参数</li>
<li>info b：查看断点信息表</li>
<li>b 20 if i&#x3D;5：设置条件断点</li>
<li>ptype：查看变量类型</li>
<li>backtrace(bt)：列出当前程序正存活着的栈帧</li>
<li>frame：根据栈帧编号，切换栈帧</li>
<li>display：设置持续跟踪变量(display i)</li>
<li>undisplay：取消设置的跟踪变量。undisplay 1(使用跟踪变量的编号)</li>
</ul>
<h3 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h3><ul>
<li><p>作用：项目编译管理  提高编译效率  降低编译出错概率</p>
</li>
<li><p>命名：makefile  Makefile(可以默认使用make命令)</p>
</li>
<li><p>1个规则：</p>
</li>
</ul>
<p>​                     目标:依赖条件(目标：欲生成的文件  依赖：生成目标的原材料)</p>
<p>​                                 (一个tab缩进)命令  (tab命令：生成手段，方法)</p>
<pre><code>                 1. 目标的时间必须晚于依赖条件的时间，否则，更新目标
                 2. 依赖条件如果不存在，找寻新的规则去产生依赖条件 
</code></pre>
<ul>
<li>ALL：指定makefile的终极目标</li>
<li>2个函数：</li>
</ul>
<p>​                    src&#x3D;$(wildcard .&#x2F;*.c)：匹配当前工作目录下的所有.c文件。将文件组成列表，赋值给变量src。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">src=add.c sub.c</span><br></pre></td></tr></table></figure>

<p>​                    obj&#x3D;$(patsubst %.c,%.o,$(src))：将参数3中，包含参数1的部分，替换为参数2.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">obj=add.o sub.o</span><br></pre></td></tr></table></figure>

<p>​                    clean:(没有依赖)   (如果当前文件夹存在clean目录，make clean失败，此时必须加到伪目标中)</p>
<p>​                     	-rm -rf $(obj) a.out</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;-rm 中 -&quot;</span>作用是：删除不存在的文件时，不报错。顺序执行结束</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>make clean -n(可以展示要执行的代码，并不会执行)</strong></li>
<li>3个自动变量：</li>
</ul>
<p>​                      $@：在规则的命令中，表示规则中的目标</p>
<p>​                      $^：在规则的命令中，表示所有依赖条件</p>
<p>​                      $&lt;：在规则的命令中，表示第一个依赖条件。如果将该变量应用到模式规则中，它可将依赖条件列表中的依赖依次取出，套用模式规则。</p>
<ul>
<li>手动变量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">foo=abc(给出变量值)</span><br><span class="line">bar=$(foo)(索引变量值)</span><br></pre></td></tr></table></figure>

<ul>
<li>库变量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CC</span><br><span class="line">CPPFLAGS</span><br><span class="line">CFLAGS</span><br><span class="line">LDFLAGS</span><br></pre></td></tr></table></figure>

<ul>
<li>模式规则：(%通配符，只匹配参数名，不匹配路径)</li>
</ul>
<p>​                      %.o:%.c</p>
<p>​                       	gcc -c $&lt; -o %@</p>
<ul>
<li>静态模式规则：(表示对哪一个依赖条件套用模式规则)防止有多个规则时的误解，用以区分</li>
</ul>
<p>​                       $(obj):%.o:%.c</p>
<p>​                       	gcc -c $&lt; -o %@</p>
<ul>
<li><p>伪目标：</p>
<p>​                 .PHONY: clean ALL(不用生成文件，但要执行这个规则)</p>
</li>
<li><p>参数：</p>
<p>​                -n：模拟执行make，make clean 命令</p>
<p>​                -f：指定文件执行make命令 (若文件名不是makefile | Makefile时使用)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -f 文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>当文件夹有多个main函数时</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">src=$(wildcard *.c)</span><br><span class="line">obj=$(patsubst %.c,%.o,$(src))</span><br><span class="line">executables=$(patsubst %.c,%,$(src))</span><br><span class="line"></span><br><span class="line">myArgs= -Wall -g</span><br><span class="line"></span><br><span class="line">all: $(executables)</span><br><span class="line"></span><br><span class="line">%: %.o</span><br><span class="line">        gcc $^ -o $@ $(myArgs)</span><br><span class="line"></span><br><span class="line">$(obj): %.o: %.c</span><br><span class="line">        gcc -c $&lt; -o $@ $(myArgs)</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        -rm -rf $(obj) $(executables)</span><br><span class="line"></span><br><span class="line">.PHONY: clean all</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202307311611857.png" alt="image-20230731161109706"></p>
<h3 id="open-x2F-close函数"><a href="#open-x2F-close函数" class="headerlink" title="open&#x2F;close函数"></a>open&#x2F;close函数</h3><h4 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h4><ul>
<li>int open(const char *pathname,int flags);</li>
<li>int open(const char *pathname,int flags,mode_t mode);  &#x2F;&#x2F;mode_t 存储八进制整型(参数2指定了0_CREATE)</li>
<li>int close(int fd);  &#x2F;&#x2F;成功返回0   失败返回-1  并设置  errno</li>
</ul>
<h4 id="常用参数-flags取值"><a href="#常用参数-flags取值" class="headerlink" title="常用参数(flags取值)"></a>常用参数(flags取值)</h4><ul>
<li>O_RDONLY  O_WRONLY  O_RDWR(选其一)</li>
<li>O_APPEND  O_CREATE  O_EXCL(是否存在)  O_TRUNC(截断，截断后文件大小为0)  O_NONBLOCK(附加选项)</li>
<li>创建文件时，指定文件访问权限。权限同时受umask影响。结论为：<strong>文件的权限&#x3D;mode &amp; ~umask</strong>(775)(使用头文件：&lt;fcntl.h&gt;)</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>成功：返回打开文件所得到对应的 文件描述符 (整数)</li>
<li>失败：返回**-1<strong>，并设置一个</strong>errno**(头文件为errno.h)。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>;  <span class="comment">//可以展示出errno所对应的信息</span></span><br></pre></td></tr></table></figure>

<h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span>   <span class="comment">//前两个可以使用#include&lt;unistd.h&gt;代替</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span>    </span></span><br></pre></td></tr></table></figure>

<h4 id="open常见错误："><a href="#open常见错误：" class="headerlink" title="open常见错误："></a>open常见错误：</h4><ol>
<li>打开文件不存在</li>
<li>以写方式打开只读文件(打开文件没有对应的权限)</li>
<li>以只写方式打开目录</li>
</ol>
<ul>
<li>错误处理函数：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;xxx error: %d\n&quot;</span>,errno);</span><br><span class="line"></span><br><span class="line">char *strerror(int errnum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;xxx error: %s\n&quot;</span>,strerror(errno));</span><br><span class="line"></span><br><span class="line">void perror(const char *s)</span><br><span class="line">perror(<span class="string">&quot;open error&quot;</span>); //字符串自定义</span><br></pre></td></tr></table></figure>

<h4 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h4><ul>
<li>ssize_t read(int fd , void *buf , size_t count);  (第一个s表符号)</li>
<li>参数：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fd: 文件描述符</span><br><span class="line">buf: 存数据的缓冲区</span><br><span class="line">count: 缓冲区大小</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值：</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0：读到文件末尾</span><br><span class="line">成功：读到的字节数</span><br><span class="line">失败：-1 设置errno</span><br><span class="line">-1：并且errno=EAGIN 或 EWOULDBLOCK，说明<span class="built_in">read</span>在以非阻塞方式读一个设备文件(网络文件)，并且文件无数据。(不是<span class="built_in">read</span>失败)</span><br></pre></td></tr></table></figure>

<h4 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h4><ul>
<li>*<em>ssize_t write(int fd , const void <em>buf , size_t count);</em></em>  (第一个s表符号)</li>
<li>参数：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fd: 文件描述符</span><br><span class="line">buf: 待写出数据的缓冲区</span><br><span class="line">count: 数据大小</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">成功：写入的字节数</span><br><span class="line">失败：-1 设置errno</span><br></pre></td></tr></table></figure>

<h4 id="系统调用和库函数的比较"><a href="#系统调用和库函数的比较" class="headerlink" title="系统调用和库函数的比较"></a>系统调用和库函数的比较</h4><h5 id="strace命令"><a href="#strace命令" class="headerlink" title="strace命令"></a>strace命令</h5><p>strace是一个用于跟踪系统调用的命令行工具。它可以让你查看一个程序执行期间发生的系统调用，包括打开文件、读写文件、网络通信等。通过跟踪系统调用，你可以了解程序在底层的操作和行为。</p>
<p>strace的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strace [选项] [命令 [参数...]]</span><br></pre></td></tr></table></figure>

<p>常用选项包括：</p>
<ul>
<li><code>-p &lt;进程ID&gt;</code>：跟踪指定进程ID的系统调用。</li>
<li><code>-o &lt;输出文件&gt;</code>：将跟踪结果输出到指定文件。</li>
<li><code>-e &lt;系统调用&gt;</code>：指定需要跟踪的系统调用，多个系统调用之间用逗号分隔。</li>
<li><code>-c</code>：统计每个系统调用的次数和时间。</li>
<li><code>-s &lt;最大字符串长度&gt;</code>：限制显示的字符串长度。</li>
<li><code>-f</code>：跟踪由fork创建的子进程。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strace -o output.txt ls -l</span><br></pre></td></tr></table></figure>
<p>上述命令将跟踪执行ls -l命令时发生的系统调用，并将结果输出到output.txt文件中。</p>
<p>strace是一个强大的工具，可以帮助开发人员和系统管理员调试和分析应用程序的行为。通过查看系统调用，你可以了解程序的执行过程和底层操作，从而更好地理解和解决问题。</p>
<h5 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h5><ul>
<li>read，write函数常常被称为Unbuffered I&#x2F;O。(指的是无用户及缓冲区，但不保证不使用内核缓冲区)</li>
</ul>
<h5 id="预读入缓输出"><a href="#预读入缓输出" class="headerlink" title="预读入缓输出"></a>预读入缓输出</h5><ul>
<li><strong>用户空间到内核空间时间消耗大</strong>。(只有系统调用才能进内核空间(例如：write，read))。</li>
<li>fputc在用户空间有缓冲区，缓满4096才调用write进入内核。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308032030214.png" alt="Snipaste_2023-08-03_17-33-25"></p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><ul>
<li>PCB进程控制块：本质  结构体</li>
<li>成员：文件描述符表</li>
<li>文件描述符：0&#x2F;1&#x2F;……&#x2F;1023</li>
</ul>
<ol>
<li>STDIN_FILENO   &#x2F;&#x2F;标准输入</li>
<li>STDOUT_FILENO   &#x2F;&#x2F;标准输出</li>
<li>STDERR_FILENO  &#x2F;&#x2F;标准错误</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308040937536.png" alt="Snipaste_2023-08-03_21-55-25"></p>
<ul>
<li>文件描述符key所对应的value：是指向文件结构体的指针</li>
</ul>
<h3 id="阻塞，非阻塞-设备文件，网络文件的属性"><a href="#阻塞，非阻塞-设备文件，网络文件的属性" class="headerlink" title="阻塞，非阻塞(设备文件，网络文件的属性)"></a>阻塞，非阻塞(设备文件，网络文件的属性)</h3><ul>
<li><strong>产生阻塞的场景。</strong>读设备文件。读网络文件。(读常规文件无阻塞概念)</li>
<li>&#x2F;dev&#x2F;tty  –  终端文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">open(<span class="string">&quot;/dev/tty&quot;</span>,O_RDWR | O_NONBLOCK	)  --设置/dev/tty非阻塞状态。(默认为阻塞状态)</span><br></pre></td></tr></table></figure>

<h3 id="fcntl改文件属性"><a href="#fcntl改文件属性" class="headerlink" title="fcntl改文件属性"></a>fcntl改文件属性</h3><ul>
<li><strong>int flags&#x3D;fcntl(fd,F_GETFL);</strong></li>
<li>flags |&#x3D; O_NONBLOCK</li>
<li><strong>fcntl(fd,F_SETFL,flags)</strong></li>
<li>获取文件状态：F_GETFL</li>
<li>设置文件状态：F_SETFL</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"></span><br><span class="line">int fcntl(int fd, int cmd, ... /* arg */);</span><br><span class="line">功能：改变已打开的文件性质，fcntl针对描述符提供控制。</span><br><span class="line">参数：</span><br><span class="line">    fd：操作的文件描述符</span><br><span class="line">    cmd：操作方式</span><br><span class="line">    arg：针对cmd的值，fcntl能够接受第三个参数int arg。</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回某个其他值</span><br><span class="line">    失败：-1</span><br></pre></td></tr></table></figure>

<p><strong>fcntl函数有5种功能：</strong></p>
<ol>
<li><p>复制一个现有的描述符（cmd&#x3D;F_DUPFD）</p>
</li>
<li><p>获得／设置文件描述符标记(cmd&#x3D;F_GETFD或F_SETFD)</p>
</li>
<li><p>获得／设置文件状态标记(cmd&#x3D;F_GETFL或F_SETFL)</p>
</li>
<li><p>获得／设置异步I&#x2F;O所有权(cmd&#x3D;F_GETOWN或F_SETOWN)</p>
</li>
<li><p>获得／设置记录锁(cmd&#x3D;F_GETLK, F_SETLK或F_SETLKW)</p>
</li>
</ol>
<h3 id="lseek函数-修改文件偏移量"><a href="#lseek函数-修改文件偏移量" class="headerlink" title="lseek函数(修改文件偏移量)"></a>lseek函数(修改文件偏移量)</h3><ul>
<li><strong>off_t lseek(int fd,off_t offset,int whence);</strong></li>
<li>参数：</li>
</ul>
<ol>
<li>fd：文件描述符</li>
<li>offset：偏移量(off_t 矢量值，可以往前偏也可以往后偏)</li>
<li>whence：设置起始偏移位置：SEEK_SET | SEEK_CUR | SEEK_END</li>
</ol>
<ul>
<li>返回值：</li>
</ul>
<ol>
<li>成功：较起始位置偏移量</li>
<li>失败：-1 errno</li>
</ol>
<ul>
<li>应用场景：</li>
</ul>
<ol>
<li><em><strong>文件的”读”，”写”使用同一偏移位置</strong></em></li>
<li><strong>使用lseek获取文件大小</strong>：int length&#x3D;lseek(fd,0,SEEK_END);</li>
<li><strong>使用lseek拓展文件大小</strong>：lseek(fd,111,SEEK_END) -此时文件大小并未真正改变，要想使文件大小真正拓展，<strong>必须引起IO操作</strong> (如调write函数)</li>
</ol>
<ul>
<li>使用truncate函数。直接拓展文件。 int ret&#x3D;truncate(“dict.cp”,250); </li>
<li>使用ftruncate函数。int ret &#x3D; ftruncate(fd , 250);</li>
<li><strong>od-tcx filename  查看文件的16进制表示形式</strong></li>
<li><strong>od-tcd filename  查看文件的10进制表示形式</strong></li>
</ul>
<h3 id="传入传出参数"><a href="#传入传出参数" class="headerlink" title="传入传出参数"></a>传入传出参数</h3><ul>
<li><p>char *strcpy(char *dest,const char *src);</p>
</li>
<li><p><strong>传入参数：第二个参数</strong></p>
</li>
</ul>
<ol>
<li>指针作为函数参数</li>
<li>通常有const关键字修饰</li>
<li>指针指向有效区域，在函数内部做读操作</li>
</ol>
<ul>
<li><strong>传出参数：第一个参数</strong></li>
</ul>
<ol>
<li>指针作为函数参数</li>
<li>在函数调用之前，指针指向的空间可以无意义，但必须有效</li>
<li>在函数内部，做写操作</li>
<li>函数调用结束后，充当函数返回值</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void aaa();</span><br><span class="line">int aaa(int *p,struct <span class="built_in">stat</span> *p2,struct student *p3);</span><br><span class="line"><span class="function"><span class="title">bb</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    aaa();</span><br><span class="line">&#125;</span><br><span class="line">1.给b赋值，如果无传出参数充当返回值，返回一个数</span><br><span class="line">2.有传出参数充当返回值，返回4个数，但传出参数不是返回值</span><br></pre></td></tr></table></figure>

<ul>
<li><p>char *strtok(char *str,const char *delim,char **saveptr);</p>
</li>
<li><p><strong>传入传出参数：第三个参数</strong></p>
</li>
</ul>
<ol>
<li>指针作为函数参数</li>
<li>在函数调用之前，指针指向的空间有实际意义</li>
<li>在函数内部，先做读操作，后做写操作</li>
<li>函数调用结束后，充当函数返回值</li>
</ol>
<h3 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h3><h4 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h4><ul>
<li>其<strong>本质为结构体</strong>，存储文件的属性信息(ls -l查看的信息)。如：权限，类型，大小，时间，用户，<em><strong>盘块位置</strong></em>…也叫作<strong>文件属性管理结构</strong>，大多数的inode都存储在磁盘上。</li>
<li>少量使用、近期使用的inode会被缓存在内存中。</li>
</ul>
<h4 id="dentry"><a href="#dentry" class="headerlink" title="dentry"></a>dentry</h4><ul>
<li><strong>目录项</strong>，其本质依然是结构体，重要的、成员变量有两个{文件名，inode,…}，而文件内容(data)保存在磁盘盘块中。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308061451906.png" alt="Snipaste_2023-08-06_10-57-03"></p>
<ul>
<li><strong>硬链接时，dentry不同，inode相同。</strong>删除一个硬链接，减少一个dentry，全部删除，磁盘空间不会被擦除。磁盘空间只能被覆盖。</li>
</ul>
<h3 id="stat-x2F-lstat函数"><a href="#stat-x2F-lstat函数" class="headerlink" title="stat&#x2F;lstat函数"></a>stat&#x2F;lstat函数</h3><ul>
<li><strong>获取文件属性(从inode结构体中获取)</strong></li>
</ul>
<h4 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h4><ul>
<li>**int stat(const char <em>path,struct stat <em>buf);</em></em> (包含头文件 #include&lt;sys&#x2F;stat.h&gt; <strong>手动创建结构体 struct stat buf)</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">参数：</span><br><span class="line">   path：文件路径</span><br><span class="line">   buf：(传出参数) 存放文件属性</span><br><span class="line">返回值：</span><br><span class="line">   成功：0</span><br><span class="line">   失败：-1 errno</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>获取文件大小</strong>：buf.st_size</li>
<li><strong>获取文件类型</strong>：buf.st_mode</li>
<li><strong>获取文件权限</strong>：buf.st_mode</li>
</ul>
<h4 id="lstat函数"><a href="#lstat函数" class="headerlink" title="lstat函数"></a>lstat函数</h4><ul>
<li>**int lstat(char <em>path,struct stat <em>buf);</em></em></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">成功：返回0</span><br><span class="line">失败：返回-1 设置errno</span><br></pre></td></tr></table></figure>

<ul>
<li>文件类型判断方法：st_mode 取高4位。但应使用宏函数：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">S_ISREG(m)		is it a regular file?</span><br><span class="line">S_ISDIR(m)		directory?</span><br><span class="line">S_ISCHR(m)		character device?</span><br><span class="line">S_ISBLK(m)		block device?</span><br><span class="line">S_ISFIFO(m)		FIFO(named pipe)</span><br><span class="line">S_ISLNK(m)		symbolic <span class="built_in">link</span>? (Not <span class="keyword">in</span> POSIX.1-1996)</span><br><span class="line">S_ISSOCK(m)		socket? (Not <span class="keyword">in</span> POSIX.1-1996)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>穿透符号链接：stat：会；lstat：不会</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./stat f.soft  //is a reguctor</span><br><span class="line">./lstat f.soft //is a symbolic <span class="built_in">link</span></span><br></pre></td></tr></table></figure>

<h3 id="link和unlink隐式回收"><a href="#link和unlink隐式回收" class="headerlink" title="link和unlink隐式回收"></a>link和unlink隐式回收</h3><h4 id="link函数-可以为已经存在的文件创建目录项-硬链接"><a href="#link函数-可以为已经存在的文件创建目录项-硬链接" class="headerlink" title="link函数(可以为已经存在的文件创建目录项(硬链接))"></a>link函数(可以为已经存在的文件创建目录项(硬链接))</h4><ul>
<li>**int link(const char <em>oldpath , const char <em>newpath)</em></em>   –  可以为已经存在的文件创建目录项(硬链接)</li>
</ul>
<ol>
<li>成功：0</li>
<li>失败：-1 设置errno</li>
</ol>
<h4 id="unlink函数-删除一个文件的目录项"><a href="#unlink函数-删除一个文件的目录项" class="headerlink" title="unlink函数(删除一个文件的目录项)"></a>unlink函数(删除一个文件的目录项)</h4><ul>
<li>*<em>int unlink(const char <em>pahname);</em></em></li>
</ul>
<ol>
<li>成功：0</li>
<li>失败：-1 设置errno</li>
</ol>
<ul>
<li>Linux下删除文件的机制</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不断将st_nlink -1，直至减到0为止。无目录项对应的文件，将会被操作系统择机释放。(具体时间由系统内部调度算法决定)</span><br><span class="line">因此，我们删除文件，从某种意义上说，只是让文件具备了被释放的条件</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>unlink函数的特征：</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">清楚文件时，如果文件的硬链接数到0了，没有dentry对应，但该文件仍不会马上被释放。要等到所有打开该文件的进程关闭该文件，系统才会挑时间将该文件释放掉。</span><br></pre></td></tr></table></figure>

<h4 id="隐式回收"><a href="#隐式回收" class="headerlink" title="隐式回收"></a>隐式回收</h4><ul>
<li>当进程结束运行时，所有该进程打开的文件会被关闭，申请的内存空间会被释放。系统的这一特性称之为隐式回收系统资源。</li>
</ul>
<h4 id="readlink函数-读取符号链接文件本身内容，得到链接所指向的文件名"><a href="#readlink函数-读取符号链接文件本身内容，得到链接所指向的文件名" class="headerlink" title="readlink函数(读取符号链接文件本身内容，得到链接所指向的文件名)"></a>readlink函数(读取符号链接文件本身内容，得到链接所指向的文件名)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /.home/wzhvv/a a.soft</span><br><span class="line"><span class="built_in">readlink</span> a.soft  --&gt;  /.home/wzhvv/a</span><br></pre></td></tr></table></figure>

<ul>
<li>**ssize_t  readlink(const char <em>path , char <em>buf,size_t bufsiz);</em></em> –&gt; 读到的内容放到buf缓冲区</li>
</ul>
<ol>
<li>成功：返回实际读到的字节数</li>
<li>失败：-1 设置errno</li>
</ol>
<h4 id="rename函数-重命名一个文件"><a href="#rename函数-重命名一个文件" class="headerlink" title="rename函数(重命名一个文件)"></a>rename函数(重命名一个文件)</h4><ul>
<li>**int rename(const char <em>oldpath , const char <em>newpath)</em></em></li>
</ul>
<ol>
<li>成功：0</li>
<li>失败：-1 设置errno</li>
</ol>
<h4 id="getcwd函数-获取当前工作目录-–-gt-相当于pwd"><a href="#getcwd函数-获取当前工作目录-–-gt-相当于pwd" class="headerlink" title="getcwd函数(获取当前工作目录) –&gt; 相当于pwd"></a>getcwd函数(获取当前工作目录) –&gt; 相当于pwd</h4><ul>
<li>**char <em>getcwd(char <em>buf , size_t size);</em></em></li>
</ul>
<ol>
<li>成功：buf中保存当前进程工作目录位置</li>
<li>失败：返回NULL</li>
</ol>
<h4 id="chdir函数-改变当前进程的工作目录-–-gt-相当于cd"><a href="#chdir函数-改变当前进程的工作目录-–-gt-相当于cd" class="headerlink" title="chdir函数(改变当前进程的工作目录) –&gt; 相当于cd"></a>chdir函数(改变当前进程的工作目录) –&gt; 相当于cd</h4><ul>
<li>int chdir(const char *path)</li>
</ul>
<ol>
<li>成功：0</li>
<li>失败：-1 设置errno</li>
</ol>
<h3 id="文件目录权限"><a href="#文件目录权限" class="headerlink" title="文件目录权限"></a>文件目录权限</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308071505544.png" alt="Snipaste_2023-08-07_15-04-37"></p>
<h3 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h3><h4 id="opendir函数-根据传入的目录名打开一个目录-库函数-DIR-类似于-FILE"><a href="#opendir函数-根据传入的目录名打开一个目录-库函数-DIR-类似于-FILE" class="headerlink" title="opendir函数(根据传入的目录名打开一个目录(库函数))		DIR * 类似于 FILE *"></a>opendir函数(根据传入的目录名打开一个目录(库函数))		DIR * 类似于 FILE *</h4><ul>
<li>**DIR <em>opendir(const char <em>name);</em></em>   (头文件 #include&lt;dirent.h&gt;)	–》 directory entry</li>
</ul>
<ol>
<li>成功：返回<strong>指向该目录结构体指针</strong></li>
<li>失败：返回NULL</li>
</ol>
<h4 id="closedir函数-关闭打开的目录"><a href="#closedir函数-关闭打开的目录" class="headerlink" title="closedir函数(关闭打开的目录)"></a>closedir函数(关闭打开的目录)</h4><ul>
<li>*<em>int closedir(DIR <em>dirp)</em></em></li>
</ul>
<ol>
<li>成功：0</li>
<li>失败：-1 设置errno</li>
</ol>
<h4 id="readdir函数-读取目录-库函数"><a href="#readdir函数-读取目录-库函数" class="headerlink" title="readdir函数(读取目录(库函数))"></a>readdir函数(读取目录(库函数))</h4><ul>
<li>**struct dirent <em>readdir(DIR <em>dirp);</em></em></li>
</ul>
<ol>
<li>成功：返回目录项结构体指针</li>
<li>失败：返回NULL 设置errno  <strong>(当读取结束时也返回NULL值，所以应借助errno进一步加以区分)</strong></li>
</ol>
<ul>
<li>struct 结构体：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct dirent&#123;</span><br><span class="line">    ino_t  d_ino;  //inode编号</span><br><span class="line">    ...</span><br><span class="line">    char  d_name[256];  //文件名</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="递归遍历目录：ls-R"><a href="#递归遍历目录：ls-R" class="headerlink" title="递归遍历目录：ls -R"></a>递归遍历目录：ls -R</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 判断命令行参数，获取用户要查询的目录名。	argv[<span class="number">1</span>]</span><br><span class="line">    argc == <span class="number">1</span>	--&gt; ./</span><br><span class="line"><span class="number">2.</span> 判断用户指定的是否是目录。stat S_ISDIR();	--&gt; 封装函数 isFile</span><br><span class="line"><span class="number">3.</span> 读目录：</span><br><span class="line">    opendir(dir)</span><br><span class="line">    <span class="keyword">while</span>(readdir())&#123;</span><br><span class="line">        普通文件，直接打印</span><br><span class="line">        目录：</span><br><span class="line">            拼接目录访问绝对路径。<span class="built_in">sprintf</span>(path,<span class="string">&quot;%s%s&quot;</span>,dir,d_name)</span><br><span class="line">            递归调用自己。--&gt; opendir(path) readdir closedir</span><br><span class="line">    &#125;</span><br><span class="line">	closedir()</span><br></pre></td></tr></table></figure>

<h3 id="dup函数-重定向"><a href="#dup函数-重定向" class="headerlink" title="dup函数(重定向)"></a>dup函数(重定向)</h3><h4 id="dup函数"><a href="#dup函数" class="headerlink" title="dup函数"></a>dup函数</h4><ul>
<li><p><strong>int dup(int oldfd);</strong>   </p>
</li>
<li><p>功能：<strong>通过 oldfd 复制出一个新的文件描述符</strong>，新的文件描述符是调用进程文件描述符表中最小可用的文件描述符，最终 oldfd 和新的文件描述符都指向同一个文件。    </p>
</li>
<li><p>参数：oldfd : 需要复制的文件描述符 oldfd   </p>
</li>
<li><p>返回值：</p>
</li>
</ul>
<p>  成功：新文件描述符<br>  失败： -1</p>
<h4 id="dup2函数-dup-to"><a href="#dup2函数-dup-to" class="headerlink" title="dup2函数 (dup to)"></a>dup2函数 (dup to)</h4><ul>
<li><strong>int dup2(int oldfd, int newfd);</strong>  (头文件 #include &lt;unistd.h&gt;)</li>
<li>功能：<strong>通过 oldfd 复制出一个新的文件描述符 newfd</strong>，<strong>如果成功，newfd 和函数返回值是<em>同一个返回值</em></strong>，最终 oldfd 和新的文件描述符 newfd 都指向同一个文件。    </li>
<li>参数：<br>    oldfd : 需要复制的文件描述符<br>     newfd : 新的文件描述符，这个描述符可以人为指定一个合法数字（0 - 1023），如果指定的数字已经被占用（和某个文件有关联），此函数会自动关闭 close() 断开这个数字和某个文件的关联，再来使用这个合法数字。</li>
<li>返回值：<br>        成功：返回 newfd<br>        失败：返回 -1</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li>程序：死的。只占用磁盘空间。  –剧本</li>
<li>进程：活的。运行起来的程序。占用内存，cpu等系统资源。  –戏</li>
</ul>
<h3 id="PCB进程控制块"><a href="#PCB进程控制块" class="headerlink" title="PCB进程控制块"></a>PCB进程控制块</h3><ol>
<li>进程id</li>
<li>文件描述符</li>
<li>进程状态： 初始态  就绪态  运行态  挂起态  终止态</li>
<li>进程工作目录位置</li>
<li>umask掩码</li>
<li>信号相关信息资源</li>
<li>信号相关信息资源</li>
<li>用户id和组id</li>
</ol>
<h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><ul>
<li>pid_t fork(void);</li>
<li>创建子进程。父子进程各自返回。父进程返回子进程pid。子进程返回0。</li>
<li>getpid()：返回当前进程pid。getppid：返回父进程pid。</li>
<li>循环创建N个子进程模型。每个子进程标识自己的身份。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)   <span class="comment">//循环期间，子进程不fork</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">5</span>==i)&#123;        <span class="comment">//父进程，从表达式2跳出</span></span><br><span class="line">    <span class="comment">//sleep(5);</span></span><br><span class="line">    wait(<span class="literal">NULL</span>);  <span class="comment">//一次wait/waitpid函数调用，只能回收一个进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I`m parent\n&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;           <span class="comment">//子进程，从break跳出</span></span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I`m %dth child\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="父子进程相同："><a href="#父子进程相同：" class="headerlink" title="父子进程相同："></a>父子进程相同：</h4><ul>
<li>刚fork后。data段，text段，堆，栈，环境变量，全局变量，宿主目录位置，进程工作目录位置，信号处理方式</li>
</ul>
<h4 id="父子进程不同："><a href="#父子进程不同：" class="headerlink" title="父子进程不同："></a>父子进程不同：</h4><ul>
<li>进程id，返回值，各自的父进程，进程创建时间，闹钟，未决信号集</li>
</ul>
<h4 id="父子进程共享："><a href="#父子进程共享：" class="headerlink" title="父子进程共享："></a>父子进程共享：</h4><ul>
<li><strong>读时共享，写时复制。</strong>—–   全局变量</li>
</ul>
<ol>
<li>文件描述符</li>
<li>mmap映射区</li>
</ol>
<h4 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h4><p>使用gdb调试的时候，gdb只能跟踪一个进程。可以在fork函数调用之前，通过指令设置gdb调试工具跟踪父进程或者是跟踪子进程。<strong>默认跟踪父进程。</strong></p>
<ul>
<li>set follow-fork-mode child 命令设置gdb在fork之后跟踪子进程。</li>
<li>set follow-fork-mode parent 设置跟踪父进程</li>
</ul>
<p><em><strong>注意：一定要在fork函数调用之前设置才有效。</strong></em></p>
<h3 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h3><ul>
<li>fork创建子进程后执行的是和父进程相同的程序(但有可能执行不同的代码分支)，子进程往往要调用exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。</li>
<li>将当前进程的.text,.data替换为所要加载的程序的.text,.data，然后让进程从新的.text第一条指令开始执行，但进程id不变，换核不换壳。</li>
</ul>
<h4 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a>execlp函数</h4><ul>
<li>加载一个进程，借助PATH环境变量</li>
<li>int execlp(const char *file , const char *arg , ….);</li>
</ul>
<ol>
<li>成功：无返回</li>
<li>失败：-1</li>
</ol>
<ul>
<li>参数1：要加载的程序的名字。该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数1则出错返回。</li>
<li>该函数通常用来调用系统程序。如：ls，date，cp，cat等指令。</li>
</ul>
<h4 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a>execl函数</h4><ul>
<li>加载一个进程，通过  路径名+程序名  来加载</li>
<li>int execl(const char *path , const char *arg , ….);</li>
</ul>
<ol>
<li>成功：无返回</li>
<li>失败：-1</li>
</ol>
<ul>
<li>对比execlp，如加载 ls 命令带有 -l ，-F参数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-F&quot;</span>,NULL);          //使用程序名在PATH中搜索   哨兵：NULL</span><br><span class="line">execlp(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-F&quot;</span>,NULL);     //使用参数1给出的绝对路径搜索      </span><br></pre></td></tr></table></figure>

<h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><ul>
<li>孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为 init 进程，称为init进程领养的孤儿。</li>
</ul>
<h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><ul>
<li>僵尸进程：进程终止，父进程尚未回收，子进程残留资源(PCB)存放于内核中，变成僵尸(Zombie)进程。</li>
<li>特别注意：僵尸进程不能使用kill命令消除掉。因为kill命令只用来终止进程的，而僵尸进程已经终止。(可通过杀死父进程，让init来回收子进程)</li>
</ul>
<h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h4><ul>
<li>一个进程在终止时会关闭所有的文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着<strong>导致该进程终止的信号</strong>是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid都得到它的退出状态同时彻底清除掉这个进程。</span><br></pre></td></tr></table></figure>

<ul>
<li>父进程调用wait函数可以回收子进程终止信息。该函数有<strong>三个功能</strong>：</li>
</ul>
<ol>
<li>阻塞等待子进程退出</li>
<li>回收子进程残留资源</li>
<li>获取子进程结束状态(退出原因)</li>
</ol>
<ul>
<li><em><em>pid_t wait(int <em>status);</em></em>     &#x2F;&#x2F;status为</em><strong>传出</strong><em>参数，*<em>回收进程状态</em></em>    (传NULL，不关心子进程结束原因)</li>
</ul>
<ol>
<li>成功：清理掉的<strong>子进程ID</strong></li>
<li>失败：-1(没有子进程)</li>
</ol>
<ul>
<li>当进程终止时，<strong>操作系统的隐式回收进制</strong>会：1.关闭所有文件描述符 2.释放用户空间分配的内存。</li>
<li>内核的PCB仍存在。其中保存该进程的退出状态。(正常终止 -&gt; 退出值 ；异常终止 -&gt; 终止信号)</li>
<li>可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组：</li>
</ul>
<ol>
<li><p><strong>WIFEXITED(status)</strong>  为非0  → 进程正常结束</p>
<p><strong>WEXITSTATUS(status)</strong> 如上宏为真，使用此宏 → 获取进程退出状态(exit的参数) —  子进程的返回值。</p>
</li>
<li><p><strong>WIFSIGNALED(status)</strong> 为非0 → 进程异常终止  <strong>(信号终止)</strong></p>
<p><strong>WTERMSIG(status)</strong> 如上宏为真，使用此宏 → <strong>取得使进程终止的那个信号的编号</strong>。</p>
</li>
<li><p><strong>WIFSTOPPED(status)</strong> 为非0  →  进程处于暂停状态</p>
<p><strong>WSTOPSIG(status)</strong> 如上宏为真，使用此宏  → 取得使进程暂停的那个信号的编号。</p>
<p><strong>WIFCONTINUED(status)</strong> 为真  → 进程暂停后已经继续运行</p>
</li>
</ol>
<h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h4><ul>
<li>作用同wait，但可指定pid进程清理，可以不阻塞。</li>
<li>*<em>pid_t waitpid(pid_t pid,int <em>status,int options);</em></em></li>
<li>返回值：</li>
</ul>
<ol>
<li>(&gt;0)：表成功回收的子进程pid</li>
<li>(0)：函数调用时，参3指定了WNOHANG，并且，没有子进程结束</li>
<li>(-1)：失败。errno</li>
</ol>
<p><strong>特殊参数和返回情况：</strong></p>
<ul>
<li>参数pid：</li>
</ul>
<ol>
<li>(&gt;0) 回收指定ID的进程</li>
<li>(-1) 回收任意子进程(相当于wait)</li>
<li>(0) 回收和当前调用waitpid<em><strong>一个组</strong></em>的所有子进程  <strong>此时 参3 为WNOHANG，且子进程正在运行</strong></li>
<li>(&lt;-1) 回收指定<em><strong>进程组</strong></em>内的任意子进程  <strong>(进程id取反)</strong></li>
</ol>
<ul>
<li><em><strong>注意：</strong></em>一次wait 或 waitpid 调用只能清理一个子进程，清理多个子进程应使用循环。</li>
<li>参数status：**(传出)** 回收进程的状态</li>
<li>参数options：WNOHANG 指定回收方式为：非阻塞    0：阻塞</li>
</ul>
<p><strong>总结：wait，waitpid一次调用，回收一个子进程。想回收多个：用while。</strong></p>
<h3 id="进程间通信常见方式"><a href="#进程间通信常见方式" class="headerlink" title="进程间通信常见方式"></a>进程间通信常见方式</h3><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308190931519.png" alt="Snipaste_2023-08-15_15-50-37"></p>
<ul>
<li>现今常用的进程间通信方式有：</li>
</ul>
<ol>
<li>管道 (使用最简单)</li>
<li>信号 (开销最小)</li>
<li>共享映射区 (无血缘关系)</li>
<li>本地套接字 (最稳定)</li>
</ol>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><h4 id="管道的概念"><a href="#管道的概念" class="headerlink" title="管道的概念"></a>管道的概念</h4><ul>
<li>管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据的传递。调用pipe系统函数即可创建一个管道。有如下特质：</li>
</ul>
<ol>
<li>其本质是一个伪文件 (实为内核缓冲区)</li>
<li>由两个文件描述符引用，一个表示读端，一个表示写端</li>
<li>规定数据从管道的写端写入管道，从读端流出</li>
</ol>
<ul>
<li>管道的原理：管道实为内核使用<strong>环形队列机制</strong>，借助内核缓冲区(4k)实现</li>
<li>管道的局限性：</li>
</ul>
<ol>
<li>数据不能进程自己写，自己读</li>
<li>管道中数据不可反复读取。一但读走，管道中不再存在</li>
<li>采用半双工通信方式，数据只能在单方向上流动</li>
<li>只能在有公共祖先的进程间使用管道</li>
</ol>
<ul>
<li><strong>常用的通信方式有：单工通信：电视  半双工通信：对讲机  全双工通信：电话</strong></li>
</ul>
<h4 id="管道基本用法"><a href="#管道基本用法" class="headerlink" title="管道基本用法"></a>管道基本用法</h4><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308190931599.png" alt="Snipaste_2023-08-16_10-20-22"></p>
<ul>
<li>pipe函数：创建，并打开管道</li>
<li>int pipe(int fd[2]);</li>
<li>参数：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fd[0]；读端</span><br><span class="line">fd[1]：写端</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">成功：0</span><br><span class="line">失败：-1 errno</span><br></pre></td></tr></table></figure>

<h4 id="管道读写行为"><a href="#管道读写行为" class="headerlink" title="管道读写行为"></a>管道读写行为</h4><ul>
<li>读管道：</li>
</ul>
<ol>
<li>管道中有数据，read返回实际读到的字节数。</li>
<li>管道中无数据：</li>
</ol>
<p>​                             (1) 管道写端被全部关闭，read返回0 (类似读到文件结尾)</p>
<pre><code>                         (2) 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)
</code></pre>
<ul>
<li>写管道：</li>
</ul>
<ol>
<li><p>管道读端全部被关闭，进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)</p>
</li>
<li><p>管道读端没有全部关闭：</p>
<p>​                     (1) 管道已满，write阻塞。</p>
<p>​                     (2)管道未满，write将数据写入，并返回实际写入的字节数。</p>
</li>
</ol>
<h4 id="管道缓冲区大小"><a href="#管道缓冲区大小" class="headerlink" title="管道缓冲区大小"></a>管道缓冲区大小</h4><ul>
<li><p>可以使用 <strong>ulimit -a</strong> 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为：</p>
<p>​		pipe size  				(512 byte , -p)  8</p>
</li>
<li><p>也可以使用 fpathconf 函数，借助参数选项来查看。使用该宏应引入头文件&lt;unistd.h&gt;</p>
<p>​		<strong>long fpathconf(int fd , int name)；</strong></p>
</li>
</ul>
<ol>
<li>成功：返回管道大小</li>
<li>失败：-1 设置errno</li>
</ol>
<h4 id="管道的优劣"><a href="#管道的优劣" class="headerlink" title="管道的优劣"></a>管道的优劣</h4><ul>
<li>优点：简单，相比信号，套接字实现进程间通信，简单很多</li>
<li>缺点：</li>
</ul>
<ol>
<li>只能单向通信，双向通信需建立两个管道</li>
<li>只能用于父子，兄弟进程(有共同祖先)间通信</li>
</ol>
<h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><ul>
<li>FIFO常被称为命名管道，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间。但通过FIFO，不相关的进程也能交换数据。</li>
<li>FIFO是Linux基础文件类型中的一种。但，<strong>FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道</strong>。<em><strong>各进程可以打开这个文件进行read&#x2F;write</strong></em>，实际上是在读写内核通道，这样就实现了进程间通信。</li>
<li>创建方式：</li>
</ul>
<ol>
<li>命令：<strong>mkfifo 管道名</strong></li>
<li>库函数：<em><em>int mkfifo(const char <em>pathname , mode_t mode);</em></em>  成功：0；失败：-1</em><em>(头文件 sys&#x2F;stat.h)</em>*</li>
</ol>
<ul>
<li>一但使用mkfifo创建一个FIFO，就可以使用open打开它，常见的文件I&#x2F;O函数都可用于fifo。如：close，read，write，unlink等</li>
</ul>
<h3 id="存储映射I-x2F-O"><a href="#存储映射I-x2F-O" class="headerlink" title="存储映射I&#x2F;O"></a>存储映射I&#x2F;O</h3><ul>
<li>存储映射I&#x2F;O(Memory-mapped I&#x2F;O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可以不适用read和write函数的情况下，使用地址(指针)完成I&#x2F;O操作。</li>
<li>使用这种方法，首先通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308190931049.png" alt="Snipaste_2023-08-19_09-31-15"></p>
<h4 id="mmap函数-头文件sys-x2F-mman-h"><a href="#mmap函数-头文件sys-x2F-mman-h" class="headerlink" title="mmap函数(头文件sys&#x2F;mman.h)"></a>mmap函数(头文件sys&#x2F;mman.h)</h4><ul>
<li>**void <em>mmap(void <em>addr , size_t length , int prot , int flags , int fd , off_t offset);</em></em>             创建共享内存映射</li>
<li>参数：</li>
</ul>
<ol>
<li>addr：指定映射区的首地址。通常传NULL，表示让系统自动分配</li>
<li>length：共享内存映射区的大小。(&lt;&#x3D;文件的实际大小)</li>
<li>prot：共享内存映射区的读写属性。PROT_READ、PROT_WRITE、PROT_READ | PROT_WRITE</li>
<li>flags：标注共享内存的共享属性。MAP_SHARED、<strong>MAP_PRIVATE(当对内存进行修改，不能直接修改磁盘)</strong></li>
<li>fd：用于创建共享内存映射区的那个文件的 文件描述符</li>
<li>offset：偏移位置。需要是 <strong>4k</strong> 的整数倍。默认为0，表示映射文件全部</li>
</ol>
<ul>
<li>返回值：</li>
</ul>
<ol>
<li>成功：映射区的首地址。</li>
<li>失败：MAP_FAILED 设置errno</li>
</ol>
<h4 id="munmap函数"><a href="#munmap函数" class="headerlink" title="munmap函数"></a>munmap函数</h4><ul>
<li>*<em>int munmap(void <em>addr , size_t length);</em></em>        释放映射区</li>
<li>参数：</li>
</ul>
<ol>
<li>addr：mmap的返回值</li>
<li>length：大小</li>
</ol>
<p>返回值：</p>
<ol>
<li>成功：0</li>
<li>失败：-1</li>
</ol>
<h4 id="使用注意事项："><a href="#使用注意事项：" class="headerlink" title="使用注意事项："></a>使用注意事项：</h4><ol>
<li><p>用于创建映射区的文件大小为0，实际指定非0大小创建映射区，出“总线错误”。</p>
</li>
<li><p>用于创建映射区的文件大小为0，实际指定0大小创建映射区，出“无效参数”。**(即映射文件大小为0时，不能创建映射区)**</p>
</li>
<li><p>用于创建映射区的文件读写属性为，只读。映射区属性为 读写，出“无效参数”。</p>
</li>
<li><p><strong>创建映射区，需要read权限</strong>(隐含了一次对映射区的读操作)。当访问权限指定为“共享”MAP_SHARED时，mmap的读写权限，应该&lt;&#x3D;文件的open权限。<strong>只写不行</strong></p>
</li>
<li><p>文件描述符fd，在mmap创建映射区完成即可关闭。<strong>后续访问文件，用地址访问。</strong></p>
</li>
<li><p>offset必须是 4096 的整数倍。(MMU映射的最小单位 4k)</p>
</li>
<li><p>对申请的映射区内存，不能越界访问。</p>
</li>
<li><p>munmap用于释放的地址，必须是<strong>mmap申请返回的地址</strong>。 (指针不能执行++操作，改变了原地址)</p>
</li>
<li><p>映射区访问权限为“私有”MAP_PRIVATE，对内存所做的修改，只在内存有效，不会反应到物理磁盘上。</p>
</li>
<li><p>映射区访问权限为“私有”MAP_PRIVATE，只需要open文件时，有读权限，用于创建映射区即可。</p>
</li>
</ol>
<ul>
<li><strong>mmap函数的保险调用方式：</strong></li>
</ul>
<ol>
<li>fd&#x3D;open(“文件名” , O_RDWR);</li>
<li>mmap(NULL,有效文件大小,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</li>
</ol>
<h4 id="mmap父子进程通信"><a href="#mmap父子进程通信" class="headerlink" title="mmap父子进程通信"></a>mmap父子进程通信</h4><ul>
<li>父子等血缘关系的进程之间也可以通过mmap建立的映射区来完成数据通信。但相应的要在创建映射区的时候指定对应的标志位参数flags：</li>
<li>MAP_PRIVATE：(私有映射)  父子进程各自独占映射区</li>
<li>MAP_SHARED：(共享映射)  父子进程共享映射区</li>
</ul>
<h4 id="mmap无血缘关系进程间通信"><a href="#mmap无血缘关系进程间通信" class="headerlink" title="mmap无血缘关系进程间通信"></a>mmap无血缘关系进程间通信</h4><ul>
<li>实际上mmap是内核借助文件帮我们创建了一个映射区，多个进程之间利用该映射区完成数据传递。由于内核空间多进程共享，因此无血缘关系的进程间也可以使用mmap来完成通信。只要设置相应的标志位参数flags即可。</li>
<li>若想实现共享，使用MAP_SHARED</li>
<li><strong>值得注意的是：MAP_ANON和&#x2F;dev&#x2F;zero都不能应用于非血缘关系进程间通信。只能应用于亲子进程间。</strong></li>
</ul>
<h4 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a>匿名映射</h4><ul>
<li><p>通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。</p>
<p>通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。 可以直接使用匿名映射来代替。</p>
<p>其实Linux系统给我们提供了创建匿名映射区的方法，<strong>无需依赖一个文件即可创建映射区</strong>。同样需要<strong>借助标志位参数flags</strong>来指定。</p>
</li>
<li><p>使用**MAP_ANONYMOUS(或MAP_ANON)**，如：</p>
</li>
<li><p>int <em>p&#x3D;(int <em>)mmap(NULL,<strong>4,<strong>PROT_READ|PROT_WRITE</strong>,MAP_SHARED|MAP_ANONYMOUS</strong>,**-1</em></em>,0);  (“4”位置可以自行指定大小)</p>
</li>
<li><p>需要注意的是，MAP_ANONYMOUS和MAP_ANON这两个宏是Linux操作系统特有的宏。在类Unix系统中无该宏定义，可使用如下两步来完成匿名映射区的建立。</p>
</li>
</ul>
<ol>
<li>fd&#x3D;open(“&#x2F;dev&#x2F;zero” , O_RDWR);  dev&#x2F;zero:文件宝库(无限读，”\0”)  dev&#x2F;null:文件黑洞(无限写)</li>
<li>p&#x3D;mmap(NULL , size , PROT_READ|PROT_WRITE , MMAP_SHARED , fd , 0);</li>
</ol>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><h4 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a>信号的概念</h4><ul>
<li><p>信号在我们的生活中随处可见，如：古代战争中摔杯为号；现代战争中的信号弹；体育比赛中使用的信号枪…他们都有共性：</p>
<p>1.简单  2.不能携带大量信息   3.满足某个特设条件才发送</p>
</li>
</ul>
<h5 id="信号的机制"><a href="#信号的机制" class="headerlink" title="信号的机制"></a>信号的机制</h5><ul>
<li>A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行。与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。</li>
<li>信号的特质：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延时时间非常短，不易察觉。</li>
<li><strong>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</strong></li>
</ul>
<h5 id="与信号相关的事件和状态"><a href="#与信号相关的事件和状态" class="headerlink" title="与信号相关的事件和状态"></a>与信号相关的事件和状态</h5><ul>
<li>产生信号：</li>
</ul>
<ol>
<li>按键产生：如：ctrl+c，ctrl+z，ctrl+&#x2F;</li>
<li>系统调用产生，如：kill，raise，abort</li>
<li>软件条件产生，如：定时器alarm</li>
<li>硬件异常产生，如：非法访问内存(段错误)，除0(浮点数例外)，内存对齐错误(总线错误)</li>
<li>命令产生：如：kill命令</li>
</ol>
<ul>
<li><strong>递达：递送并且到达进程</strong></li>
<li><strong>未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。</strong></li>
<li><strong>信号的处理方式：</strong></li>
</ul>
<ol>
<li>执行默认动作</li>
<li>忽略(丢弃)</li>
<li>捕捉(调用户处理函数)</li>
</ol>
<ul>
<li><p>Linux内核的进程控制块PCB是一个结构体，task_struct，除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，<strong>主要指阻塞信号集和未决信号集</strong></p>
</li>
<li><p><strong>阻塞信号集(信号屏蔽字)：本质：位图。</strong>将某些信号加入集合，对他们设置屏蔽，当屏蔽信号x后，在解决屏蔽前，该信号一直处于未决状态。</p>
</li>
<li><p><strong>未决信号集：本质位图。</strong></p>
</li>
</ul>
<ol>
<li>信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0.这一时刻往往非常短暂。</li>
<li>信号产生后由于某些原因(主要是阻塞)不能递达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。</li>
</ol>
<h5 id="信号的编号"><a href="#信号的编号" class="headerlink" title="信号的编号"></a>信号的编号</h5><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308211101339.png" alt="Snipaste_2023-08-21_11-01-05"></p>
<h5 id="信号四要素"><a href="#信号四要素" class="headerlink" title="信号四要素"></a>信号四要素</h5><ul>
<li><p><strong>1.编号  2. 名称  3. 事件  4. ，默认处理动作</strong></p>
<p>可以通过man 7 signal查看帮助文档获取。也可以查看&#x2F;usr&#x2F;src&#x2F;linux-headers-3.16.0-30&#x2F;arch&#x2F;s390&#x2F;include&#x2F;uapi&#x2F;asm&#x2F;signal.h</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308211723199.png" alt="1527928967909"></p>
<ul>
<li><strong>Action为默认动作：</strong></li>
</ul>
<ol>
<li>Term：终止进程</li>
<li>lgn：忽略信号(默认即时对该种信号忽略操作)</li>
<li>Core：终止进程，生成Core文件(查验死亡原因，用于gdb调试)</li>
<li>Stop停止(暂停)进程</li>
<li>Cont：继续运行进程</li>
</ol>
<ul>
<li><strong>Linux常规信号一览表</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong>编号</strong></th>
<th align="left"><strong>信号</strong></th>
<th align="left"><strong>对应事件</strong></th>
<th align="left"><strong>默认动作</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>SIGHUP</strong></td>
<td align="left">用户退出shell时，由该shell启动的所有进程将收到这个信号</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>SIGINT</strong></td>
<td align="left">当用户按下了**&lt;Ctrl+C&gt;**组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>SIGQUIT</strong></td>
<td align="left">用户按下**&lt;ctrl+ \ &gt;**组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">SIGILL</td>
<td align="left">CPU检测到某进程执行了非法指令</td>
<td align="left">终止进程并产生core文件</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">SIGTRAP</td>
<td align="left">该信号由断点指令或其他 trap指令产生</td>
<td align="left">终止进程并产生core文件</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">SIGABRT</td>
<td align="left">调用abort函数时产生该信号</td>
<td align="left">终止进程并产生core文件</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>SIGBUS</strong></td>
<td align="left">非法访问内存地址，包括内存对齐出错</td>
<td align="left">终止进程并产生core文件</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>SIGFPE</strong></td>
<td align="left">在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误</td>
<td align="left">终止进程并产生core文件</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><em><strong>SIGKILL</strong></em></td>
<td align="left">无条件终止进程。本信号不能被忽略，处理和阻塞</td>
<td align="left">终止进程，可以杀死任何进程</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>SIGUSR1</strong></td>
<td align="left">用户定义的信号。即程序员可以在程序中定义并使用该信号</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>SIGSEGV</strong></td>
<td align="left">指示进程进行了无效内存访问(段错误)</td>
<td align="left">终止进程并产生core文件</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>SIGUSR2</strong></td>
<td align="left">另外一个用户自定义信号，程序员可以在程序中定义并使用该信号</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>SIGPIPE</strong></td>
<td align="left">Broken pipe向一个没有读端的管道写数据</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><strong>SIGALRM</strong></td>
<td align="left">定时器超时，超时的时间 由系统调用alarm设置</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><strong>SIGTERM</strong></td>
<td align="left">程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">SIGSTKFLT</td>
<td align="left">Linux早期版本出现的信号，现仍保留向后兼容</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><strong>SIGCHLD</strong></td>
<td align="left">子进程结束时，父进程会收到这个信号</td>
<td align="left">忽略这个信号</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left">SIGCONT</td>
<td align="left">如果进程已停止，则使其继续运行</td>
<td align="left">继续&#x2F;忽略</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><em><strong>SIGSTOP</strong></em></td>
<td align="left">停止进程的执行。信号不能被忽略，处理和阻塞</td>
<td align="left">为终止进程</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">SIGTSTP</td>
<td align="left">停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号</td>
<td align="left">暂停进程</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left">SIGTTIN</td>
<td align="left">后台进程读终端控制台</td>
<td align="left">暂停进程</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left">SIGTTOU</td>
<td align="left">该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生</td>
<td align="left">暂停进程</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">SIGURG</td>
<td align="left">套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达</td>
<td align="left">忽略该信号</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">SIGXCPU</td>
<td align="left">进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">SIGXFSZ</td>
<td align="left">超过文件的最大长度设置</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">SIGVTALRM</td>
<td align="left">虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left">SGIPROF</td>
<td align="left">类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left">SIGWINCH</td>
<td align="left">窗口变化大小时发出</td>
<td align="left">忽略该信号</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left">SIGIO</td>
<td align="left">此信号向进程指示发出了一个异步IO事件</td>
<td align="left">忽略该信号</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left">SIGPWR</td>
<td align="left">关机</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left">SIGSYS</td>
<td align="left">无效的系统调用</td>
<td align="left">终止进程并产生core文件</td>
</tr>
<tr>
<td align="left">34~64</td>
<td align="left">SIGRTMIN ～ SIGRTMAX</td>
<td align="left">LINUX的实时信号，它们没有固定的含义（可以由用户自定义）</td>
<td align="left">终止进程</td>
</tr>
</tbody></table>
<ul>
<li>特别强调：<strong>9) SIGKILL</strong> <strong>和19) SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</strong></li>
<li>另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送(但不一定递达)，不应乱发信号！</li>
</ul>
<h4 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h4><h5 id="kill函数-x2F-命令产生信号"><a href="#kill函数-x2F-命令产生信号" class="headerlink" title="kill函数&#x2F;命令产生信号"></a>kill函数&#x2F;命令产生信号</h5><ul>
<li>kill命令参数信号：kill -SIGKILL pid</li>
<li>kill函数：给指定进程发送指定信号(不一定杀死)</li>
<li>**int kill(pid_t , int sig);<strong>成功：0，失败：-1</strong>(ID非法，信号非法，普通用户杀init进程等权级问题)**，设置errno</li>
<li>sig：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</li>
</ul>
<ol>
<li>pid&gt;0：发送信号给指定的进程。</li>
<li>pid&#x3D;0：发送信号给与<strong>调用kill函数进程属于同一进程组的所有进程</strong>。</li>
<li>pid&lt;-1：区|pid|发送给对应进程组。</li>
<li>pid&#x3D;-1：发送给进程有权限发送的系统中所有进程。</li>
</ol>
<ul>
<li><strong>进程组</strong>：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，<strong>每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。</strong></li>
<li>权限保护：super用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。同样，普通用户也不能向其他普通用户发送信号终止其进程，只能向自己创建的进程发送信号。<strong>普通用户基本规则是：发送者实际或有效用户ID&#x3D;&#x3D;接收者实际或有效用户ID。</strong></li>
</ul>
<h5 id="其他几个发信号函数"><a href="#其他几个发信号函数" class="headerlink" title="其他几个发信号函数"></a>其他几个发信号函数</h5><ul>
<li>int raise(int sig);</li>
<li>void abort(void);</li>
</ul>
<h5 id="软件条件产生信号"><a href="#软件条件产生信号" class="headerlink" title="软件条件产生信号"></a>软件条件产生信号</h5><h6 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h6><ul>
<li><p>设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送 14)SIGALRM 信号。进程收到该信号，默认动作终止。</p>
</li>
<li><p><strong>每个进程都有且只有唯一一个定时器。</strong></p>
</li>
<li><p>unsigned int alarm(unsigned int seconds); <strong>返回0或剩余的秒数</strong>，无失败。</p>
</li>
<li><p>常用：取消定时器 alarm(0)，返回旧闹钟余下秒数。</p>
</li>
<li><p>例：alarm(5) →3sec →alarm(4) (返回2s)→5sec→alarm(5) (返回0s)→alarm(0) </p>
</li>
<li><p>定时，与进程状态无关(自然定时法)！就绪，运行，挂起(阻塞，暂停)，终止，僵尸…无论进程处于何种状态，alarm都计时。</p>
</li>
<li><p>使用time命令查看程序执行时间。 time .&#x2F;alarm  <strong>程序运行的瓶颈在于IO，优化程序，首选优化IO。</strong></p>
</li>
<li><p><strong>实际执行时间&#x3D;系统时间+用户时间+<em>等待时间</em></strong></p>
</li>
</ul>
<h6 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which,  <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value, <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br><span class="line">功能：</span><br><span class="line">    设置定时器(闹钟)。 可代替alarm函数。精度微秒us，可以实现周期定时。</span><br><span class="line">参数：</span><br><span class="line">    which：指定定时方式</span><br><span class="line">        a) 自然定时：ITIMER_REAL → <span class="number">14</span>）SIGALRM计算自然时间</span><br><span class="line">        b) 虚拟空间计时(用户空间)：ITIMER_VIRTUAL → <span class="number">26</span>）SIGVTALRM  只计算进程占用cpu的时间</span><br><span class="line">        c) 运行时计时(用户 + 内核)：ITIMER_PROF → <span class="number">27</span>）SIGPROF计算占用cpu及执行系统调用的时间</span><br><span class="line">    </span><br><span class="line">    new_value：定时秒数 (相当于alarm的seconds)</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_interval</span>;</span> <span class="comment">// 闹钟触发周期</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_value</span>;</span>    <span class="comment">// 闹钟触发时间</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">            <span class="type">long</span> tv_sec;            <span class="comment">// 秒</span></span><br><span class="line">            <span class="type">long</span> tv_usec;           <span class="comment">// 微秒</span></span><br><span class="line">        &#125;</span><br><span class="line">        itimerval.it_value：     设定第一次执行function所延迟的秒数 (<span class="keyword">do</span>)</span><br><span class="line">        itimerval.it_interval：  设定以后每几秒执行function   (<span class="keyword">while</span>)</span><br><span class="line">​</span><br><span class="line">    old_value： 传出参数，上次定时剩余时间(相对于alarm的返回值)，一般指定为<span class="literal">NULL</span></span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="信号集概述"><a href="#信号集概述" class="headerlink" title="信号集概述"></a>信号集概述</h4><ul>
<li>这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对其进行位操作。而需自定义另外一个集合，接着信号集操作函数来对PCB中的这两个信号集进行修改。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308232043891.png" alt="Snipaste_2023-08-23_10-00-15"></p>
<h5 id="信号集设定"><a href="#信号集设定" class="headerlink" title="信号集设定"></a>信号集设定</h5><ul>
<li><p><strong>#include &lt;signal.h&gt;</strong>  </p>
</li>
<li><p><strong>sigset_t set;</strong>    &#x2F;&#x2F;typedef unsigned long sigset_t;</p>
</li>
<li><p>int sig<strong>empty</strong>set(sigset_t *set);       &#x2F;&#x2F;将set集合置空(清0)                                                成功：0；失败-1</p>
</li>
<li><p>int sig<strong>fill</strong>set(sigset_t *set)；          &#x2F;&#x2F;将所有信号加入set集合(全置1)                              成功：0；失败-1</p>
</li>
<li><p>int sig<strong>add</strong>set(sigset_t *set, int signo);  &#x2F;&#x2F;将signo信号加入到set集合(单个置1)            成功：0；失败-1</p>
</li>
<li><p>int sig<strong>del</strong>set(sigset_t *set, int signo);   &#x2F;&#x2F;从set集合中移除signo信号(单个清0)            成功：0；失败-1</p>
</li>
<li><p>int sig<strong>ismember</strong>(const sigset_t *set, int signo); &#x2F;&#x2F;判断信号是否存在                           在：1；不在：0；出错：-1</p>
</li>
<li><p>sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。</p>
</li>
</ul>
<h5 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h5><ul>
<li>用来屏蔽信号。解除屏蔽也使用该函数。其本质，读取或修改进程的信号屏蔽字(PCB中)</li>
<li>严格注意，<strong>屏蔽信号：只是将信号处理延迟执行(延迟到解除屏蔽时)<strong>，而</strong>忽略</strong>表示将信号丢处理。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line">功能：</span><br><span class="line">    检查或修改信号阻塞集，根据 how 指定的方法对进程的阻塞集合进行修改，新的信号阻塞集由 <span class="built_in">set</span> 指定，而原先的信号阻塞集合由 oldset 保存。</span><br><span class="line">​</span><br><span class="line">参数：</span><br><span class="line">    how : 信号阻塞集合的修改方法，有 <span class="number">3</span> 种情况：</span><br><span class="line">        SIG_BLOCK：当how设置为此值，<span class="built_in">set</span>表示需要屏蔽的信号。相当于 mask = mask|<span class="built_in">set</span>。</span><br><span class="line">        SIG_UNBLOCK：当how设置为此值，<span class="built_in">set</span>表示需要解除屏蔽的信号。相当于 mask = mask &amp; ~ <span class="built_in">set</span>。</span><br><span class="line">        SIG_SETMASK：当how设置为此值，<span class="built_in">set</span>表示用于替代原始屏蔽集的新屏蔽集。相当于mask = <span class="built_in">set</span>。</span><br><span class="line">        若调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">set</span> : 传入参数，是一个位图，<span class="built_in">set</span>中哪个位置为<span class="number">1</span>，就表示当前进程屏蔽哪个信号。要操作的信号集地址。</span><br><span class="line">        若 <span class="built_in">set</span> 为 <span class="literal">NULL</span>，则不改变信号阻塞集合，函数只把当前信号阻塞集合保存到 oldset 中。</span><br><span class="line">    oldset : 传出参数，保存原先信号阻塞集地址</span><br><span class="line">​</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span>，</span><br><span class="line">    失败：<span class="number">-1</span>，失败时错误代码只可能是 EINVAL，表示参数 how 不合法。</span><br></pre></td></tr></table></figure>

<h5 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a>sigpending函数</h5><ul>
<li><strong>读取</strong>当前进程的未决信号集</li>
<li>int sigpending(sigset_t *set);set传出参数。返回值：成功：0；失败：-1，设置errno</li>
</ul>
<h4 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h4><h5 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h5><ul>
<li><strong>注册</strong>一个信号捕捉函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;(不加<span class="keyword">typedef</span>为一个函数指针，返回值为<span class="type">void</span>，参数为<span class="type">int</span>)</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line">功能：</span><br><span class="line">    注册信号处理函数（不可用于 SIGKILL、SIGSTOP 信号），即确定收到信号后处理函数的入口地址。此函数不会阻塞。</span><br><span class="line">​</span><br><span class="line">参数：</span><br><span class="line">    signum：信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令 kill - l(<span class="string">&quot;l&quot;</span> 为字母)进行相应查看。</span><br><span class="line">    handler : 取值有 <span class="number">3</span> 种情况：</span><br><span class="line">          SIG_IGN：忽略该信号</span><br><span class="line">          SIG_DFL：执行系统默认动作</span><br><span class="line">          信号处理函数名：自定义信号处理函数，如：func</span><br><span class="line">          回调函数的定义如下：</span><br><span class="line">            <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// signo 为触发的信号，为 signal() 第一个参数的值</span></span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">返回值：</span><br><span class="line">    成功：第一次返回 <span class="literal">NULL</span>，下一次返回此信号上一次注册的信号处理函数的地址。如果需要使用此返回值，必须在前面先声明此函数指针的类型。</span><br><span class="line">    失败：返回 SIG_ERR</span><br></pre></td></tr></table></figure>

<ul>
<li>该函数由ANSI定义，由于历史原因在不同版本的Unix和不同版本的Linux中可能有不同的行为。因此应该尽量避免使用它，取而代之使用sigaction函数。</li>
</ul>
<h5 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h5><ul>
<li>修改信号处理动作(通常在Linux用其来注册一个信号的捕捉函数)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line">功能：</span><br><span class="line">    检查或修改指定信号的设置（或同时执行这两种操作）。</span><br><span class="line">​</span><br><span class="line">参数：</span><br><span class="line">    signum：要操作的信号。</span><br><span class="line">    act：   要设置的对信号的新处理方式（传入参数）。</span><br><span class="line">    oldact：原来对信号的处理方式（传出参数）。</span><br><span class="line">​</span><br><span class="line">    如果 act 指针非空，则要改变指定信号的处理方式（设置），如果 oldact 指针非空，则系统将此前指定信号的处理方式存入 oldact。</span><br><span class="line">​</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>struct sigaction结构体：</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>(*sa_handler)(<span class="type">int</span>); <span class="comment">//旧的信号处理函数指针</span></span><br><span class="line">    <span class="type">void</span>(*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *); <span class="comment">//新的信号处理函数指针(携带复杂数据时使用)</span></span><br><span class="line">    <span class="type">sigset_t</span>   sa_mask;      <span class="comment">//信号阻塞集(只工作于信号捕捉函数执行期间) (用sigemptyset函数初始化)</span></span><br><span class="line">    <span class="type">int</span>        sa_flags;     <span class="comment">//信号处理的方式</span></span><br><span class="line">    <span class="type">void</span>(*sa_restorer)(<span class="type">void</span>); <span class="comment">//已弃用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) sa_handler、sa_sigaction：信号处理函数指针，和 signal() 里的函数指针用法一样，应根据情况给sa_sigaction、sa_handler 两者之一赋值，其取值如下：</span><br><span class="line"></span><br><span class="line">a) SIG_IGN：忽略该信号</span><br><span class="line"></span><br><span class="line">b) SIG_DFL：执行系统默认动作</span><br><span class="line"></span><br><span class="line">c) 处理函数名：自定义信号处理函数</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>) sa_mask：信号阻塞集，在信号处理函数执行过程中，临时屏蔽指定的信号。</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) sa_flags：用于指定信号处理的行为，通常设置为<span class="number">0</span>，表使用默认属性。它可以是一下值的“按位或”组合：</span><br><span class="line"></span><br><span class="line">Ø SA_RESTART：使被信号打断的系统调用自动重新发起（已经废弃）</span><br><span class="line"></span><br><span class="line">Ø SA_NOCLDSTOP：使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号。</span><br><span class="line"></span><br><span class="line">Ø SA_NOCLDWAIT：使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程。</span><br><span class="line"></span><br><span class="line">Ø SA_NODEFER：使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号。</span><br><span class="line"></span><br><span class="line">Ø SA_RESETHAND：信号处理之后重新设置为默认的处理方式。</span><br><span class="line"></span><br><span class="line">Ø SA_SIGINFO：使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数。</span><br></pre></td></tr></table></figure>

<h5 id="信号捕捉特性"><a href="#信号捕捉特性" class="headerlink" title="信号捕捉特性"></a>信号捕捉特性</h5><ol>
<li>进程正常执行时，默认PCB中有一个信号屏蔽字mask，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该函数以后，要调用该函数。<strong>而该函数有可能执行很长时间，在这期间所屏蔽的信号不由mask来指定。而是用sa_mask来指定。调用完信号处理函数，再恢复为mask。</strong></li>
<li>xxx信号捕捉函数执行期间，xxx信号自动被屏蔽。</li>
<li><strong>阻塞的常规信号不支持排队，产生多次只记录一次。</strong>(后32个实时信号支持排队)</li>
</ol>
<h5 id="内核实现信号捕捉过程"><a href="#内核实现信号捕捉过程" class="headerlink" title="内核实现信号捕捉过程"></a>内核实现信号捕捉过程</h5><p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202308241102712.png" alt="1527931072795"></p>
<h4 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h4><h6 id="SIGCHLD的产生条件"><a href="#SIGCHLD的产生条件" class="headerlink" title="SIGCHLD的产生条件"></a>SIGCHLD的产生条件</h6><ol>
<li>子进程终止时</li>
<li>子进程接收到SIGSTOP信号停止时</li>
<li>子进程处在停止态，接收到SIGCONT后唤醒时</li>
</ol>
<h3 id="进程组和会话"><a href="#进程组和会话" class="headerlink" title="进程组和会话"></a>进程组和会话</h3><h4 id="概念和特性"><a href="#概念和特性" class="headerlink" title="概念和特性"></a>概念和特性</h4><ul>
<li><p>进程组，也称之为作业。BSD于1980年前后向Unix中增加的一个新特性。<strong>代表一个或多个进程的集合。</strong></p>
</li>
<li><p>每个进程都属于一个进程组。在waitpid函数和kill函数的参数中都曾使用到。操作系统设计的进程组的概念，是为了简化对多个进程的管理。</p>
</li>
<li><p>当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。进程组ID为第一个进程ID(组长进程)。所以，组长进程标识：其进程组ID为其进程ID</p>
</li>
<li><p>可以使用<strong>kill -SIGKILL -进程组ID</strong>(负的)来将整个进程组内的进程全部杀死。</p>
</li>
<li><p>组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。<strong>只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。</strong></p>
</li>
<li><p>进程组生存期：进程组创建到最后一个进程离开(终止或转移到另一个进程组)。</p>
</li>
<li><p>一个进程可以为自己或子进程设置进程组ID。</p>
</li>
</ul>
<h4 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h4><ul>
<li>创建一个会话需要注意以下6点注意事项：</li>
</ul>
<ol>
<li><strong>调用进程不能是进程组组长</strong>，该进程变成新会话首进程(session header)</li>
<li>该调用进程是组长进程，则出错返回</li>
<li>该进程成为一个<strong>新进程组的组长进程</strong></li>
<li>需有root权限(ubuntu不需要)</li>
<li>新会话丢弃原有的控制终端，<strong>该会话没有控制终端</strong></li>
<li>建立新会话时，先调用fork, 父进程终止，子进程调用setsid</li>
</ol>
<h4 id="getsid函数："><a href="#getsid函数：" class="headerlink" title="getsid函数："></a>getsid函数：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line">功能：获取进程所属的会话ID</span><br><span class="line">参数：</span><br><span class="line">    pid：进程号，(pid为<span class="number">0</span>表示查看当前进程session ID)</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回调用进程的会话ID</span><br><span class="line">    失败：<span class="number">-1</span>，设置errno</span><br></pre></td></tr></table></figure>

<ul>
<li>ps ajx命令查看系统中的进程。参数a表示不仅列当前用户的进程，也列出所有其他用户的进程，参数x表示不仅列有控制终端的进程，也列出所有无控制终端的进程，参数j表示列出与作业控制相关的信息。</li>
<li>组长进程不能成为新会话首进程，新会话首进程必定会成为组长进程。</li>
</ul>
<h4 id="setsid函数："><a href="#setsid函数：" class="headerlink" title="setsid函数："></a>setsid函数：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：</span><br><span class="line">    创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID。</span><br><span class="line">    调用了setsid函数的进程，既是新的会长，也是新的组长。</span><br><span class="line">参数：无</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回调用进程的会话ID</span><br><span class="line">    失败：<span class="number">-1</span>，设置errno</span><br></pre></td></tr></table></figure>

<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><ul>
<li><p>Daemon(精灵)进程，是Linux中的后台服务进程，通常<strong>独立于控制终端</strong>并且<strong>周期性地执行某种任务</strong>或<strong>等待处理某些发生的事件</strong>。一般采用以d结尾的名字。</p>
</li>
<li><p>Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录，注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现：ftp服务器；nfs服务器…</p>
</li>
<li><p><strong>守护进程是个特殊的孤儿进程</strong>，这种进程脱离终端，为什么要脱离终端呢？之所以<strong>脱离于终端是为了避免进程被任何终端所产生的信息所打断</strong>，其在执行过程中的信息也不在任何终端上显示。由于在 Linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。</p>
</li>
<li><p>创建守护进程，最关键的一步是调用setsid函数创建一个新的Session，并成为Session Leader。</p>
</li>
</ul>
<h4 id="创建守护进程模型"><a href="#创建守护进程模型" class="headerlink" title="创建守护进程模型"></a>创建守护进程模型</h4><ol>
<li>创建子进程，让父进程退出(所有工作在子进程中形式上脱离控制终端)</li>
<li>子进程调用 <strong>setsid()</strong> 创建新会话(使子进程完全独立出来，脱离控制)</li>
<li>通常根据需要，改变工作目录位置 <strong>chdir()</strong> (防止占用可卸载的文件系统)</li>
<li>通常根据需要，重设umask文件权限掩码(防止继承的文件创建屏蔽字拒绝某些权限，增加守护进程的灵活性)</li>
<li>通常根据需要，<strong>关闭&#x2F;重定向</strong> (0,1,2重定向到&#x2F;dev&#x2F;null) 文件描述符(继承的打开文件不会用到的，浪费系统资源，无法卸载)</li>
<li>开始执行守护进程的核心工作：守护进程退出处理程序模型(while大循环)</li>
</ol>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h4><ul>
<li>线程是轻量级的进程（LWP：light weight process），<strong>在Linux环境下线程的本质仍是进程。</strong></li>
<li>进程：有独立的 进程地址空间 。有独立的PCB。<strong>分配资源的最小单位。</strong></li>
<li>线程：有独立的PCB。没有独立的进程地址空间(共享)。</li>
</ul>
<h4 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a>Linux内核线程实现原理</h4><ul>
<li><p>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。</p>
</li>
<li><p>因此在这类系统中，进程和线程关系密切：</p>
</li>
</ul>
<ol>
<li><p>线程是轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone</p>
</li>
<li><p>从内核里看进程和线程是一样的，都有各自不同的PCB.</p>
</li>
<li><p>进程可以蜕变成线程</p>
</li>
<li><p><strong>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</strong></p>
</li>
</ol>
<ul>
<li>查看指定进程的LWP号：</li>
</ul>
<blockquote>
<p>ps  -Lf  pid</p>
</blockquote>
<p>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数 clone 。</p>
<p>Ø 如果复制对方的地址空间，那么就产出一个“进程”；</p>
<p>Ø 如果共享对方的地址空间，就产生一个“线程”。</p>
<p>Linux内核是不区分进程和线程的, 只在用户层面上进行区分。所以，线程所有操作函数 pthread_* 是库函数，而非系统调用。</p>
<p><img src="F:\图片管理中心\学习\Snipaste_2023-08-26_21-59-41.png" alt="Snipaste_2023-08-26_21-59-41"></p>
<h4 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a>线程共享资源</h4><ol>
<li>文件描述符表</li>
<li>每种信号的处理方式</li>
<li>当前工作目录</li>
<li>用户ID和组ID</li>
<li>内存地址空间(.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库)<strong>(全局变量)</strong></li>
</ol>
<h4 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a>线程非共享资源</h4><ol>
<li>线程id</li>
<li>处理器现场(寄存器数据)和栈指针(内核栈)</li>
<li>独立的栈空间(用户空间栈)(局部变量)</li>
<li>errno变量(全局变量)</li>
<li>信号屏蔽字</li>
<li>调度优先级</li>
</ol>
<h4 id="线程优缺点"><a href="#线程优缺点" class="headerlink" title="线程优缺点"></a>线程优缺点</h4><ul>
<li>优点：</li>
</ul>
<ol>
<li>提高程序并发性</li>
<li>开销小</li>
<li>数据通信，共享数据方便</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>库函数，不稳定</li>
<li>调试，编写困难，gdb不支持</li>
<li>对信号支持不好</li>
</ol>
<ul>
<li>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程，线程差别不是很大。</li>
</ul>
<h3 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a>线程控制原语</h3><ul>
<li>就像每个进程都有一个进程号一样，每个线程也有一个线程号。进程号在整个系统中是唯一的，但线程号不同，线程号只在它所属的进程环境中有效。</li>
<li>进程号用 pid_t 数据类型表示，是一个非负整数。线程号则用 pthread_t 数据类型来表示，**Linux 使用无符号长整数表示(%lu)**。</li>
<li>有的系统在实现pthread_t 的时候，用一个结构体来表示，所以在可移植的操作系统实现不能把它做为整数处理。</li>
<li><strong>检查出错返回：线程中使用。 –fprintf(stderr,”xxx error:%s\n”,strerror(ret));</strong></li>
</ul>
<h4 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a>pthread_self函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取线程号。</span><br><span class="line">参数：</span><br><span class="line">    无</span><br><span class="line">返回值：</span><br><span class="line">    调用线程的线程 ID 。</span><br></pre></td></tr></table></figure>

<h4 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a>pthread_create函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">            <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *),</span></span><br><span class="line"><span class="params">            <span class="type">void</span> *arg )</span>;</span><br><span class="line">功能：</span><br><span class="line">    创建一个线程。</span><br><span class="line">参数：</span><br><span class="line">    thread：线程标识符地址。</span><br><span class="line">    attr：线程属性结构体地址，通常设置为 <span class="literal">NULL</span>。</span><br><span class="line">    start_routine：线程函数的入口地址。</span><br><span class="line">    arg：传给线程函数的参数。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在一个线程中调用pthread_create()创建新的线程后，当前线程从pthread_create()返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。</p>
</li>
<li><p>由于pthread_create的错误码不保存在errno中，因此不能直接用perror()打印错误信息，可以先用**strerror()**把错误码转换成错误信息再打印。</p>
</li>
</ul>
<h4 id="pthread-exit-函数"><a href="#pthread-exit-函数" class="headerlink" title="pthread_exit()函数"></a>pthread_exit()函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line">功能：</span><br><span class="line">    退出调用线程。一个进程中的多个线程是共享该进程的数据段，因此，通常线程退出后所占用的资源并不会释放。</span><br><span class="line">参数：</span><br><span class="line">    retval：存储线程退出状态的指针。无退出值时，传<span class="literal">NULL</span></span><br><span class="line">    <span class="title function_">exit</span><span class="params">()</span>：退出当前进程</span><br><span class="line">    <span class="keyword">return</span>：返回到调用者那里去</span><br><span class="line">返回值：无  </span><br></pre></td></tr></table></figure>

<p>在进程中我们可以调用exit函数或_exit函数来结束进程，在一个线程中我们可以通过以下三种在不终止整个进程的情况下停止它的控制流。</p>
<ul>
<li>线程从执行函数中返回。</li>
<li>线程调用pthread_exit退出线程。</li>
<li>线程可以被同一进程中的其它线程取消。</li>
</ul>
<h4 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line">功能：</span><br><span class="line">    等待线程结束（此函数会阻塞），并回收线程资源，类似进程的 wait() 函数。如果线程已经结束，那么该函数会立即返回。</span><br><span class="line">参数：</span><br><span class="line">    thread：被等待的线程号。</span><br><span class="line">    retval：用来存储线程退出状态的指针的地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>调用该函数的线程将挂起等待，直到id为thread的线程终止。thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下：</li>
</ul>
<ol>
<li><p>如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。</p>
</li>
<li><p>如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED。</p>
</li>
<li><p>如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。</p>
</li>
</ol>
<h4 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">功能：</span><br><span class="line">    使调用线程与当前进程分离，分离后不代表此线程不依赖与当前进程，线程分离的目的是将线程资源的回收工作交由系统自动来完成，也就是说当被分离的线程结束之后，系统会自动回收它的资源。所以，此函数不会阻塞。</span><br><span class="line">参数：</span><br><span class="line">    thread：线程号。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止。</strong>但是线程也可以被<em><strong>置为detach状态</strong></em>，这样的线程一旦终止就立刻回收它占用的所有资源，而<em><strong>不保留终止状态</strong></em>。</p>
</li>
<li><p><strong>不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。</strong>也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。</p>
</li>
</ul>
<h4 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">功能：</span><br><span class="line">    杀死(取消)线程。需要到达取消点(保存点)</span><br><span class="line">参数：</span><br><span class="line">    thread : 目标线程ID。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：出错编号</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>注意：线程的取消并不是实时的，而又一定的延时。需要等待线程到达某个取消点(检查点)。</strong></p>
</li>
<li><p>类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。</p>
</li>
<li><p>杀死线程也不是立刻就能完成，<strong>必须要到达取消点。</strong>(没有到达，那么pthread_cancel无效)</p>
</li>
<li><p>我们可以在程序中，<strong>手动添加</strong>一个取消点。使用**pthread_testcancel()**。</p>
</li>
<li><p><strong>成功被pthread_cancel()杀死的线程，<em>返回-1</em>.使用pthread_join回收。</strong></p>
</li>
<li><p>取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write….. 执行命令<strong>man 7 pthreads</strong>可以查看具备这些取消点的系统调用列表。</p>
</li>
<li><p>可粗略认为一个**系统调用(进入内核)**即为一个取消点。</p>
</li>
</ul>
<h4 id="进程和线程控制原语对比"><a href="#进程和线程控制原语对比" class="headerlink" title="进程和线程控制原语对比"></a>进程和线程控制原语对比</h4><table>
<thead>
<tr>
<th align="center">线程控制原语</th>
<th align="center">进程控制原语</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pthread_create()</td>
<td align="center">fork()</td>
</tr>
<tr>
<td align="center">pthread_self()</td>
<td align="center">getpid()</td>
</tr>
<tr>
<td align="center">pthread_exit()</td>
<td align="center">exit()&#x2F;return</td>
</tr>
<tr>
<td align="center">pthread_join()</td>
<td align="center">wait()&#x2F;waitpid()</td>
</tr>
<tr>
<td align="center">pthread_cancel()</td>
<td align="center">kill()</td>
</tr>
<tr>
<td align="center">pthread_detach()</td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="线程使用注意事项"><a href="#线程使用注意事项" class="headerlink" title="线程使用注意事项"></a>线程使用注意事项</h4><ul>
<li><p><strong>主线程退出其他线程不退出，主线程应调用pthread_exit</strong></p>
</li>
<li><p>避免僵尸线程</p>
</li>
</ul>
<ol>
<li><p>pthread_join</p>
</li>
<li><p>pthread_detach</p>
</li>
<li><p>pthread_create指定分离属性</p>
<p>被join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程栈中的值;</p>
</li>
</ol>
<ul>
<li><p>malloc和mmap申请的内存可以被其他线程释放**(线程之间共享堆区)**</p>
</li>
<li><p>应避免在多线程模型中调用fork，除非马上exec，<strong>子进程中只有调用fork的线程存在，其他线程在子进程中均pthread_exit</strong></p>
</li>
<li><p>信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制**(线程对于信号，谁抢到谁处理(处理方式共享)。mask独立，未决信号集共享)**</p>
</li>
</ul>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ul>
<li><p><strong>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其他线程为保证数据一致性，不能调用该功能。</strong></p>
</li>
<li><p><strong>所有”多个控制流，共同操作一个共享资源”的情况，都需要同步。</strong></p>
</li>
</ul>
<h4 id="数据混乱原因"><a href="#数据混乱原因" class="headerlink" title="数据混乱原因"></a>数据混乱原因</h4><ol>
<li>资源共享(独享资源则不会)</li>
<li>调度随机(意味着数据访问会出现竞争)</li>
<li>线程间缺乏必要的同步机制。</li>
</ol>
<ul>
<li>以上3点中，<strong>前两点不能改变</strong> ：欲提高效率，传递数据，资源必须共享；只要共享资源，就一定会出现竞争。</li>
<li>从第三点着手解决。<strong>使多个线程在访问共享资源的时候，出现互斥。</strong></li>
</ul>
<h4 id="互斥量Mutex"><a href="#互斥量Mutex" class="headerlink" title="互斥量Mutex"></a>互斥量Mutex</h4><ul>
<li>Linux中提供一把互斥锁mutex(也称之为互斥量)。</li>
<li><strong>每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。</strong></li>
<li><strong>资源还是共享的，线程间也还是竞争的。</strong></li>
<li>但通过”锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</li>
</ul>
<p><strong>但，应注意：同一时刻，只能有一个线程持有该锁。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。</span><br><span class="line">   所以，互斥锁实质上是操作系统提供的一把<span class="string">&quot;建议锁&quot;</span>(又称<span class="string">&quot;协同锁&quot;</span>)，建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。</span><br><span class="line">   因此，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱。</span><br></pre></td></tr></table></figure>

<h5 id="主要应用函数："><a href="#主要应用函数：" class="headerlink" title="主要应用函数："></a>主要应用函数：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_mutex_init函数</span><br><span class="line">pthread_mutex_destroy函数</span><br><span class="line">pthread_mutex_lock函数</span><br><span class="line">pthread_mutex_trylock函数</span><br><span class="line">pthread_mutex_unlock函数</span><br><span class="line">注意事项：</span><br><span class="line">    尽量保证锁的粒度，越小越好。(访问共享数据前，加锁。访问结束【立即】解锁)</span><br><span class="line">    互斥锁，本质是结构体。我们可以看成整数。初值为<span class="number">1.</span>(pthread_mutex_init()函数调用成功)</span><br><span class="line">    加锁：--操作	阻塞线程</span><br><span class="line">    解锁：++操作	唤醒阻塞在锁上的线程</span><br><span class="line">    try锁：尝试加锁，成功--，失败返回(不阻塞)，同时设置错误号(EBUSY)</span><br><span class="line">初始化互斥量：</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;	</span><br><span class="line">	<span class="number">1.</span>pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);					动态初始化</span><br><span class="line">	<span class="number">2.</span><span class="type">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER;	静态初始化</span><br></pre></td></tr></table></figure>

<ul>
<li>以上5个函数的返回值都是：<strong>成功返回0，失败返回错误号</strong></li>
<li><strong>pthread_mutex_t类型，其本质是一个结构体</strong>。为简化理解，应用时可忽略其实现细节，简单<strong>当成整数看待</strong>。</li>
<li><strong>pthread_mutex_t mutex；变量mutex只有两种取值1，0。</strong></li>
</ul>
<p><img src="F:\图片管理中心\学习\Snipaste_2023-09-06_09-42-04.png" alt="Snipaste_2023-09-06_09-42-04"></p>
<h6 id="pthread-mutex-init函数"><a href="#pthread-mutex-init函数" class="headerlink" title="pthread_mutex_init函数"></a>pthread_mutex_init函数</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    初始化一个互斥锁。</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址。类型是 <span class="type">pthread_mutex_t</span> 。</span><br><span class="line">    attr：设置互斥量的属性，通常可采用默认属性，即可将 attr 设为 <span class="literal">NULL</span>。</span><br><span class="line">​</span><br><span class="line">    可以使用宏 PTHREAD_MUTEX_INITIALIZER 静态初始化互斥锁，比如：</span><br><span class="line">    <span class="type">pthread_mutex_t</span>  mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">​</span><br><span class="line">这种方法等价于使用 <span class="literal">NULL</span> 指定的 attr 参数调用 pthread_mutex_init() 来完成动态初始化，不同之处在于 PTHREAD_MUTEX_INITIALIZER 宏不进行错误检查。</span><br><span class="line">​</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span>，成功申请的锁默认是打开的。</span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>restrict，C语言中的一种类型<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%99%90%E5%AE%9A%E7%AC%A6/1924249">限定符</a>（Type Qualifiers），用于告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。</p>
</blockquote>
<h6 id="pthread-mutex-destroy函数"><a href="#pthread-mutex-destroy函数" class="headerlink" title="pthread_mutex_destroy函数"></a>pthread_mutex_destroy函数</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    销毁指定的一个互斥锁。互斥锁在使用完毕后，必须要对互斥锁进行销毁，以释放资源。</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br></pre></td></tr></table></figure>

<h6 id="pthread-mutex-lock函数"><a href="#pthread-mutex-lock函数" class="headerlink" title="pthread_mutex_lock函数"></a>pthread_mutex_lock函数</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    对互斥锁上锁，若互斥锁已经上锁，则调用者阻塞，直到互斥锁解锁后再上锁。</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">   调用该函数时，若互斥锁未加锁，则上锁，返回 <span class="number">0</span>；</span><br><span class="line">   若互斥锁已加锁，则函数直接返回失败，即 EBUSY。</span><br></pre></td></tr></table></figure>

<h6 id="pthread-mutex-unlock函数"><a href="#pthread-mutex-unlock函数" class="headerlink" title="pthread_mutex_unlock函数"></a>pthread_mutex_unlock函数</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    对指定的互斥锁解锁。</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul>
<li>是使用锁不恰当导致的现象：</li>
</ul>
<ol>
<li>对一个锁反复lock</li>
<li>两个线程，各自持有一把锁，请求另一把。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wzhvv/image/main/image/202309071905447.png" alt="Snipaste_2023-09-07_19-03-25"></p>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><ul>
<li><strong>锁只有一把。</strong>以读方式给数据加锁 – 读锁。以写方式给数据加锁 – 写锁。</li>
<li><strong>读共享，写独占。</strong></li>
<li><strong>写锁优先级高</strong>。</li>
<li>相较于互斥量而言，当读线程多的时候，提高访问效率</li>
</ul>
<h5 id="主要应用函数"><a href="#主要应用函数" class="headerlink" title="主要应用函数"></a>主要应用函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_rwlock_init函数</span><br><span class="line">pthread_rwlock_destroy函数</span><br><span class="line">pthread_rwlock_rdlock函数</span><br><span class="line">pthread_rwlock_wrlock函数</span><br><span class="line">pthread_rwlock_tryrdlock函数</span><br><span class="line">pthread_rwlock_trywrlock函数</span><br><span class="line">pthread_rwlock_unlock函数   </span><br><span class="line">以上<span class="number">7</span>个函数的返回值都是：成功返回<span class="number">0</span>，失败返回非<span class="number">0</span>，错误号errno</span><br><span class="line"><span class="type">pthread_rwlock_t</span>类型 用于定义一个读写锁变量</span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock    </span><br></pre></td></tr></table></figure>

<h5 id="pthread-rwlock-init函数"><a href="#pthread-rwlock-init函数" class="headerlink" title="pthread_rwlock_init函数"></a>pthread_rwlock_init函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    用来初始化 rwlock 所指向的读写锁。</span><br><span class="line">​</span><br><span class="line">参数：</span><br><span class="line">    rwlock：指向要初始化的读写锁指针。</span><br><span class="line">    attr：读写锁的属性指针。如果 attr 为 <span class="literal">NULL</span> 则会使用默认的属性初始化读写锁，否则使用指定的 attr 初始化读写锁。</span><br><span class="line">​</span><br><span class="line">    可以使用宏 PTHREAD_RWLOCK_INITIALIZER 静态初始化读写锁，比如：</span><br><span class="line">    <span class="type">pthread_rwlock_t</span> my_rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line">​</span><br><span class="line">    这种方法等价于使用 <span class="literal">NULL</span> 指定的 attr 参数调用 pthread_rwlock_init() 来完成动态初始化，不同之处在于PTHREAD_RWLOCK_INITIALIZER 宏不进行错误检查。</span><br><span class="line">​</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span>，读写锁的状态将成为已初始化和已解锁。</span><br><span class="line">    失败：非 <span class="number">0</span> 错误码。</span><br></pre></td></tr></table></figure>

<h5 id="pthread-rwlock-destroy函数"><a href="#pthread-rwlock-destroy函数" class="headerlink" title="pthread_rwlock_destroy函数"></a>pthread_rwlock_destroy函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    用于销毁一个读写锁，并释放所有相关联的资源（所谓的所有指的是由 pthread_rwlock_init() 自动申请的资源） 。</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br></pre></td></tr></table></figure>

<h5 id="pthread-rwlock-rdlock函数"><a href="#pthread-rwlock-rdlock函数" class="headerlink" title="pthread_rwlock_rdlock函数"></a>pthread_rwlock_rdlock函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    以阻塞方式在读写锁上获取读锁（读锁定）。</span><br><span class="line">    如果没有写者持有该锁，并且没有写者阻塞在该锁上，则调用线程会获取读锁。</span><br><span class="line">    如果调用线程未获取读锁，则它将阻塞直到它获取了该锁。一个线程可以在一个读写锁上多次执行读锁定。</span><br><span class="line">    线程可以成功调用 pthread_rwlock_rdlock() 函数 n 次，但是之后该线程必须调用 pthread_rwlock_unlock() 函数 n 次才能解除锁定。</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">   用于尝试以非阻塞的方式来在读写锁上获取读锁。</span><br><span class="line">   如果有任何的写者持有该锁或有写者阻塞在该读写锁上，则立即失败返回。</span><br></pre></td></tr></table></figure>

<h5 id="pthread-rwlock-wrlock函数"><a href="#pthread-rwlock-wrlock函数" class="headerlink" title="pthread_rwlock_wrlock函数"></a>pthread_rwlock_wrlock函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    在读写锁上获取写锁（写锁定）。</span><br><span class="line">    如果没有写者持有该锁，并且没有写者读者持有该锁，则调用线程会获取写锁。</span><br><span class="line">    如果调用线程未获取写锁，则它将阻塞直到它获取了该锁。</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">   用于尝试以非阻塞的方式来在读写锁上获取写锁。</span><br><span class="line">   如果有任何的读者或写者持有该锁，则立即失败返回。</span><br></pre></td></tr></table></figure>

<h5 id="pthread-rwlock-unlock函数"><a href="#pthread-rwlock-unlock函数" class="headerlink" title="pthread_rwlock_unlock函数"></a>pthread_rwlock_unlock函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    无论是读锁或写锁，都可以通过此函数解锁。</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br></pre></td></tr></table></figure>

<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><ul>
<li><strong>条件变量本身不是锁</strong>。但它也可以造成线程阻塞。<strong>通常与互斥锁配合使用</strong>。给多线程提供一个会合的场所。</li>
</ul>
<h5 id="主要应用函数-1"><a href="#主要应用函数-1" class="headerlink" title="主要应用函数"></a>主要应用函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_cond_init函数</span><br><span class="line">pthread_cond_destroy函数 </span><br><span class="line">pthread_cond_wait函数  </span><br><span class="line">pthread_cond_timewait函数</span><br><span class="line">pthread_cond_signal函数</span><br><span class="line">pthread_cond_broadcast函数  </span><br><span class="line">以上<span class="number">6</span>个函数的返回值都是：成功返回<span class="number">0</span>，失败返回错误号</span><br><span class="line"><span class="type">pthread_cond_t</span>类型 用于定义条件变量</span><br><span class="line"><span class="type">pthread_cond_t</span> cond </span><br><span class="line">    </span><br><span class="line">初始化条件变量：</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond;	</span><br><span class="line">	<span class="number">1.</span>pthread_cond_init(&amp;cond,<span class="literal">NULL</span>);					动态初始化</span><br><span class="line">	<span class="number">2.</span><span class="type">pthread_cond_t</span> cond=PTHREAD_COND_INITIALIZER;		静态初始化   </span><br><span class="line">        </span><br><span class="line">pthread_cond_signal()：唤醒阻塞在条件变量上的 (至少)一个线程 </span><br><span class="line">pthread_con_broadcast()：唤醒阻塞在条件变量上的 所有线程        </span><br></pre></td></tr></table></figure>

<h5 id="pthread-cond-init函数"><a href="#pthread-cond-init函数" class="headerlink" title="pthread_cond_init函数"></a>pthread_cond_init函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    初始化一个条件变量</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针。</span><br><span class="line">    attr：条件变量属性，通常为默认值，传<span class="literal">NULL</span>即可</span><br><span class="line">        也可以使用静态初始化的方法，初始化条件变量：</span><br><span class="line">        <span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<h5 id="pthread-cond-destroy函数"><a href="#pthread-cond-destroy函数" class="headerlink" title="pthread_cond_destroy函数"></a>pthread_cond_destroy函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    销毁一个条件变量</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<h5 id="pthread-cond-wait函数"><a href="#pthread-cond-wait函数" class="headerlink" title="pthread_cond_wait函数"></a>pthread_cond_wait函数</h5><p><img src="C:\Users\27458\AppData\Roaming\Typora\typora-user-images\image-20231105135708680.png" alt="image-20231105135708680"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">    <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    阻塞等待一个条件变量</span><br><span class="line">    a) 阻塞等待条件变量cond（参<span class="number">1</span>）满足</span><br><span class="line">    b) 释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            a) b) 两步为一个原子操作。</span><br><span class="line">    c) 当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex);</span><br><span class="line">​</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">    mutex：互斥锁</span><br><span class="line">​</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">    <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span></span></span><br><span class="line"><span class="params">                           .*<span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line">功能：</span><br><span class="line">    限时等待一个条件变量</span><br><span class="line">​</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">    mutex：互斥锁</span><br><span class="line">    abstime：绝对时间</span><br><span class="line">​</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;      <span class="comment">/* seconds */</span> <span class="comment">// 秒</span></span><br><span class="line">    <span class="type">long</span>   tv_nsec; <span class="comment">/* nanosecondes*/</span> <span class="comment">// 纳秒</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="type">time_t</span> cur = time(<span class="literal">NULL</span>);        <span class="comment">//获取当前时间。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span>;</span>              <span class="comment">//定义timespec 结构体变量t</span></span><br><span class="line">t.tv_sec = cur + <span class="number">1</span>;             <span class="comment">// 定时1秒</span></span><br><span class="line">pthread_cond_timedwait(&amp;cond, &amp;t);</span><br></pre></td></tr></table></figure>

<h5 id="pthread-cond-signal函数"><a href="#pthread-cond-signal函数" class="headerlink" title="pthread_cond_signal函数"></a>pthread_cond_signal函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    唤醒至少一个阻塞在条件变量上的线程</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    唤醒全部阻塞在条件变量上的线程</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul>
<li>应用于线程，进程间同步。</li>
<li>相当于 初始化值为 N 的互斥量。N值，表示可以同时访问共享数据区的线程数。</li>
</ul>
<h5 id="主要应用函数-2"><a href="#主要应用函数-2" class="headerlink" title="主要应用函数"></a>主要应用函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sem_init函数</span><br><span class="line">sem_destroy函数</span><br><span class="line">sem_wait函数</span><br><span class="line">sem_trywait函数</span><br><span class="line">sem_timewait函数</span><br><span class="line">sem_post函数 </span><br><span class="line">以上<span class="number">6</span>个函数的返回值都是：成功返回<span class="number">0</span>，失败返回<span class="number">-1</span>，同时设置errno。</span><br><span class="line">    <span class="type">sem_t</span>类型，本质仍是结构体。但应用期间可简单看作为整数，忽略实现细节(类似于使用文件描述符)。</span><br><span class="line">    <span class="type">sem_t</span> sem：规定信号量sem不能&lt;<span class="number">0</span>。  头文件&lt;semaphore.h&gt;</span><br></pre></td></tr></table></figure>

<h5 id="sem-init函数"><a href="#sem-init函数" class="headerlink" title="sem_init函数"></a>sem_init函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">功能：</span><br><span class="line">    创建一个信号量并初始化它的值。一个无名信号量在被使用前必须先初始化。</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量的地址。</span><br><span class="line">    pshared：等于 <span class="number">0</span>，信号量在线程间共享（常用）；不等于<span class="number">0</span>，信号量在进程间共享。</span><br><span class="line">    value：信号量的初始值。(指定同时访问的线程数)</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h5 id="sem-destroy函数"><a href="#sem-destroy函数" class="headerlink" title="sem_destroy函数"></a>sem_destroy函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">功能：</span><br><span class="line">    删除 sem 标识的信号量。</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h5 id="信号量P操作-减1"><a href="#信号量P操作-减1" class="headerlink" title="信号量P操作(减1)"></a>信号量P操作(减1)</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将信号量的值减 <span class="number">1</span>。操作前，先检查信号量（sem）的值是否为 <span class="number">0</span>，若信号量为 <span class="number">0</span>，此函数会阻塞，直到信号量大于 <span class="number">0</span> 时才进行减 <span class="number">1</span> 操作。</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量的地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败： - <span class="number">1</span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">   以非阻塞的方式来对信号量进行减 <span class="number">1</span> 操作。</span><br><span class="line">   若操作前，信号量的值等于 <span class="number">0</span>，则对信号量的操作失败，函数立即返回。</span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line">   限时尝试将信号量的值减 <span class="number">1</span></span><br><span class="line">   abs_timeout：绝对时间</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;      <span class="comment">/* seconds */</span> <span class="comment">// 秒</span></span><br><span class="line">    <span class="type">long</span>   tv_nsec; <span class="comment">/* nanosecondes*/</span> <span class="comment">// 纳秒</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="type">time_t</span> cur = time(<span class="literal">NULL</span>);        <span class="comment">//获取当前时间。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span>;</span>              <span class="comment">//定义timespec 结构体变量t</span></span><br><span class="line">t.tv_sec = cur + <span class="number">1</span>;             <span class="comment">// 定时1秒</span></span><br><span class="line">sem_timedwait(&amp;cond, &amp;t);</span><br></pre></td></tr></table></figure>

<h5 id="信号量V操作-加1"><a href="#信号量V操作-加1" class="headerlink" title="信号量V操作(加1)"></a>信号量V操作(加1)</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将信号量的值加 <span class="number">1</span> 并发出信号唤醒等待线程（sem_wait()）。</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量的地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

























<h2 id="Linux随记"><a href="#Linux随记" class="headerlink" title="Linux随记"></a>Linux随记</h2><h3 id="关于僵尸进程和孤儿进程"><a href="#关于僵尸进程和孤儿进程" class="headerlink" title="关于僵尸进程和孤儿进程"></a>关于僵尸进程和孤儿进程</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为<span class="number">1</span>)所收养，并由init进程对它们完成状态收集工作。</span><br><span class="line">   僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有使用wait或waitpid获取子进程的状态信息，那么子进程的进程描述仍然保存在系统中。这种进程称之为僵尸进程。</span><br><span class="line">如何处理：</span><br><span class="line">       孤儿进程将由init接管，成为init的子进程，然后回收资源。</span><br><span class="line">       僵尸进程的危害主要是占用进程描述符。在出现大量僵尸进程的时候，系统会杀死产生僵尸进程的父进程(因为僵尸进程的产生主要是因为父进程出错，没有获取子进程的状态)。在杀死父进程后，僵尸进程就会全部变成孤儿进程，由init接管，回收资源</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">wzhvv</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/11/25/Linux/">http://example.com/2023/11/25/Linux/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">HAO</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/10/14/project/" title="数据安全传输"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据安全传输</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wzhvv</div><div class="author-info__description">学海无涯苦作舟</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wzhvv"><i class="wzhvv-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wzhvv" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2745853490@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">Linux学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF"><span class="toc-number">1.1.</span> <span class="toc-text">终端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shell%E5%AE%B6%E6%97%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">shell家族</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.</span> <span class="toc-text">类Unix系统目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.</span> <span class="toc-text">Linux命令基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ls%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.1.</span> <span class="toc-text">ls命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cd%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.2.</span> <span class="toc-text">cd命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pwd%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.3.</span> <span class="toc-text">pwd命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mkdir%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.4.</span> <span class="toc-text">mkdir命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#touch%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.5.</span> <span class="toc-text">touch命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cat%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.6.</span> <span class="toc-text">cat命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#more-x2F-less%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.7.</span> <span class="toc-text">more&#x2F;less命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#head%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.8.</span> <span class="toc-text">head命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tail%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.9.</span> <span class="toc-text">tail命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tree%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.10.</span> <span class="toc-text">tree命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cp%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.11.</span> <span class="toc-text">cp命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mv%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.12.</span> <span class="toc-text">mv命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rm%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.13.</span> <span class="toc-text">rm命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#which%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.14.</span> <span class="toc-text">which命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.15.</span> <span class="toc-text">find命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#grep%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.16.</span> <span class="toc-text">grep命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wc%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.17.</span> <span class="toc-text">wc命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#whoami%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.18.</span> <span class="toc-text">whoami命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%AC%A6"><span class="toc-number">1.3.19.</span> <span class="toc-text">管道符 |</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#echo%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.20.</span> <span class="toc-text">echo命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#96-%E5%8F%8D%E5%BC%95%E5%8F%B7%E7%AC%A6"><span class="toc-number">1.3.21.</span> <span class="toc-text">&#96;反引号符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%A6"><span class="toc-number">1.3.22.</span> <span class="toc-text">重定向符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vi%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">1.3.23.</span> <span class="toc-text">vi编辑器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vi%E5%9F%BA%E6%9C%AC%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">1.3.24.</span> <span class="toc-text">vi基本快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vim%E9%85%8D%E7%BD%AE"><span class="toc-number">1.3.25.</span> <span class="toc-text">vim配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E7%9A%84root%E7%94%A8%E6%88%B7-%E8%B6%85%E7%BA%A7%E7%AE%A1%E7%90%86%E5%91%98"><span class="toc-number">1.3.26.</span> <span class="toc-text">Linux的root用户(超级管理员)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#su%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.26.1.</span> <span class="toc-text">su命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sudo%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.26.2.</span> <span class="toc-text">sudo命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%EF%BC%8C%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-number">1.3.27.</span> <span class="toc-text">用户，用户组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.27.1.</span> <span class="toc-text">用户组管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.27.2.</span> <span class="toc-text">用户管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.28.</span> <span class="toc-text">查看权限控制信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A4%E7%9F%A5%E6%9D%83%E9%99%90%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.28.1.</span> <span class="toc-text">认知权限信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rwx"><span class="toc-number">1.3.28.2.</span> <span class="toc-text">rwx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.28.3.</span> <span class="toc-text">Linux系统文件类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chmod%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.29.</span> <span class="toc-text">chmod命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%9A%84%E6%95%B0%E5%AD%97%E5%BA%8F%E5%8F%B7"><span class="toc-number">1.3.29.1.</span> <span class="toc-text">权限的数字序号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chown%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.30.</span> <span class="toc-text">chown命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">1.3.31.</span> <span class="toc-text">快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85"><span class="toc-number">1.3.32.</span> <span class="toc-text">软件安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#systemctl%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.33.</span> <span class="toc-text">systemctl命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ln%E5%91%BD%E4%BB%A4%E5%88%9B%E5%BB%BA%E8%BD%AF%E9%93%BE%E6%8E%A5"><span class="toc-number">1.3.34.</span> <span class="toc-text">ln命令创建软链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-number">1.3.35.</span> <span class="toc-text">硬链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#date%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.36.</span> <span class="toc-text">date命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9Linux%E6%97%B6%E5%8C%BA"><span class="toc-number">1.3.37.</span> <span class="toc-text">修改Linux时区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ntp%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.38.</span> <span class="toc-text">ntp命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ip%E5%9C%B0%E5%9D%80%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%90%8D"><span class="toc-number">1.3.39.</span> <span class="toc-text">ip地址和主机名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ip%E5%9C%B0%E5%9D%80"><span class="toc-number">1.3.39.1.</span> <span class="toc-text">ip地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8Aip%E5%9C%B0%E5%9D%80"><span class="toc-number">1.3.39.2.</span> <span class="toc-text">特殊ip地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E5%90%8D"><span class="toc-number">1.3.39.3.</span> <span class="toc-text">主机名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90"><span class="toc-number">1.3.39.4.</span> <span class="toc-text">域名解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%BB%E6%9C%BA%E5%90%8D%E6%98%A0%E5%B0%84"><span class="toc-number">1.3.39.5.</span> <span class="toc-text">配置主机名映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AELinux%E5%9B%BA%E5%AE%9Aip%E5%9C%B0%E5%9D%80"><span class="toc-number">1.3.40.</span> <span class="toc-text">配置Linux固定ip地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%BA%E5%AE%9Aip"><span class="toc-number">1.3.40.1.</span> <span class="toc-text">为什么需要固定ip</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%92%8C%E4%B8%8B%E8%BD%BD"><span class="toc-number">1.3.41.</span> <span class="toc-text">网络请求和下载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ping%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.41.1.</span> <span class="toc-text">ping命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wget%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.41.2.</span> <span class="toc-text">wget命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#curl%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.41.3.</span> <span class="toc-text">curl命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.3.42.</span> <span class="toc-text">端口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%AB%AF%E5%8F%A3%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.42.1.</span> <span class="toc-text">虚拟端口作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.43.</span> <span class="toc-text">端口分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8"><span class="toc-number">1.3.44.</span> <span class="toc-text">查看端口占用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9"><span class="toc-number">1.3.45.</span> <span class="toc-text">压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8B"><span class="toc-number">1.3.46.</span> <span class="toc-text">解压</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gcc%E7%BC%96%E8%AF%91"><span class="toc-number">1.3.47.</span> <span class="toc-text">gcc编译</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gcc%E7%BC%96%E8%AF%91%E5%9B%9B%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.3.47.1.</span> <span class="toc-text">gcc编译四步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gcc%E7%BC%96%E8%AF%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.47.2.</span> <span class="toc-text">gcc编译常用命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">1.3.48.</span> <span class="toc-text">静态库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C"><span class="toc-number">1.3.48.1.</span> <span class="toc-text">静态库制作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E5%AE%88%E5%8D%AB%EF%BC%9A%E9%98%B2%E6%AD%A2%E5%A4%B4%E6%96%87%E4%BB%B6%E8%A2%AB%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB"><span class="toc-number">1.3.48.2.</span> <span class="toc-text">头文件守卫：防止头文件被重复包含</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">1.3.49.</span> <span class="toc-text">动态库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C"><span class="toc-number">1.3.49.1.</span> <span class="toc-text">动态库制作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5%E5%90%88%E5%B9%B6"><span class="toc-number">1.3.50.</span> <span class="toc-text">数据段合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gdb%E8%B0%83%E8%AF%95-%E8%B0%83%E8%AF%95%E9%80%BB%E8%BE%91%E9%94%99%E8%AF%AF"><span class="toc-number">1.3.51.</span> <span class="toc-text">gdb调试(调试逻辑错误)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.51.1.</span> <span class="toc-text">基础命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.51.2.</span> <span class="toc-text">其他命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#makefile"><span class="toc-number">1.3.52.</span> <span class="toc-text">makefile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.53.</span> <span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#open-x2F-close%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.54.</span> <span class="toc-text">open&#x2F;close函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%9A"><span class="toc-number">1.3.54.1.</span> <span class="toc-text">函数原型：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0-flags%E5%8F%96%E5%80%BC"><span class="toc-number">1.3.54.2.</span> <span class="toc-text">常用参数(flags取值)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.3.54.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.54.4.</span> <span class="toc-text">头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#open%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%EF%BC%9A"><span class="toc-number">1.3.54.5.</span> <span class="toc-text">open常见错误：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#read%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.54.6.</span> <span class="toc-text">read函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#write%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.54.7.</span> <span class="toc-text">write函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.54.8.</span> <span class="toc-text">系统调用和库函数的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#strace%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.54.8.1.</span> <span class="toc-text">strace命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.3.54.8.2.</span> <span class="toc-text">缓冲区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E8%AF%BB%E5%85%A5%E7%BC%93%E8%BE%93%E5%87%BA"><span class="toc-number">1.3.54.8.3.</span> <span class="toc-text">预读入缓输出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.3.55.</span> <span class="toc-text">文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9E-%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%EF%BC%8C%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.56.</span> <span class="toc-text">阻塞，非阻塞(设备文件，网络文件的属性)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fcntl%E6%94%B9%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.57.</span> <span class="toc-text">fcntl改文件属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lseek%E5%87%BD%E6%95%B0-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">1.3.58.</span> <span class="toc-text">lseek函数(修改文件偏移量)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%85%A5%E4%BC%A0%E5%87%BA%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.59.</span> <span class="toc-text">传入传出参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.60.</span> <span class="toc-text">文件存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#inode"><span class="toc-number">1.3.60.1.</span> <span class="toc-text">inode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dentry"><span class="toc-number">1.3.60.2.</span> <span class="toc-text">dentry</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stat-x2F-lstat%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.61.</span> <span class="toc-text">stat&#x2F;lstat函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stat%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.61.1.</span> <span class="toc-text">stat函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lstat%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.61.2.</span> <span class="toc-text">lstat函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#link%E5%92%8Cunlink%E9%9A%90%E5%BC%8F%E5%9B%9E%E6%94%B6"><span class="toc-number">1.3.62.</span> <span class="toc-text">link和unlink隐式回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#link%E5%87%BD%E6%95%B0-%E5%8F%AF%E4%BB%A5%E4%B8%BA%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95%E9%A1%B9-%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-number">1.3.62.1.</span> <span class="toc-text">link函数(可以为已经存在的文件创建目录项(硬链接))</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unlink%E5%87%BD%E6%95%B0-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95%E9%A1%B9"><span class="toc-number">1.3.62.2.</span> <span class="toc-text">unlink函数(删除一个文件的目录项)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%9B%9E%E6%94%B6"><span class="toc-number">1.3.62.3.</span> <span class="toc-text">隐式回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readlink%E5%87%BD%E6%95%B0-%E8%AF%BB%E5%8F%96%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6%E6%9C%AC%E8%BA%AB%E5%86%85%E5%AE%B9%EF%BC%8C%E5%BE%97%E5%88%B0%E9%93%BE%E6%8E%A5%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-number">1.3.62.4.</span> <span class="toc-text">readlink函数(读取符号链接文件本身内容，得到链接所指向的文件名)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rename%E5%87%BD%E6%95%B0-%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.62.5.</span> <span class="toc-text">rename函数(重命名一个文件)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getcwd%E5%87%BD%E6%95%B0-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95-%E2%80%93-gt-%E7%9B%B8%E5%BD%93%E4%BA%8Epwd"><span class="toc-number">1.3.62.6.</span> <span class="toc-text">getcwd函数(获取当前工作目录) –&gt; 相当于pwd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chdir%E5%87%BD%E6%95%B0-%E6%94%B9%E5%8F%98%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95-%E2%80%93-gt-%E7%9B%B8%E5%BD%93%E4%BA%8Ecd"><span class="toc-number">1.3.62.7.</span> <span class="toc-text">chdir函数(改变当前进程的工作目录) –&gt; 相当于cd</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90"><span class="toc-number">1.3.63.</span> <span class="toc-text">文件目录权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.64.</span> <span class="toc-text">目录操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#opendir%E5%87%BD%E6%95%B0-%E6%A0%B9%E6%8D%AE%E4%BC%A0%E5%85%A5%E7%9A%84%E7%9B%AE%E5%BD%95%E5%90%8D%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E7%9B%AE%E5%BD%95-%E5%BA%93%E5%87%BD%E6%95%B0-DIR-%E7%B1%BB%E4%BC%BC%E4%BA%8E-FILE"><span class="toc-number">1.3.64.1.</span> <span class="toc-text">opendir函数(根据传入的目录名打开一个目录(库函数))		DIR * 类似于 FILE *</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#closedir%E5%87%BD%E6%95%B0-%E5%85%B3%E9%97%AD%E6%89%93%E5%BC%80%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="toc-number">1.3.64.2.</span> <span class="toc-text">closedir函数(关闭打开的目录)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readdir%E5%87%BD%E6%95%B0-%E8%AF%BB%E5%8F%96%E7%9B%AE%E5%BD%95-%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.64.3.</span> <span class="toc-text">readdir函数(读取目录(库函数))</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%EF%BC%9Als-R"><span class="toc-number">1.3.65.</span> <span class="toc-text">递归遍历目录：ls -R</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dup%E5%87%BD%E6%95%B0-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">1.3.66.</span> <span class="toc-text">dup函数(重定向)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dup%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.66.1.</span> <span class="toc-text">dup函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dup2%E5%87%BD%E6%95%B0-dup-to"><span class="toc-number">1.3.66.2.</span> <span class="toc-text">dup2函数 (dup to)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.67.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCB%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">1.3.68.</span> <span class="toc-text">PCB进程控制块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.69.</span> <span class="toc-text">fork函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%90%8C%EF%BC%9A"><span class="toc-number">1.3.69.1.</span> <span class="toc-text">父子进程相同：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="toc-number">1.3.69.2.</span> <span class="toc-text">父子进程不同：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%EF%BC%9A"><span class="toc-number">1.3.69.3.</span> <span class="toc-text">父子进程共享：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gdb%E8%B0%83%E8%AF%95"><span class="toc-number">1.3.69.4.</span> <span class="toc-text">gdb调试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-number">1.3.70.</span> <span class="toc-text">exec函数族</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#execlp%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.70.1.</span> <span class="toc-text">execlp函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#execl%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.70.2.</span> <span class="toc-text">execl函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.71.</span> <span class="toc-text">回收子进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.71.1.</span> <span class="toc-text">孤儿进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.71.2.</span> <span class="toc-text">僵尸进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wait%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.71.3.</span> <span class="toc-text">wait函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#waitpid%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.71.4.</span> <span class="toc-text">waitpid函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.72.</span> <span class="toc-text">进程间通信常见方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">1.3.73.</span> <span class="toc-text">管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.73.1.</span> <span class="toc-text">管道的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.3.73.2.</span> <span class="toc-text">管道基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E8%AF%BB%E5%86%99%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.3.73.3.</span> <span class="toc-text">管道读写行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.3.73.4.</span> <span class="toc-text">管道缓冲区大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E4%BC%98%E5%8A%A3"><span class="toc-number">1.3.73.5.</span> <span class="toc-text">管道的优劣</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FIFO"><span class="toc-number">1.3.73.6.</span> <span class="toc-text">FIFO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84I-x2F-O"><span class="toc-number">1.3.74.</span> <span class="toc-text">存储映射I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap%E5%87%BD%E6%95%B0-%E5%A4%B4%E6%96%87%E4%BB%B6sys-x2F-mman-h"><span class="toc-number">1.3.74.1.</span> <span class="toc-text">mmap函数(头文件sys&#x2F;mman.h)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#munmap%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.74.2.</span> <span class="toc-text">munmap函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">1.3.74.3.</span> <span class="toc-text">使用注意事项：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">1.3.74.4.</span> <span class="toc-text">mmap父子进程通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap%E6%97%A0%E8%A1%80%E7%BC%98%E5%85%B3%E7%B3%BB%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">1.3.74.5.</span> <span class="toc-text">mmap无血缘关系进程间通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E6%98%A0%E5%B0%84"><span class="toc-number">1.3.74.6.</span> <span class="toc-text">匿名映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.3.75.</span> <span class="toc-text">信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.75.1.</span> <span class="toc-text">信号的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.75.1.1.</span> <span class="toc-text">信号的机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8E%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.75.1.2.</span> <span class="toc-text">与信号相关的事件和状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%BC%96%E5%8F%B7"><span class="toc-number">1.3.75.1.3.</span> <span class="toc-text">信号的编号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%9B%9B%E8%A6%81%E7%B4%A0"><span class="toc-number">1.3.75.1.4.</span> <span class="toc-text">信号四要素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-number">1.3.75.2.</span> <span class="toc-text">信号的产生</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#kill%E5%87%BD%E6%95%B0-x2F-%E5%91%BD%E4%BB%A4%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.3.75.2.1.</span> <span class="toc-text">kill函数&#x2F;命令产生信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%87%A0%E4%B8%AA%E5%8F%91%E4%BF%A1%E5%8F%B7%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.75.2.2.</span> <span class="toc-text">其他几个发信号函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%9D%A1%E4%BB%B6%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.3.75.2.3.</span> <span class="toc-text">软件条件产生信号</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#alarm%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.75.2.3.1.</span> <span class="toc-text">alarm函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#setitimer%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.75.2.3.2.</span> <span class="toc-text">setitimer函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.75.3.</span> <span class="toc-text">信号集概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E8%AE%BE%E5%AE%9A"><span class="toc-number">1.3.75.3.1.</span> <span class="toc-text">信号集设定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sigprocmask%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.75.3.2.</span> <span class="toc-text">sigprocmask函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sigpending%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.75.3.3.</span> <span class="toc-text">sigpending函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89"><span class="toc-number">1.3.75.4.</span> <span class="toc-text">信号捕捉</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#signal%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.75.4.1.</span> <span class="toc-text">signal函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sigaction%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.75.4.2.</span> <span class="toc-text">sigaction函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.75.4.3.</span> <span class="toc-text">信号捕捉特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.75.4.4.</span> <span class="toc-text">内核实现信号捕捉过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SIGCHLD%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.3.75.5.</span> <span class="toc-text">SIGCHLD信号</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#SIGCHLD%E7%9A%84%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.3.75.5.0.1.</span> <span class="toc-text">SIGCHLD的产生条件</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%92%8C%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.3.76.</span> <span class="toc-text">进程组和会话</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.76.1.</span> <span class="toc-text">概念和特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.3.76.2.</span> <span class="toc-text">创建会话</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getsid%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.3.76.3.</span> <span class="toc-text">getsid函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setsid%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.3.76.4.</span> <span class="toc-text">setsid函数：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.77.</span> <span class="toc-text">守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.77.1.</span> <span class="toc-text">创建守护进程模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.78.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.78.1.</span> <span class="toc-text">什么是线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.78.2.</span> <span class="toc-text">Linux内核线程实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="toc-number">1.3.78.3.</span> <span class="toc-text">线程共享资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%9D%9E%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="toc-number">1.3.78.4.</span> <span class="toc-text">线程非共享资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.3.78.5.</span> <span class="toc-text">线程优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.3.79.</span> <span class="toc-text">线程控制原语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-self%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.79.1.</span> <span class="toc-text">pthread_self函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-create%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.79.2.</span> <span class="toc-text">pthread_create函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-exit-%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.79.3.</span> <span class="toc-text">pthread_exit()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-join%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.79.4.</span> <span class="toc-text">pthread_join函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-detach%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.79.5.</span> <span class="toc-text">pthread_detach函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-cancel%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.79.6.</span> <span class="toc-text">pthread_cancel函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8E%9F%E8%AF%AD%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.79.7.</span> <span class="toc-text">进程和线程控制原语对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.3.79.8.</span> <span class="toc-text">线程使用注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.3.80.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B7%B7%E4%B9%B1%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.3.80.1.</span> <span class="toc-text">数据混乱原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8FMutex"><span class="toc-number">1.3.80.2.</span> <span class="toc-text">互斥量Mutex</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.3.80.2.1.</span> <span class="toc-text">主要应用函数：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#pthread-mutex-init%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.80.2.1.1.</span> <span class="toc-text">pthread_mutex_init函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#pthread-mutex-destroy%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.80.2.1.2.</span> <span class="toc-text">pthread_mutex_destroy函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#pthread-mutex-lock%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.80.2.1.3.</span> <span class="toc-text">pthread_mutex_lock函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#pthread-mutex-unlock%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.80.2.1.4.</span> <span class="toc-text">pthread_mutex_unlock函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.3.80.3.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.3.80.4.</span> <span class="toc-text">读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.80.4.1.</span> <span class="toc-text">主要应用函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pthread-rwlock-init%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.80.4.2.</span> <span class="toc-text">pthread_rwlock_init函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pthread-rwlock-destroy%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.80.4.3.</span> <span class="toc-text">pthread_rwlock_destroy函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pthread-rwlock-rdlock%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.80.4.4.</span> <span class="toc-text">pthread_rwlock_rdlock函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pthread-rwlock-wrlock%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.80.4.5.</span> <span class="toc-text">pthread_rwlock_wrlock函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pthread-rwlock-unlock%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.80.4.6.</span> <span class="toc-text">pthread_rwlock_unlock函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.80.5.</span> <span class="toc-text">条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%87%BD%E6%95%B0-1"><span class="toc-number">1.3.80.5.1.</span> <span class="toc-text">主要应用函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pthread-cond-init%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.80.5.2.</span> <span class="toc-text">pthread_cond_init函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pthread-cond-destroy%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.80.5.3.</span> <span class="toc-text">pthread_cond_destroy函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pthread-cond-wait%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.80.5.4.</span> <span class="toc-text">pthread_cond_wait函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pthread-cond-signal%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.80.5.5.</span> <span class="toc-text">pthread_cond_signal函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.3.80.6.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%87%BD%E6%95%B0-2"><span class="toc-number">1.3.80.6.1.</span> <span class="toc-text">主要应用函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sem-init%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.80.6.2.</span> <span class="toc-text">sem_init函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sem-destroy%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.80.6.3.</span> <span class="toc-text">sem_destroy函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8FP%E6%93%8D%E4%BD%9C-%E5%87%8F1"><span class="toc-number">1.3.80.6.4.</span> <span class="toc-text">信号量P操作(减1)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8FV%E6%93%8D%E4%BD%9C-%E5%8A%A01"><span class="toc-number">1.3.80.6.5.</span> <span class="toc-text">信号量V操作(加1)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E9%9A%8F%E8%AE%B0"><span class="toc-number">1.4.</span> <span class="toc-text">Linux随记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">关于僵尸进程和孤儿进程</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/25/Linux/" title="Linux">Linux</a><time datetime="2023-11-25T06:19:44.000Z" title="发表于 2023-11-25 14:19:44">2023-11-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/14/project/" title="数据安全传输">数据安全传输</a><time datetime="2023-10-14T08:20:40.000Z" title="发表于 2023-10-14 16:20:40">2023-10-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/29/python/" title="python">python</a><time datetime="2023-09-29T08:22:24.000Z" title="发表于 2023-09-29 16:22:24">2023-09-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/15/QT/" title="QT">QT</a><time datetime="2023-09-15T01:29:15.000Z" title="发表于 2023-09-15 09:29:15">2023-09-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/23/JavaWeb/" title="JavaWeb开发">JavaWeb开发</a><time datetime="2023-03-23T02:22:26.000Z" title="发表于 2023-03-23 10:22:26">2023-03-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By wzhvv</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://wzhvv.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>